// @ts-check
'use strict'

/**
 * @file VovkPLC.js
 * @description
 * This file and its companion 'VovkPLC.worker.js' are manually authored components of the VovkPLCRuntime WASM build.
 * They are deliberately hand-written to interface with the bare-metal WASM output generated by clang++ and wasm-ld.
 * This approach avoids standard library bloat, ensuring maximum portability and performance.
 *
 * DO NOT REMOVE OR RENAME THIS FILE OR 'VovkPLC.worker.js'.
 *
 * This module provides a high-level JavaScript wrapper class `VovkPLC` that manages the WebAssembly instance,
 * handles memory interactions, exposes the PLC API, and facilitates communication with the worker thread if used.
 */

const isNodeRuntime = typeof process !== 'undefined' && !!(process.versions && process.versions.node)

/**
 * Robust detection for shared memory and decoding capabilities.
 */
const checkSupport = () => {
    const support = {
        sab: typeof SharedArrayBuffer !== 'undefined',
        atomics: typeof Atomics !== 'undefined',
        decodeShared: false,
    }

    if (support.sab) {
        try {
            // Verify SAB is actually usable (might be blocked by COOP/COEP)
            new SharedArrayBuffer(8)

            // Check if TextDecoder can decode from SharedBufferView directly
            // This avoids an extra copy where supported (e.g. some browsers)
            const sab = new SharedArrayBuffer(1)
            const view = new Uint8Array(sab)
            new TextDecoder().decode(view)
            support.decodeShared = true
        } catch (e) {
            // @ts-ignore
            // If new SharedArrayBuffer throws, it's effectively unsupported
            if (e.name === 'ReferenceError' || e.name === 'TypeError') support.sab = false
        }
    }
    return support
}

const SUPPORT = checkSupport()

/**
 * Memory layout constants - matches runtime-lib.h
 * System partition is read-only from JS side to prevent accidental corruption.
 */
const MEMORY_LAYOUT = {
    SYSTEM_SIZE: 64,    // S: 0-63 (reserved for runtime)
    INPUT_SIZE: 64,     // X: 64-127
    OUTPUT_SIZE: 64,    // Y: 128-191
    MARKER_SIZE: 256,   // M: 192-447
    // T and C follow after markers
}

/**
 * @typedef {{
 *     initialize: () => void, // Initializes the runtime environment and resets internal state.
 *     printInfo: () => void, // Prints runtime configuration and version info to stdout.
 *     streamIn: (char: number) => boolean, // Receives a character byte into the input stream buffer. Returns false if buffer full.
 *     streamClear: () => void, // Clears the input stream buffer.
 *     loadAssembly: () => void, // Moves the streamed input buffer into the assembly compiler.
 *     downloadProgram: (size: number, crc: number) => number, // Loads a pre-compiled bytecode program from the input stream. Returns 0 on success, >0 on error (1=size, 2=crc).
 *     compileAssembly: (debug?: boolean) => boolean, // Compiles the loaded assembly code. Returns true if compilation failed.
 *     loadCompiledProgram: () => boolean, // Loads the compiled bytecode into the runtime memory. Returns false on success.
 *     runFullProgram: () => void, // Executes the loaded program fully (standard run).
 *     runFullProgramDebug: () => void, // Executes the loaded program with debug tracing enabled.
 *     uploadProgram: () => number, // Streams the current bytecode out via stdout. Returns the size of the program.
 *     getMemoryLocation: () => number, // Returns the offset of the main memory area.
 *     getMemoryArea: (address: number, size: number) => number, // Streams a requested memory area to stdout. Returns the size processed.
 *     writeMemoryByte: (address: number, byte: number) => number, // Writes a single byte to memory at the specified address. Returns 1 on success.
 *     writeMemoryByteMasked: (address: number, byte: number, mask: number) => number, // Writes a masked byte to memory. (mem & ~mask) | (byte & mask). Returns 1 on success.
 *     getLastCycleTimeUs: () => number, // Returns the execution time of the last cycle in microseconds.
 *     getMinCycleTimeUs: () => number, // Returns the minimum cycle time recorded in microseconds.
 *     getMaxCycleTimeUs: () => number, // Returns the maximum cycle time recorded in microseconds.
 *     getRamFree: () => number, // Returns the current free RAM in bytes.
 *     getMinRamFree: () => number, // Returns the minimum free RAM recorded.
 *     getMaxRamFree: () => number, // Returns the maximum free RAM recorded.
 *     resetDeviceHealth: () => void, // Resets the min/max statistics for cycle time and RAM usage.
 *     get_free_memory: () => number, // Returns currently free memory (allocator status).
 *     doNothing: () => void, // No-op function for testing overhead.
 *     setMillis: (millis: number) => void, // Sets the system millisecond counter.
 *     setMicros: (micros: number) => void, // Sets the system microsecond counter.
 *     getMillis: () => number, // Gets the system millisecond counter.
 *     getMicros: () => number, // Gets the system microsecond counter.
 *     setRuntimeOffsets: (systemOffset: number, inputOffset: number, outputOffset: number, markerOffset: number) => void, // Sets the memory offsets for system, input, output, and marker areas.
 *     run: () => number, // Executes a single program scan cycle. Returns status code.
 *     runDirty: () => number, // Executed a single cycle without cleaning certain flags (Dirty).
 *     run_unit_test: () => void, // Runs the internal unit test suite.
 *     run_custom_test: () => void, // Runs custom test routines defined in the build.
 *     downloadAssembly: (assembly: string) => boolean, // Helper: Downloads assembly string directly (calls streamIn + loadAssembly).
 *     extractProgram: () => { size: number, output: string }, // Helper: Extracts program (calls uploadProgram + readStream).
 *     memory: WebAssembly.Memory, // The main WebAssembly linear memory.
 *     lint_load_assembly: () => void, // Moves streamed input to the linter buffer.
 *     lint_run: () => void, // Runs the linter on the loaded assembly.
 *     lint_get_problem_count: () => number, // Returns the number of problems found by the linter.
 *     lint_get_problems_pointer: () => number, // Returns a pointer to the array of linter problem structs.
 *     stl_load_from_stream: () => void, // Loads STL code from the stream buffer into the STL compiler.
 *     stl_set_source: (ptr: number, len: number) => void, // Sets the STL source from a memory pointer.
 *     stl_compile: () => boolean, // Compiles the loaded STL code to PLCASM. Returns true on success.
 *     stl_compile_full: () => boolean, // Compiles STL code fully (STL → PLCASM → bytecode). Returns true on success.
 *     stl_get_output: () => number, // Returns a pointer to the generated PLCASM output.
 *     stl_get_output_length: () => number, // Returns the length of the generated PLCASM output.
 *     stl_has_error: () => boolean, // Returns true if there was an STL compilation error.
 *     stl_get_error: () => number, // Returns a pointer to the STL error message string.
 *     stl_get_error_line: () => number, // Returns the line number of the STL error.
 *     stl_get_error_column: () => number, // Returns the column number of the STL error.
 *     stl_output_to_stream: () => void, // Streams the generated PLCASM output to stdout.
 *     stl_lint_load_from_stream: () => void, // Loads STL code from the stream buffer into the STL linter.
 *     stl_lint_set_source: (ptr: number, len: number) => void, // Sets the STL source from a memory pointer.
 *     stl_lint_run: () => void, // Runs the STL linter on the loaded code.
 *     stl_lint_get_problem_count: () => number, // Returns the number of problems found by the STL linter.
 *     stl_lint_get_problems_pointer: () => number, // Returns a pointer to the array of STL linter problem structs.
 *     stl_lint_get_problem_type: (index: number) => number, // Returns the type of a specific STL linter problem.
 *     stl_lint_get_problem_line: (index: number) => number, // Returns the line number of a specific STL linter problem.
 *     stl_lint_get_problem_column: (index: number) => number, // Returns the column number of a specific STL linter problem.
 *     stl_lint_get_problem_length: (index: number) => number, // Returns the length of a specific STL linter problem.
 *     stl_lint_get_problem_message: (index: number) => number, // Returns a pointer to the message of a specific STL linter problem.
 *     stl_lint_get_output: () => void, // Streams the generated PLCASM output to stdout.
 *     stl_lint_get_output_length: () => number, // Returns the length of the generated PLCASM output.
 *     stl_lint_clear: () => void, // Clears the STL linter state.
 *     ladder_standalone_clear: () => void, // Clears the standalone Ladder compiler state.
 *     ladder_standalone_load_stream: () => void, // Loads Ladder Graph JSON from the stream buffer into the compiler.
 *     ladder_standalone_compile: () => number, // Compiles the loaded Ladder Graph to STL. Returns output length or -1.
 *     ladder_standalone_compile_full: () => boolean, // Compiles Ladder Graph fully (Ladder → STL → PLCASM → bytecode). Returns true on success.
 *     ladder_standalone_get_output: () => number, // Returns a pointer to the generated STL output.
 *     ladder_standalone_get_output_len: () => number, // Returns the length of the generated STL output.
 *     ladder_standalone_output_to_stream: () => void, // Streams the generated STL output to stdout.
 *     ladder_standalone_has_error: () => boolean, // Returns true if there was a Ladder Graph compilation error.
 *     ladder_standalone_get_error: () => number, // Returns a pointer to the Ladder Graph error message string.
 *     ladder_standalone_error_to_stream: () => void, // Streams the error message to stdout.
 *     plcscript_load_from_stream: () => void, // Loads PLCScript code from the stream buffer into the PLCScript compiler.
 *     plcscript_compile: () => boolean, // Compiles the loaded PLCScript code to PLCASM. Returns true on success.
 *     plcscript_hasError: () => boolean, // Returns true if there was a PLCScript compilation error.
 *     plcscript_getError: () => number, // Returns a pointer to the PLCScript error message string.
 *     plcscript_getErrorLine: () => number, // Returns the line number of the PLCScript error.
 *     plcscript_getErrorColumn: () => number, // Returns the column number of the PLCScript error.
 *     plcscript_getOutput: () => number, // Returns a pointer to the generated PLCASM output.
 *     plcscript_getOutputLength: () => number, // Returns the length of the generated PLCASM output.
 *     plcscript_output_to_stream: () => void, // Streams the generated PLCASM output to stdout.
 *     plcscript_reset: () => void, // Resets the PLCScript compiler state.
 *     st_compiler_load_from_stream: () => void, // Loads ST code from the stream buffer into the ST compiler.
 *     st_compiler_compile: () => number, // Compiles the loaded ST code to PLCScript. Returns 0 on success, 1 on error.
 *     st_compiler_has_error: () => number, // Returns 1 if there was an ST compilation error, 0 otherwise.
 *     st_compiler_get_error: () => number, // Returns a pointer to the ST error message string.
 *     st_compiler_get_error_line: () => number, // Returns the line number of the ST error.
 *     st_compiler_get_error_column: () => number, // Returns the column number of the ST error.
 *     st_compiler_get_error_token_text: () => number, // Returns a pointer to the ST error token text.
 *     st_compiler_get_output: () => number, // Returns a pointer to the generated PLCScript output.
 *     st_compiler_get_output_length: () => number, // Returns the length of the generated PLCScript output.
 *     st_compiler_output_to_stream: () => void, // Streams the generated PLCScript output to stdout.
 *     project_compile: (debug?: boolean | number) => boolean, // Compiles a project from the stream buffer. Returns true on success.
 *     project_compileString: (source: number, length: number, debug?: boolean) => boolean, // Compiles a project from a memory pointer. Returns true on success.
 *     project_getBytecode: () => number, // Returns a pointer to the compiled bytecode.
 *     project_getBytecodeLength: () => number, // Returns the length of the compiled bytecode.
 *     project_getChecksum: () => number, // Returns the CRC8 checksum of the compiled bytecode.
 *     project_hasError: () => boolean, // Returns true if there was a compilation error.
 *     project_getError: () => number, // Returns a pointer to the error message string.
 *     project_getErrorLine: () => number, // Returns the line number of the error.
 *     project_getErrorColumn: () => number, // Returns the column number of the error.
 *     project_getErrorFile: () => number, // Returns a pointer to the error file path string.
 *     project_getErrorBlock: () => number, // Returns a pointer to the error block name string.
 *     project_getErrorBlockLanguage: () => number, // Returns the language enum of the error block.
 *     project_getErrorCompiler: () => number, // Returns a pointer to the compiler name that produced the error.
 *     project_getErrorSourceLine: () => number, // Returns a pointer to the source line that caused the error.
 *     project_getErrorToken: () => number, // Returns a pointer to the error token string.
 *     project_getErrorTokenLength: () => number, // Returns the length of the error token.
 *     project_getName: () => number, // Returns a pointer to the project name string.
 *     project_getVersion: () => number, // Returns a pointer to the project version string.
 *     project_getFileCount: () => number, // Returns the number of program files in the project.
 *     project_getFilePath: (index: number) => number, // Returns a pointer to the file path string at the given index.
 *     project_getFileDirectory: (index: number) => number, // Returns a pointer to the file directory path string at the given index.
 *     project_getFileFirstBlockIndex: (index: number) => number, // Returns the first block index for the file at the given index.
 *     project_getFileBlockCount: (index: number) => number, // Returns the number of blocks in the file at the given index.
 *     project_getFileExecutionOrder: (index: number) => number, // Returns the execution order of the file at the given index.
 *     project_getBlockCount: () => number, // Returns the total number of program blocks.
 *     project_getBlockName: (index: number) => number, // Returns a pointer to the block name string at the given index.
 *     project_getBlockFilePath: (index: number) => number, // Returns a pointer to the block's file path string.
 *     project_getBlockProgramName: (index: number) => number, // Returns a pointer to the block's program name string.
 *     project_getBlockLanguage: (index: number) => number, // Returns the language enum of the block (0=UNKNOWN, 1=PLCASM, 2=STL, 3=LADDER, etc.).
 *     project_getBlockOffset: (index: number) => number, // Returns the bytecode offset of the block.
 *     project_getBlockSize: (index: number) => number, // Returns the bytecode size of the block.
 *     project_getProblemCount: () => number, // Returns the number of linter problems found during compilation.
 *     project_getProblems: () => number, // Returns a pointer to the array of LinterProblem structs.
 *     project_getMemoryAreaCount: () => number, // Returns the number of memory areas defined.
 *     project_getMemoryAvailable: () => number, // Returns the total available memory in bytes.
 *     project_getMemoryUsed: () => number, // Returns the used memory in bytes.
 *     project_getFlashSize: () => number, // Returns the flash size limit in bytes.
 *     project_getFlashUsed: () => number, // Returns the used flash (bytecode size) in bytes.
 *     project_getTimerOffset: () => number, // Returns the timer area start offset in memory.
 *     project_getTimerCount: () => number, // Returns the number of timers allocated.
 *     project_getCounterOffset: () => number, // Returns the counter area start offset in memory.
 *     project_getCounterCount: () => number, // Returns the number of counters allocated.
 *     project_getMemoryAreaName: (index: number) => number, // Returns a pointer to the memory area name string.
 *     project_getMemoryAreaStart: (index: number) => number, // Returns the start address of the memory area.
 *     project_getMemoryAreaEnd: (index: number) => number, // Returns the end address of the memory area.
 *     project_getSymbolCount: () => number, // Returns the number of symbols defined in the project.
 *     project_getSymbolName: (index: number) => number, // Returns a pointer to the symbol name string.
 *     project_getSymbolType: (index: number) => number, // Returns a pointer to the symbol type string.
 *     project_getSymbolAddress: (index: number) => number, // Returns a pointer to the symbol address string.
 *     project_getSymbolByteAddress: (index: number) => number, // Returns the byte address of the symbol.
 *     project_getSymbolBit: (index: number) => number, // Returns the bit offset of the symbol (0-7).
 *     project_getSymbolIsBit: (index: number) => boolean, // Returns true if the symbol is a bit address.
 *     project_getSymbolTypeSize: (index: number) => number, // Returns the size in bytes of the symbol's type.
 *     project_getDatablockCount: () => number, // Returns the number of datablocks defined in the project.
 *     project_getDatablockNumber: (index: number) => number, // Returns the DB number (e.g., 1 for DB1).
 *     project_getDatablockAlias: (index: number) => number, // Returns a pointer to the datablock alias string.
 *     project_getDatablockDirectory: (index: number) => number, // Returns a pointer to the datablock directory path string.
 *     project_getDatablockOffset: (index: number) => number, // Returns the absolute memory offset of the datablock.
 *     project_getDatablockSize: (index: number) => number, // Returns the total size of the datablock in bytes.
 *     project_getDatablockFieldCount: (index: number) => number, // Returns the number of fields in the datablock.
 *     project_getDatablockFieldName: (dbIndex: number, fieldIndex: number) => number, // Returns a pointer to the field name string.
 *     project_getDatablockFieldType: (dbIndex: number, fieldIndex: number) => number, // Returns a pointer to the field type string.
 *     project_getDatablockFieldTypeSize: (dbIndex: number, fieldIndex: number) => number, // Returns the size of the field in bytes.
 *     project_getDatablockFieldOffset: (dbIndex: number, fieldIndex: number) => number, // Returns the byte offset of the field within the datablock.
 *     project_getDatablockFieldHasDefault: (dbIndex: number, fieldIndex: number) => boolean, // Returns true if the field has a default value.
 *     project_getDatablockFieldDefaultInt: (dbIndex: number, fieldIndex: number) => number, // Returns the default value as an integer.
 *     project_getDatablockFieldDefaultFloat: (dbIndex: number, fieldIndex: number) => number, // Returns the default value as a float.
 *     project_load: () => boolean, // Loads the compiled program into the runtime. Returns true on success.
 *     project_reset: () => void, // Resets the project compiler state.
 *     project_getCombinedPLCASM: () => number, // Returns a pointer to the combined PLCASM source string from all blocks.
 *     project_uploadBytecode: () => number, // Streams the bytecode to stdout. Returns the bytecode length.
 *     project_printInfo: () => void, // Prints project information to stdout.
 *     project_loadToRuntime: () => number, // Loads the project bytecode into the runtime. Returns status code.
 *     runExplain: () => number, // Executes a single cycle with step-by-step explanation output.
 *     doSomething: () => void, // Test function that does something (for benchmarking).
 *     getLastInstructionCount: () => number, // Returns the number of instructions executed in the last cycle.
 *     getDeviceHealthPtr: () => number, // Returns a pointer to the DeviceHealth struct.
 *     getInfoString: () => number, // Returns a pointer to a static buffer containing runtime info string (same format as printInfo).
 *     getLastPeriodUs: () => number, // Returns the last period time in microseconds.
 *     getMinPeriodUs: () => number, // Returns the minimum period time recorded in microseconds.
 *     getMaxPeriodUs: () => number, // Returns the maximum period time recorded in microseconds.
 *     getLastJitterUs: () => number, // Returns the last jitter value in microseconds.
 *     getMinJitterUs: () => number, // Returns the minimum jitter recorded in microseconds.
 *     getMaxJitterUs: () => number, // Returns the maximum jitter recorded in microseconds.
 *     getTotalRam: () => number, // Returns the total RAM size in bytes.
 *     getStackSize: () => number, // Returns the current stack size in bytes.
 *     clearStack: () => void, // Clears the runtime stack.
 *     memoryReset: () => void, // Resets all memory to initial state.
 *     ir_get_count: () => number, // Returns the number of IR entries from the last compilation.
 *     ir_get_pointer: () => number, // Returns a pointer to the array of IR_Entry structs.
 *     ir_get_entry_size: () => number, // Returns the size in bytes of each IR_Entry struct.
 *     ir_get_labels_count: () => number, // Returns the number of labels defined in the last compilation.
 *     ir_get_consts_count: () => number, // Returns the number of named constants defined in the last compilation.
 *     ladder_lint_load_from_stream?: () => void, // Loads Ladder JSON from the stream buffer into the linter.
 *     ladder_lint_run?: () => number, // Runs the Ladder linter. Returns output length or -1.
 *     ladder_lint_compile?: () => number, // Compiles Ladder and lints. Returns output length or -1.
 *     ladder_lint_problem_count?: () => number, // Returns the number of problems found.
 *     ladder_lint_get_problem_type?: (index: number) => number, // Returns the type of a specific problem.
 *     ladder_lint_get_problem_line?: (index: number) => number, // Returns the line number of a specific problem.
 *     ladder_lint_get_problem_column?: (index: number) => number, // Returns the column number of a specific problem.
 *     ladder_lint_get_problem_length?: (index: number) => number, // Returns the length of a specific problem.
 *     ladder_lint_get_problem_message?: (index: number) => number, // Returns a pointer to the message of a specific problem.
 *     ladder_lint_get_problem_token?: (index: number) => number, // Returns a pointer to the token of a specific problem.
 *     ladder_lint_get_output?: () => number, // Returns a pointer to the generated STL output.
 *     ladder_lint_get_output_length?: () => number, // Returns the length of the generated STL output.
 *     ladder_lint_get_problems_pointer?: () => number, // Returns a pointer to the problems array.
 *     ladder_lint_clear?: () => void, // Clears the Ladder linter state.
 *     project_getModifierCount?: () => number, // Returns the number of modifiers defined.
 *     project_getModifierName?: (index: number) => number, // Returns a pointer to the modifier name string.
 *     project_getModifierLocation?: (index: number) => number, // Returns the location type (0=memory, 1=program).
 *     project_getModifierByteOffset?: (index: number) => number, // Returns the byte offset of the modifier.
 *     project_getModifierDatatype?: (index: number) => number, // Returns a pointer to the datatype string.
 *     project_getModifierSize?: (index: number) => number, // Returns the size of the modifier.
 *     project_getModifierFile?: (index: number) => number, // Returns a pointer to the file path string.
 *     project_getModifierProgram?: (index: number) => number, // Returns a pointer to the program name string.
 *     project_getModifierBlock?: (index: number) => number, // Returns a pointer to the block name string.
 *     project_getModifierLine?: (index: number) => number, // Returns the line number of the modifier.
 *     project_getModifierColumn?: (index: number) => number, // Returns the column number of the modifier.
 *     project_getModifierLength?: (index: number) => number, // Returns the length of the modifier token.
 *     project_getModifierToken?: (index: number) => number, // Returns a pointer to the modifier token string.
 *     project_getModifierDescription?: (index: number) => number, // Returns a pointer to the modifier description.
 *     get_out_buffer_ptr?: () => number, // Returns a pointer to the output buffer.
 *     get_out_index?: () => number, // Returns the current output buffer index/length.
 *     flush_out_buffer?: () => void, // Clears the output buffer.
 *     db_getSlotCount?: () => number, // Returns the number of DB slots available.
 *     db_getTableOffset?: () => number, // Returns the start address of the DB lookup table in memory.
 *     db_getActiveCount?: () => number, // Returns the number of active (non-empty) DB entries.
 *     db_getFreeSpace?: () => number, // Returns free bytes between user area and lowest DB data.
 *     db_getEntryDB?: (slot: number) => number, // Returns the DB number for a slot (0 = unused).
 *     db_getEntryOffset?: (slot: number) => number, // Returns the absolute memory offset for a slot.
 *     db_getEntrySize?: (slot: number) => number, // Returns the byte size for a slot.
 *     db_declare?: (db_number: number, size: number) => number, // Declares a new DB. Returns slot index or -1.
 *     db_remove?: (db_number: number) => number, // Removes a DB. Returns 1 on success, 0 on failure.
 *     db_migrate?: (db_number: number, target_offset: number) => number, // Migrates DB data. Returns 1/0.
 *     db_compact?: () => number, // Compacts all DBs. Returns new lowest address.
 *     db_resolveAddress?: (db_number: number, db_offset: number) => number, // Resolves DB-relative to absolute address. 0xFFFF on error.
 *     db_format?: () => void, // Clears all DB entries.
 *     db_setSlotCount?: (count: number) => void, // Re-initializes DB manager with new slot count.
 *     db_getLowestAddress?: () => number, // Returns the lowest allocated DB data address.
 *     db_getTotalDataUsed?: () => number, // Returns total bytes used by all active DBs.
 *     db_read?: (db_number: number, db_offset: number, count: number, dest_addr: number) => number, // Reads bytes from DB to memory. Returns 1/0.
 *     db_write?: (db_number: number, db_offset: number, count: number, src_addr: number) => number, // Writes bytes from memory to DB. Returns 1/0.
 *     db_getDeclCount?: () => number, // Returns the number of compiler-declared DB definitions.
 *     db_getDeclDBNumber?: (index: number) => number, // Returns the DB number for a declaration.
 *     db_getDeclAlias?: (index: number) => number, // Returns pointer to alias string.
 *     db_getDeclFieldCount?: (index: number) => number, // Returns field count for a declaration.
 *     db_getDeclTotalSize?: (index: number) => number, // Returns total byte size for a declaration.
 *     db_getDeclComputedOffset?: (index: number) => number, // Returns computed memory offset.
 *     db_getDeclFieldName?: (db_index: number, field_index: number) => number, // Returns pointer to field name.
 *     db_getDeclFieldTypeName?: (db_index: number, field_index: number) => number, // Returns pointer to field type name.
 *     db_getDeclFieldTypeSize?: (db_index: number, field_index: number) => number, // Returns field type size in bytes.
 *     db_getDeclFieldOffset?: (db_index: number, field_index: number) => number, // Returns field byte offset within DB.
 *     db_getDeclFieldHasDefault?: (db_index: number, field_index: number) => number, // Returns 1 if field has default.
 *     db_getDeclFieldDefaultInt?: (db_index: number, field_index: number) => number, // Returns default value as i32.
 *     db_getDeclFieldDefaultFloat?: (db_index: number, field_index: number) => number, // Returns default value as f32.
 *     wcet_analyze_compiled?: () => boolean, // Analyze bytecode from PLCASM compiler. Returns true on success.
 *     wcet_analyze_project?: () => boolean, // Analyze bytecode from project compiler. Returns true on success.
 *     wcet_analyze_runtime?: () => boolean, // Analyze bytecode loaded in runtime. Returns true on success.
 *     wcet_do_print_report?: () => void, // Print human-readable WCET report to stdout.
 *     wcet_get_bytecode_size?: () => number, // Total bytecode size analyzed.
 *     wcet_get_instruction_count?: () => number, // Total decoded instructions.
 *     wcet_get_unique_opcodes?: () => number, // Number of distinct opcodes.
 *     wcet_get_block_count?: () => number, // CFG basic block count.
 *     wcet_get_edge_count?: () => number, // CFG edge count.
 *     wcet_get_loop_count?: () => number, // Detected loop count.
 *     wcet_get_unreachable_blocks?: () => number, // Unreachable block count.
 *     wcet_get_dead_code_bytes?: () => number, // Dead code bytes.
 *     wcet_get_bcet_cycles?: () => number, // Best-case execution time (cycle units).
 *     wcet_get_wcet_cycles?: () => number, // Worst-case execution time (cycle units).
 *     wcet_get_bcet_instructions?: () => number, // Best-case instruction count.
 *     wcet_get_wcet_instructions?: () => number, // Worst-case instruction count.
 *     wcet_get_max_stack_depth?: () => number, // Max possible stack depth (bytes).
 *     wcet_get_min_stack_depth?: () => number, // Min stack depth.
 *     wcet_get_stack_at_exit?: () => number, // Stack depth at exit.
 *     wcet_get_max_call_depth?: () => number, // Max call nesting depth.
 *     wcet_get_has_recursion?: () => number, // 1 if recursion detected.
 *     wcet_get_total_paths?: () => number, // Number of unique execution paths.
 *     wcet_get_shortest_path_blocks?: () => number, // Shortest path length (blocks).
 *     wcet_get_longest_path_blocks?: () => number, // Longest path length (blocks).
 *     wcet_get_warning_count?: () => number, // Total warnings.
 *     wcet_get_has_dead_code?: () => number, // 1 if dead code detected.
 *     wcet_get_has_infinite_loop?: () => number, // 1 if infinite loop detected.
 *     wcet_get_has_stack_overflow?: () => number, // 1 if stack overflow risk.
 *     wcet_get_has_stack_underflow?: () => number, // 1 if stack underflow risk.
 *     wcet_get_has_unbalanced_stack?: () => number, // 1 if unbalanced stack at merge.
 *     wcet_get_opcode_freq_count?: () => number, // Number of entries in opcode frequency table.
 *     wcet_get_opcode_freq_opcode?: (i: number) => number, // Opcode at frequency index.
 *     wcet_get_opcode_freq_count_at?: (i: number) => number, // Count at frequency index.
 *     wcet_get_opcode_freq_bcet?: (i: number) => number, // Total BCET at frequency index.
 *     wcet_get_opcode_freq_wcet?: (i: number) => number, // Total WCET at frequency index.
 *     wcet_get_cfg_block_start?: (i: number) => number, // Block start offset.
 *     wcet_get_cfg_block_end?: (i: number) => number, // Block end offset.
 *     wcet_get_cfg_block_bcet?: (i: number) => number, // Block BCET.
 *     wcet_get_cfg_block_wcet?: (i: number) => number, // Block WCET.
 *     wcet_get_cfg_block_is_unreachable?: (i: number) => number, // 1 if block unreachable.
 *     wcet_get_cfg_block_stack_delta?: (i: number) => number, // Block stack delta.
 *     wcet_get_cfg_edge_from?: (i: number) => number, // Edge source block.
 *     wcet_get_cfg_edge_to?: (i: number) => number, // Edge destination block.
 *     wcet_get_cfg_edge_type?: (i: number) => number, // Edge type (0=fallthrough,1=jump,2=branch_true,3=branch_false,4=call,5=return).
 *     wcet_get_cfg_edge_is_back?: (i: number) => number, // 1 if back edge (loop).
 *     wcet_get_loop_header?: (i: number) => number, // Loop header block ID.
 *     wcet_get_loop_back_edge?: (i: number) => number, // Loop back edge source block.
 *     wcet_get_loop_max_iterations?: (i: number) => number, // Estimated max loop iterations.
 *     wcet_get_bcet_ns?: () => number, // Best-case nanoseconds (0 if no target profile).
 *     wcet_get_wcet_ns?: () => number, // Worst-case nanoseconds (0 if no target profile).
 *     wcet_get_has_target?: () => number, // 1 if a calibrated target profile is active.
 *     wcet_target_count?: () => number, // Number of available target profiles.
 *     wcet_target_select_by_index?: (i: number) => number, // Select target by index. Returns match quality.
 *     wcet_target_select?: (arch_id: number, clock_mhz: number, capabilities: number) => number, // Select target by arch/clock/caps.
 *     wcet_target_reset?: () => void, // Reset to default (no target) profile.
 *     wcet_target_get_match_quality?: () => number, // Match quality: 3=exact, 2=arch, 1=family, 0=default.
 *     wcet_target_get_match_reason?: () => number, // Pointer to match reason string.
 *     wcet_target_get_active_name?: () => number, // Pointer to active profile name.
 *     wcet_target_get_active_arch?: () => number, // Pointer to active profile arch name.
 *     wcet_target_get_active_clock?: () => number, // Active profile clock MHz.
 *     wcet_target_get_active_caps?: () => number, // Active profile capability flags.
 *     wcet_target_list_name?: (i: number) => number, // Pointer to profile name at index.
 *     wcet_target_list_arch?: (i: number) => number, // Pointer to profile arch at index.
 *     wcet_target_list_clock?: (i: number) => number, // Profile clock MHz at index.
 *     wcet_target_list_caps?: (i: number) => number, // Profile capabilities at index.
 * }} VovkPLCExportTypes
 */

/**
 * @typedef {{
 *     last_cycle_time_us: number,
 *     min_cycle_time_us: number,
 *     max_cycle_time_us: number,
 *     ram_free: number,
 *     min_ram_free: number,
 *     max_ram_free: number,
 *     total_ram_size: number,
 *     last_period_us: number,
 *     min_period_us: number,
 *     max_period_us: number,
 *     last_jitter_us: number,
 *     min_jitter_us: number,
 *     max_jitter_us: number,
 * }} DeviceHealth
 */

/**
 * @typedef {{
 *     type: number,        // IR_OP_TYPES value
 *     bytecode_pos: number, // Position within instruction where this operand starts
 *     value: number | bigint  // The operand value (number for 32-bit, bigint for 64-bit)
 * }} IR_Operand
 */

/**
 * @typedef {{
 *     bytecode_offset: number,  // Offset in bytecode where this instruction starts
 *     source_line: number,       // Source line number (1-based)
 *     source_column: number,     // Source column number (1-based)
 *     bytecode_size: number,     // Size of this instruction in bytes
 *     opcode: number,            // The instruction opcode
 *     flags: number,             // IR_FLAGS combination
 *     operand_count: number,     // Number of operands (0-3)
 *     operands: IR_Operand[]     // Array of operands
 * }} IR_Entry
 */

/**
 * Main Interface for the VovkPLC Runtime.
 *
 * @example
 * // 1. Worker Usage (Recommended, Non-blocking)
 * import VovkPLC from './VovkPLC.js';
 *
 * const worker = await VovkPLC.createWorker('./VovkPLC.wasm');
 * await worker.enableSharedMemory(); // Enable SharedArrayBuffer for high performance
 *
 * const assembly = `
 *   u8.const 10
 *   u8.const 20
 *   u8.add
 *   exit
 * `;
 *
 * // Compile
 * await worker.compilePLCASM(assembly);
 *
 * // Start the PLC VM
 * await worker.startRuntime();
 *
 * // Monitor Real-time Statistics (Zero-overhead via Shared Memory)
 * setInterval(() => {
 *   const stats = worker.getSharedStatus();
 *   if(stats) console.log(`Cycles: ${stats.cycles} | Last Time: ${stats.last_time}us`);
 * }, 100);
 *
 * // Stop
 * await worker.stopRuntime();
 *
 * @example
 * // 2. Basic Usage (Main Thread / Synchronous)
 * const plc = new VovkPLC();
 * await plc.initialize('./VovkPLC.wasm');
 *
 * plc.compilePLCASM(`
 *   ptr.const 0
 *   u8.const 42
 *   u8.move
 *   exit
 * `, {run: true}); // run: true = run immediately in debug mode
 *
 * // Read Memory
 * const mem = plc.readMemoryArea(0, 1);
 * console.log('Value at 0:', mem[0]);
 */
/** @typedef */ // @ts-ignore
class VovkPLC_class {
    /** @type { WebAssembly.Instance } */ // @ts-ignore
    wasm
    /** @type { VovkPLCExportTypes } */ // @ts-ignore
    wasm_exports
    /** @type { any } */
    wasmImports
    running = false
    /** @type { boolean } */
    mainLoopActive = false
    silent = false
    console_message = ''
    error_message = ''
    stream_message = ''
    /** @type { Performance | null } */
    perf = null

    /** @type { number | null } Override for millis() import. When non-null, WASM millis() returns this value instead of performance.now(). */
    _millisOverride = null
    /** @type { number | null } Override for micros() import. When non-null, WASM micros() returns this value instead of performance.now()*1000. */
    _microsOverride = null

    /** @type { Uint8Array } */
    crc8_table = new Uint8Array(256)
    crc8_table_loaded = false

    stdout_callback = console.log
    stderr_callback = console.error

    /**
     * Runtime endianness flag - read from S memory byte 0 after initialization.
     * true = little-endian (most modern systems), false = big-endian.
     * This matches the WASM runtime's native byte order for multi-byte values.
     * @type { boolean }
     */
    isLittleEndian = true

    constructor(wasm_path = '') {
        this.wasm_path = wasm_path
    }

    /**
     * Initializes the VovkPLC WebAssembly Runtime.
     * Loads the WASM binary, instantiates the module, and sets up the environment (imports, exports).
     *
     * @param {string} [wasm_path=''] - Path to the VovkPLC.wasm file. If empty, defaults to local dist path.
     * @param {boolean} [debug=false] - If true, enables debug logging during initialization.
     * @param {boolean} [silent=false] - If true, suppresses standard output from the PLC.
     * @returns {Promise<this>} - Returns the initialized instance.
     */
    initialize = async (wasm_path = '', debug = false, silent = false) => {
        wasm_path = wasm_path || this.wasm_path || '/dist/VovkPLC.wasm' // "/wasm_test_cases/string_alloc.wasm"
        this.wasm_path = wasm_path
        if (this.running && this.wasm) return this
        this.running = true
        this.setSilent(!!silent)
        if (debug) console.log('Starting up...')
        /** @type { BufferSource | null } */
        let wasmBuffer = null
        if (!isNodeRuntime) {
            this.perf = globalThis.performance || null
            const wasmFile = await fetch(wasm_path + '?t=' + Date.now()) // Force clean cache
            wasmBuffer = await wasmFile.arrayBuffer()
        } else {
            // @ts-ignore
            this.perf = globalThis.performance || (await import('perf_hooks')).performance
            const fs = await import('fs')
            const path = await import('path')
            const {fileURLToPath} = await import('url')
            let resolvedPath = wasm_path
            if (!resolvedPath || resolvedPath === '/dist/VovkPLC.wasm') {
                resolvedPath = fileURLToPath(new URL('./VovkPLC.wasm', import.meta.url))
            } else if (resolvedPath.startsWith('file:')) {
                resolvedPath = fileURLToPath(resolvedPath)
            } else if (resolvedPath.startsWith('http://') || resolvedPath.startsWith('https://')) {
                const wasmFile = await fetch(resolvedPath)
                wasmBuffer = await wasmFile.arrayBuffer()
            }
            if (!wasmBuffer) {
                wasmBuffer = fs.readFileSync(path.resolve(resolvedPath))
            }
        }

        // FFI callback storage - JS functions registered for FFI calls from WASM
        /** @type {Map<number, {name: string, signature: string, fn: Function}>} */
        this.ffiCallbacks = new Map()

        this.wasmImports = {
            env: {
                stdout: this.console_print,
                stderr: this.console_error,
                streamOut: this.console_stream, // @ts-ignore
                millis: () => this._millisOverride !== null ? this._millisOverride : Math.round(this.perf.now()), // @ts-ignore
                micros: () => this._microsOverride !== null ? this._microsOverride : Math.round(this.perf.now() * 1000),
                // memory: new WebAssembly.Memory({ initial: 256, maximum: 512 }),

                // FFI import - called from WASM when runtime executes a JS-registered FFI
                // @ts-ignore
                js_ffi_invoke: (ffi_index, param_types_ptr, param_addrs_ptr, param_count, ret_addr, ret_type) => {
                    return this._ffiInvoke(ffi_index, param_types_ptr, param_addrs_ptr, param_count, ret_addr, ret_type)
                },
            },
        }
        const wasmModule = await WebAssembly.compile(wasmBuffer)
        const wasmInstance = await WebAssembly.instantiate(wasmModule, this.wasmImports)
        if (typeof window !== 'undefined') Object.assign(window, wasmInstance.exports) // Assign all exports to the global scope
        if (!wasmInstance) throw new Error('Failed to instantiate WebAssembly module')
        this.wasm = wasmInstance // @ts-ignore
        this.wasm_exports = {...wasmInstance.exports}
        if (!this.wasm_exports) throw new Error('WebAssembly module exports not found')
        this.wasm_exports.initialize()
        // Note: ffi_registerBuiltins() is available but NOT called automatically
        // to avoid FFI index conflicts when compiling for devices.
        // Call plc.wasm_exports.ffi_registerBuiltins() manually if needed for debugging.
        this.wasm_exports.downloadAssembly = assembly => this.downloadAssembly(assembly)
        this.wasm_exports.extractProgram = () => this.extractProgram()
        const required_methods = ['printInfo', 'run_unit_test', 'run_custom_test', 'memoryReset', 'get_free_memory', 'doNothing', 'compileAssembly', 'loadCompiledProgram', 'runFullProgramDebug', 'runFullProgram', 'uploadProgram', 'getMemoryArea', 'writeMemoryByte']
        for (let i = 0; i < required_methods.length; i++) {
            const method = required_methods[i] // @ts-ignore
            if (!this.wasm_exports[method]) throw new Error(`${method} function not found`)
        }

        // Read the endianness flag from system memory byte 0 (S0)
        // The runtime sets this during memory initialization
        // Bit 0: 1 = little-endian, 0 = big-endian
        const memArea = this.readMemoryArea(0, 1)
        this.isLittleEndian = (memArea[0] & 0x01) === 1

        return this
    }

    /** @type { typeof this.initialize } */
    init = (...args) => this.initialize(...args)
    /** @type { typeof this.initialize } */
    create = (...args) => this.initialize(...args)

    /**
     * @typedef {{
     *     type: 'error' | 'warning' | 'info',
     *     line: number,
     *     column: number,
     *     length: number,
     *     message: string,
     *     token_text: string
     * }} LinterProblem
     */

    /**
     * Lints the provided PLCASM assembly code.
     * Streams the assembly to the linter, runs the analysis, and returns a list of problems (errors, warnings).
     *
     * @param {string} assembly - The PLCASM source code to lint.
     * @param {boolean} [debug=false] - If true, streams linter output to console.
     * @returns {LinterProblem[]} - Array of discovered problems.
     */
    lintPLCASM = (assembly, debug = false) => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.lint_load_assembly) throw new Error("'lint_load_assembly' function not found")
        if (!this.wasm_exports.lint_run) throw new Error("'lint_run' function not found")
        if (!this.wasm_exports.lint_get_problem_count) throw new Error("'lint_get_problem_count' function not found")
        if (!this.wasm_exports.lint_get_problems_pointer) throw new Error("'lint_get_problems_pointer' function not found")

        const wasSilent = this.silent

        // Temporarily disable stream output unless debug is enabled
        if (!debug) {
            this.setSilent(true)
        }

        try {
            // 1. Download assembly to Linter
            // Clear any stale data in the stream buffer first
            if (this.wasm_exports.streamClear) this.wasm_exports.streamClear()

            let ok = true
            for (let i = 0; i < assembly.length && ok; i++) {
                const char = assembly[i]
                const c = char.charCodeAt(0)
                ok = this.wasm_exports.streamIn(c)
            }
            if (!ok) throw new Error('Failed to stream assembly')
            this.wasm_exports.lint_load_assembly()

            // 2. Run Linter
            this.wasm_exports.lint_run()

            // 3. Get results
            const count = this.wasm_exports.lint_get_problem_count()
            if (count === 0) return []

            const pointer = this.wasm_exports.lint_get_problems_pointer()
            /** @type { LinterProblem[] } */
            const problems = []

            // Struct size = 84 bytes  (4+4+4+4+64+4)
            const struct_size = 84

            // Access memory directly
            const memoryBuffer = this.wasm_exports.memory.buffer
            const view = new DataView(memoryBuffer)

            for (let i = 0; i < count; i++) {
                const offset = pointer + i * struct_size
                const type_int = view.getUint32(offset + 0, true)
                const line = view.getUint32(offset + 4, true)
                const column = view.getUint32(offset + 8, true)
                const length = view.getUint32(offset + 12, true)

                // token_text is 64 bytes at offset 16
                let message = ''
                for (let j = 0; j < 64; j++) {
                    const charCode = view.getUint8(offset + 16 + j)
                    if (charCode === 0) break
                    message += String.fromCharCode(charCode)
                }

                const token_ptr = view.getUint32(offset + 80, true)
                let token_text = ''
                if (token_ptr !== 0 && length > 0) {
                    const token_buf = new Uint8Array(memoryBuffer, token_ptr, length)
                    token_text = new TextDecoder().decode(token_buf)
                }

                problems.push({
                    type: type_int === 2 ? 'error' : type_int === 1 ? 'warning' : 'info',
                    line,
                    column,
                    length,
                    message,
                    token_text,
                })
            }

            return problems
        } finally {
            // Restore original stream callback
            this.setSilent(wasSilent)
            // Clear any accumulated stream output
            if (!debug) {
                this.readStream()
            }
        }
    }

    /**
     * @typedef {{ type: 'error' | 'warning' | 'info', line: number, column: number, length: number, message: string, token_text: string }} STLLinterProblem
     */

    /**
     * @typedef {{ problems: STLLinterProblem[], output: string }} STLLintResult
     */

    /**
     * Reads LinterProblem structs (344 bytes each) from a WASM memory pointer.
     * Used by lintSTL and lintST which share the same C++ LinterProblem layout.
     * @param {number} pointer - WASM memory pointer to the problems array.
     * @param {number} count - Number of problems to read.
     * @returns {{ type: string, line: number, column: number, length: number, message: string, token_text: string }[]}
     */
    _readLinterProblems = (pointer, count) => {
        const struct_size = 348
        const view = new DataView(this.wasm_exports.memory.buffer)
        const problems = []

        const readFixedStr = (offset, start, maxLen) => {
            let s = ''
            for (let j = 0; j < maxLen; j++) {
                const c = view.getUint8(offset + start + j)
                if (c === 0) break
                s += String.fromCharCode(c)
            }
            return s
        }

        for (let i = 0; i < count; i++) {
            const offset = pointer + i * struct_size
            const type_int = view.getUint32(offset + 0, true)
            const line = view.getUint32(offset + 4, true)
            const column = view.getUint32(offset + 8, true)
            const length = view.getUint32(offset + 12, true)
            const message = readFixedStr(offset, 16, 128)
            // token_buf is 64 bytes at offset 276
            const token_text = readFixedStr(offset, 276, 64)

            problems.push({
                type: type_int === 2 ? 'error' : type_int === 1 ? 'warning' : 'info',
                line,
                column,
                length,
                message,
                token_text,
            })
        }
        return problems
    }

    /**
     * Lints the provided STL (Statement List) code.
     * Streams the STL to the linter, runs the analysis, and returns problems and generated PLCASM.
     *
     * @param {string} stl - The STL source code to lint.
     * @param {boolean} [debug=false] - If true, streams linter output to console.
     * @returns {STLLintResult} - Object containing problems array and generated PLCASM output.
     */
    lintSTL = (stl, debug = false) => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.stl_lint_load_from_stream) throw new Error("'stl_lint_load_from_stream' function not found - STL linter not available")
        if (!this.wasm_exports.stl_lint_run) throw new Error("'stl_lint_run' function not found")
        if (!this.wasm_exports.stl_lint_get_problem_count) throw new Error("'stl_lint_get_problem_count' function not found")
        if (!this.wasm_exports.stl_lint_get_problems_pointer) throw new Error("'stl_lint_get_problems_pointer' function not found")
        if (!this.wasm_exports.stl_lint_get_output) throw new Error("'stl_lint_get_output' function not found")

        const wasSilent = this.silent

        // Temporarily disable stream output unless debug is enabled
        if (!debug) {
            this.setSilent(true)
        }

        try {
            // 1. Stream STL code to linter
            // Clear any stale data in the stream buffer first
            if (this.wasm_exports.streamClear) this.wasm_exports.streamClear()

            let ok = true
            for (let i = 0; i < stl.length && ok; i++) {
                ok = this.wasm_exports.streamIn(stl.charCodeAt(i))
            }
            if (!ok) throw new Error('Failed to stream STL code')
            this.wasm_exports.streamIn(0) // Null terminator
            this.wasm_exports.stl_lint_load_from_stream()

            // 2. Run STL Linter
            this.wasm_exports.stl_lint_run()

            // 3. Get problems (344-byte LinterProblem structs)
            const count = this.wasm_exports.stl_lint_get_problem_count()
            const pointer = count > 0 ? this.wasm_exports.stl_lint_get_problems_pointer() : 0
            /** @type { STLLinterProblem[] } */
            const problems = pointer ? this._readLinterProblems(pointer, count) : []

            // 4. Get generated PLCASM output
            this.flushOutBuffer() // Clear any previous output
            this.wasm_exports.stl_lint_get_output()
            const output = this.readOutBuffer()

            return {problems, output}
        } finally {
            // Restore original stream callback
            this.setSilent(wasSilent)
            // Clear any accumulated stream output
            if (!debug) {
                this.readStream()
            }
        }
    }

    /**
     * @typedef {{ name: string, type: string, address: string, line: number, column: number, isLocal: boolean, isConst: boolean, isInferred: boolean, scopeLevel: number, memoryOffset: number }} PLCScriptSymbol
     */

    /**
     * @typedef {{ type: 'error' | 'warning' | 'info', line: number, column: number, length: number, message: string }} PLCScriptLinterProblem
     */

    /**
     * @typedef {{ problems: PLCScriptLinterProblem[], symbols: PLCScriptSymbol[], output: string }} PLCScriptLintResult
     */

    /**
     * Lints the provided PLCScript source code.
     * Compiles the code to collect errors/warnings and exports the resolved symbol table.
     *
     * @param {string} script - The PLCScript source code.
     * @param {boolean} [debug=false] - If true, streams linter output to console.
     * @returns {PLCScriptLintResult} - Object containing problems, resolved symbols, and generated PLCASM output.
     */
    lintPLCScript = (script, debug = false) => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.plcscript_linter_load_from_stream) throw new Error("'plcscript_linter_load_from_stream' function not found - PLCScript linter not available")
        if (!this.wasm_exports.plcscript_linter_lint) throw new Error("'plcscript_linter_lint' function not found")
        if (!this.wasm_exports.plcscript_linter_getProblemCount) throw new Error("'plcscript_linter_getProblemCount' function not found")

        const wasSilent = this.silent
        if (!debug) this.setSilent(true)

        /** @param {number} ptr */
        const getString = ptr => {
            if (!ptr) return ''
            const mem = new Uint8Array(this.wasm_exports.memory.buffer)
            let str = ''
            for (let i = 0; i < 512 && mem[ptr + i] !== 0; i++) {
                str += String.fromCharCode(mem[ptr + i])
            }
            return str
        }

        try {
            // 1. Stream PLCScript code to linter
            if (this.wasm_exports.streamClear) this.wasm_exports.streamClear()

            let ok = true
            for (let i = 0; i < script.length && ok; i++) {
                ok = this.wasm_exports.streamIn(script.charCodeAt(i))
            }
            if (!ok) throw new Error('Failed to stream PLCScript code')
            this.wasm_exports.plcscript_linter_load_from_stream()

            // 2. Run PLCScript Linter
            this.wasm_exports.plcscript_linter_lint()

            // 3. Get problems (using per-field accessor pattern)
            const problemCount = this.wasm_exports.plcscript_linter_getProblemCount()
            /** @type { PLCScriptLinterProblem[] } */
            const problems = []

            for (let i = 0; i < problemCount; i++) {
                const line = this.wasm_exports.plcscript_linter_getProblemLine(i)
                const column = this.wasm_exports.plcscript_linter_getProblemColumn(i)
                const length = this.wasm_exports.plcscript_linter_getProblemLength(i)
                const severity = this.wasm_exports.plcscript_linter_getProblemSeverity(i)
                const messagePtr = this.wasm_exports.plcscript_linter_getProblemMessage(i)
                const message = getString(messagePtr)

                problems.push({
                    type: severity === 2 ? 'error' : severity === 1 ? 'warning' : 'info',
                    line,
                    column,
                    length,
                    message,
                })
            }

            // 4. Get resolved symbol table
            /** @type { PLCScriptSymbol[] } */
            const symbols = []
            if (this.wasm_exports.plcscript_linter_getSymbolCount) {
                const symbolCount = this.wasm_exports.plcscript_linter_getSymbolCount()
                for (let i = 0; i < symbolCount; i++) {
                    const name = getString(this.wasm_exports.plcscript_linter_getSymbolName(i))
                    const type = getString(this.wasm_exports.plcscript_linter_getSymbolType(i))
                    const address = getString(this.wasm_exports.plcscript_linter_getSymbolAddress(i))
                    const line = this.wasm_exports.plcscript_linter_getSymbolLine(i)
                    const column = this.wasm_exports.plcscript_linter_getSymbolColumn(i)
                    const isLocal = !!this.wasm_exports.plcscript_linter_getSymbolIsLocal(i)
                    const isConst = !!this.wasm_exports.plcscript_linter_getSymbolIsConst(i)
                    const isInferred = !!this.wasm_exports.plcscript_linter_getSymbolIsInferred(i)
                    const scopeLevel = this.wasm_exports.plcscript_linter_getSymbolScopeLevel(i)
                    const memoryOffset = this.wasm_exports.plcscript_linter_getSymbolMemoryOffset(i)
                    symbols.push({ name, type, address, line, column, isLocal, isConst, isInferred, scopeLevel, memoryOffset })
                }
            }

            // 5. Get generated PLCASM output
            const outputPtr = this.wasm_exports.plcscript_linter_getOutput()
            const output = getString(outputPtr)

            return { problems, symbols, output }
        } finally {
            this.setSilent(wasSilent)
            if (!debug) this.readStream()
        }
    }

    /**
     * @typedef {{ name: string, type: string, address: string, line: number, column: number, isConst: boolean, isUsed: boolean }} STSymbol
     */

    /**
     * @typedef {{ type: 'error' | 'warning' | 'info', line: number, column: number, length: number, message: string, token_text: string }} STLinterProblem
     */

    /**
     * @typedef {{ problems: STLinterProblem[], symbols: STSymbol[], output: string }} STLintResult
     */

    /**
     * Lints the provided Structured Text (ST) source code.
     * Compiles the code to collect errors/warnings and exports the resolved symbol table.
     *
     * @param {string} st - The ST source code to lint.
     * @param {boolean} [debug=false] - If true, streams linter output to console.
     * @returns {STLintResult} - Object containing problems, resolved symbols, and generated PLCASM output.
     */
    lintST = (st, debug = false) => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.st_lint_load_from_stream) throw new Error("'st_lint_load_from_stream' function not found - ST linter not available")
        if (!this.wasm_exports.st_lint_run) throw new Error("'st_lint_run' function not found")
        if (!this.wasm_exports.st_lint_get_problem_count) throw new Error("'st_lint_get_problem_count' function not found")
        if (!this.wasm_exports.st_lint_get_problems_pointer) throw new Error("'st_lint_get_problems_pointer' function not found")
        if (!this.wasm_exports.st_lint_get_output) throw new Error("'st_lint_get_output' function not found")

        const wasSilent = this.silent
        if (!debug) this.setSilent(true)

        try {
            // 1. Stream ST code to linter
            if (this.wasm_exports.streamClear) this.wasm_exports.streamClear()

            let ok = true
            for (let i = 0; i < st.length && ok; i++) {
                ok = this.wasm_exports.streamIn(st.charCodeAt(i))
            }
            if (!ok) throw new Error('Failed to stream ST code')
            this.wasm_exports.streamIn(0) // Null terminator
            this.wasm_exports.st_lint_load_from_stream()

            // 2. Run ST Linter
            this.wasm_exports.st_lint_run()

            // 3. Get problems (344-byte LinterProblem structs)
            const count = this.wasm_exports.st_lint_get_problem_count()
            const pointer = count > 0 ? this.wasm_exports.st_lint_get_problems_pointer() : 0
            /** @type { STLinterProblem[] } */
            const problems = pointer ? this._readLinterProblems(pointer, count) : []

            // 4. Get resolved symbol table
            /** @type { STSymbol[] } */
            const symbols = []
            if (this.wasm_exports.st_lint_getSymbolCount) {
                const symbolCount = this.wasm_exports.st_lint_getSymbolCount()
                /** @param {number} ptr */
                const getString = ptr => {
                    if (!ptr) return ''
                    const mem = new Uint8Array(this.wasm_exports.memory.buffer)
                    let str = ''
                    for (let i = 0; i < 512 && mem[ptr + i] !== 0; i++) {
                        str += String.fromCharCode(mem[ptr + i])
                    }
                    return str
                }
                for (let i = 0; i < symbolCount; i++) {
                    const name = getString(this.wasm_exports.st_lint_getSymbolName(i))
                    const type = getString(this.wasm_exports.st_lint_getSymbolType(i))
                    const address = getString(this.wasm_exports.st_lint_getSymbolAddress(i))
                    const line = this.wasm_exports.st_lint_getSymbolLine(i)
                    const column = this.wasm_exports.st_lint_getSymbolColumn(i)
                    const isConst = !!this.wasm_exports.st_lint_getSymbolIsConst(i)
                    const isUsed = !!this.wasm_exports.st_lint_getSymbolIsUsed(i)
                    symbols.push({ name, type, address, line, column, isConst, isUsed })
                }
            }

            // 5. Get generated PLCASM output
            this.flushOutBuffer() // Clear any previous output
            this.wasm_exports.st_lint_get_output()
            const output = this.readOutBuffer()

            return { problems, symbols, output }
        } finally {
            this.setSilent(wasSilent)
            if (!debug) this.readStream()
        }
    }

    /**
     * @typedef {{ type: 'error' | 'warning' | 'info', line: number, column: number, length: number, message: string, token_text: string }} LadderLinterProblem
     */

    /**
     * @typedef {{ problems: LadderLinterProblem[], output: string }} LadderLintResult
     */

    /**
     * Lints the provided Ladder Graph JSON.
     * Parses the ladder diagram, validates structure, and returns problems and generated STL.
     * The line/column in problems correspond to the node's y/x position in the grid.
     *
     * @param {string | LadderGraph} ladder - The Ladder Graph as JSON string or object.
     * @param {boolean} [debug=false] - If true, streams linter output to console.
     * @returns {LadderLintResult} - Object containing problems array and generated STL output.
     */
    lintLadder = (ladder, debug = false) => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.ladder_lint_load_from_stream) throw new Error("'ladder_lint_load_from_stream' function not found - Ladder linter not available")
        if (!this.wasm_exports.ladder_lint_run) throw new Error("'ladder_lint_run' function not found")
        if (!this.wasm_exports.ladder_lint_problem_count) throw new Error("'ladder_lint_problem_count' function not found")

        const wasSilent = this.silent

        // Temporarily disable stream output unless debug is enabled
        if (!debug) {
            this.setSilent(true)
        }

        try {
            // Convert object to JSON string if needed
            const ladderJson = typeof ladder === 'string' ? ladder : JSON.stringify(ladder)

            // 1. Stream Ladder Graph JSON to linter
            if (this.wasm_exports.streamClear) this.wasm_exports.streamClear()

            let ok = true
            for (let i = 0; i < ladderJson.length && ok; i++) {
                ok = this.wasm_exports.streamIn(ladderJson.charCodeAt(i))
            }
            if (!ok) throw new Error('Failed to stream Ladder Graph JSON')
            this.wasm_exports.streamIn(0) // Null terminator
            this.wasm_exports.ladder_lint_load_from_stream()

            // 2. Run Ladder Linter with compile (returns problem_count)
            // Use ladder_lint_compile instead of ladder_lint_run to get STL output
            const compileFunc = this.wasm_exports.ladder_lint_compile || this.wasm_exports.ladder_lint_run
            const problemCount = compileFunc()

            // 3. Get output length BEFORE calling any other functions (WASM reinit workaround)
            const lintOutputLen = this.wasm_exports.ladder_lint_get_output_length ? this.wasm_exports.ladder_lint_get_output_length() : 0

            // 4. Get problems pointer and read directly from memory
            /** @type { LadderLinterProblem[] } */
            const problems = []

            if (problemCount > 0 && this.wasm_exports.ladder_lint_get_problems_pointer) {
                const problemsPtr = this.wasm_exports.ladder_lint_get_problems_pointer()
                const memoryBuffer = this.wasm_exports.memory.buffer
                const view = new DataView(memoryBuffer)
                const mem = new Uint8Array(memoryBuffer)

                // LinterProblem struct layout (348 bytes):
                // u32 type (4), u32 line (4), u32 column (4), u32 length (4)
                // char message[128], char block[64], char program[64], u32 lang (4)
                // char token_buf[64], char* token_text (4), i32 db_number (4)
                const STRUCT_SIZE = 348

                /** @type {(offset: number, maxLen: number) => string} */
                const readString = (offset, maxLen) => {
                    let str = ''
                    for (let i = 0; i < maxLen && mem[offset + i] !== 0; i++) {
                        str += String.fromCharCode(mem[offset + i])
                    }
                    return str
                }

                for (let i = 0; i < problemCount; i++) {
                    const offset = problemsPtr + i * STRUCT_SIZE
                    const type_int = view.getUint32(offset + 0, true)
                    const line = view.getUint32(offset + 4, true)
                    const column = view.getUint32(offset + 8, true)
                    const length = view.getUint32(offset + 12, true)
                    const message = readString(offset + 16, 128)
                    // block at offset 144 (16 + 128)
                    // program at offset 208 (144 + 64)
                    // lang at offset 272 (208 + 64)
                    // token_buf at offset 276 (272 + 4)
                    const token_text = readString(offset + 276, 64)

                    problems.push({
                        type: type_int === 2 ? 'error' : type_int === 1 ? 'warning' : 'info',
                        line,
                        column,
                        length,
                        message,
                        token_text,
                    })
                }
            }

            // 5. Get generated STL output
            let output = ''
            if (this.wasm_exports.ladder_lint_get_output && lintOutputLen > 0) {
                const outputPtr = this.wasm_exports.ladder_lint_get_output()
                if (outputPtr) {
                    const mem = new Uint8Array(this.wasm_exports.memory.buffer)
                    for (let j = 0; j < lintOutputLen; j++) {
                        output += String.fromCharCode(mem[outputPtr + j])
                    }
                }
            }

            // Clear linter state
            if (this.wasm_exports.ladder_lint_clear) {
                this.wasm_exports.ladder_lint_clear()
            }

            return {problems, output}
        } finally {
            // Restore original stream callback
            this.setSilent(wasSilent)
            // Clear any accumulated stream output
            if (!debug) {
                this.readStream()
            }
        }
    }

    /**
     * IR Flag constants for instruction classification.
     */
    static IR_FLAGS = {
        NONE: 0x00,
        READ: 0x01, // Instruction reads from memory
        WRITE: 0x02, // Instruction writes to memory
        CONST: 0x04, // Instruction uses an embedded constant
        JUMP: 0x08, // Instruction is a jump/call
        TIMER: 0x10, // Instruction is a timer
        LABEL_TARGET: 0x20, // This address is a jump target (label)
        EDITABLE: 0x40, // Constant can be edited in-place
    }

    /**
     * IR Operand Type constants.
     */
    static IR_OP_TYPES = {
        NONE: 0,
        BOOL: 1,
        I8: 2,
        U8: 3,
        I16: 4,
        U16: 5,
        I32: 6,
        U32: 7,
        I64: 8,
        U64: 9,
        F32: 10,
        F64: 11,
        PTR: 12,
        LABEL: 13,
    }

    /**
     * Gets the Intermediate Representation (IR) for the last compiled assembly.
     * The IR contains metadata about each compiled instruction including:
     * - Bytecode offset and size
     * - Source location (line, column)
     * - Operand information (addresses, constants)
     * - Flags indicating if instruction reads/writes memory, uses constants, etc.
     *
     * This is useful for front-end editors to provide:
     * - Live value monitoring (track which memory addresses are used)
     * - Constant editing (modify embedded constants)
     * - Jump visualization (see control flow)
     *
     * @returns {IR_Entry[]} - Array of IR entries for each compiled instruction.
     */
    getIR = () => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.ir_get_count) throw new Error("'ir_get_count' function not found")
        if (!this.wasm_exports.ir_get_pointer) throw new Error("'ir_get_pointer' function not found")
        if (!this.wasm_exports.ir_get_entry_size) throw new Error("'ir_get_entry_size' function not found")

        const count = this.wasm_exports.ir_get_count()
        if (count === 0) return []

        const pointer = this.wasm_exports.ir_get_pointer()
        const struct_size = this.wasm_exports.ir_get_entry_size()

        /** @type {IR_Entry[]} */
        const entries = []

        // Access memory directly
        const memoryBuffer = this.wasm_exports.memory.buffer
        const view = new DataView(memoryBuffer)

        // IR_Entry layout (72 bytes with alignment):
        // u32 bytecode_offset (0-3)
        // u16 source_line (4-5)
        // u16 source_column (6-7)
        // u8  bytecode_size (8)
        // u8  opcode (9)
        // u8  flags (10)
        // u8  operand_count (11)
        // [4 bytes padding for 8-byte alignment of operands] (12-15)
        // Operands[3] at offset 16, each operand is 16 bytes (8-byte aligned):
        //   u8 type (0)
        //   u8 bytecode_pos (1)
        //   u8 _pad[2] (2-3)
        //   [4 bytes padding for 8-byte alignment] (4-7)
        //   u64 value (8-15) - union
        // Reserved[4] + padding at end

        for (let i = 0; i < count; i++) {
            const offset = pointer + i * struct_size

            const bytecode_offset = view.getUint32(offset + 0, true)
            const source_line = view.getUint16(offset + 4, true)
            const source_column = view.getUint16(offset + 6, true)
            const bytecode_size = view.getUint8(offset + 8)
            const opcode = view.getUint8(offset + 9)
            const flags = view.getUint8(offset + 10)
            const operand_count = view.getUint8(offset + 11)

            /** @type {IR_Operand[]} */
            const operands = []

            for (let j = 0; j < operand_count && j < 3; j++) {
                const op_offset = offset + 16 + j * 16 // Each operand is 16 bytes (8-byte aligned)
                const op_type = view.getUint8(op_offset + 0)
                const op_bytecode_pos = view.getUint8(op_offset + 1)

                // Read value based on type - value starts at offset 8 within operand (8-byte aligned)
                let op_value
                const IR_OP = VovkPLC_class.IR_OP_TYPES
                switch (op_type) {
                    case IR_OP.BOOL:
                    case IR_OP.U8:
                        op_value = view.getUint8(op_offset + 8)
                        break
                    case IR_OP.I8:
                        op_value = view.getInt8(op_offset + 8)
                        break
                    case IR_OP.U16:
                        op_value = view.getUint16(op_offset + 8, true)
                        break
                    case IR_OP.I16:
                        op_value = view.getInt16(op_offset + 8, true)
                        break
                    case IR_OP.U32:
                    case IR_OP.PTR:
                    case IR_OP.LABEL:
                        op_value = view.getUint32(op_offset + 8, true)
                        break
                    case IR_OP.I32:
                        op_value = view.getInt32(op_offset + 4, true)
                        break
                    case IR_OP.F32:
                        op_value = view.getFloat32(op_offset + 8, true)
                        break
                    case IR_OP.F64:
                        op_value = view.getFloat64(op_offset + 8, true)
                        break
                    case IR_OP.U64:
                        op_value = view.getBigUint64(op_offset + 8, true)
                        break
                    case IR_OP.I64:
                        op_value = view.getBigInt64(op_offset + 8, true)
                        break
                    default:
                        op_value = view.getUint32(op_offset + 8, true)
                }

                operands.push({
                    type: op_type,
                    bytecode_pos: op_bytecode_pos,
                    value: op_value,
                })
            }

            entries.push({
                bytecode_offset,
                source_line,
                source_column,
                bytecode_size,
                opcode,
                flags,
                operand_count,
                operands,
            })
        }

        return entries
    }

    /**
     * Gets the count of labels defined in the last compilation.
     * @returns {number}
     */
    getLabelsCount = () => {
        if (!this.wasm_exports?.ir_get_labels_count) return 0
        return this.wasm_exports.ir_get_labels_count()
    }

    /**
     * Gets the count of named constants defined in the last compilation.
     * @returns {number}
     */
    getConstsCount = () => {
        if (!this.wasm_exports?.ir_get_consts_count) return 0
        return this.wasm_exports.ir_get_consts_count()
    }

    setSilent = (value = true) => {
        this.silent = value
    }

    /**
     * Reads a null-terminated C string from WASM memory at the given pointer.
     *
     * @param {number} ptr - Pointer to the start of the string in WASM memory.
     * @param {number} [maxLen=512] - Maximum length to read (safety limit).
     * @returns {string} - The decoded string.
     */
    readCString = (ptr, maxLen = 512) => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        const mem = new Uint8Array(this.wasm_exports.memory.buffer)
        let str = ''
        for (let i = 0; i < maxLen && mem[ptr + i] !== 0; i++) {
            str += String.fromCharCode(mem[ptr + i])
        }
        return str
    }

    /**
     * Parses the info string from printInfo/getInfoString into a RuntimeInfo object.
     * Format: [VovkPLCRuntime,ARCH,MAJOR,MINOR,PATCH,BUILD,DATE,STACK,MEM,PROG,S_OFF,S_SZ,X_OFF,X_SZ,Y_OFF,Y_SZ,M_OFF,M_SZ,T_OFF,T_CNT,T_SZ,C_OFF,C_CNT,C_SZ,FLAGS,DEVICE]
     *
     * @param {string} raw - The raw bracket-delimited info string.
     * @returns {RuntimeInfo|string} - Parsed object or raw string if parsing fails.
     */
    parseInfoString = (raw) => {
        if (raw.length === 0) return 'No info available'
        if (raw.startsWith('[') && raw.endsWith(']')) {
            // '[VovkPLCRuntime,WASM,0,1,0,324,2025-03-16 19:16:44,1024,104857,104857,0,16,16,16,32,16,48,16,64,16,704,16,9,848,16,5,Simulator]'
            const content = raw.substring(1, raw.length - 1)
            const parts = content.split(',')
            const base = {
                header: parts[0],
                arch: parts[1],
                version: `${parts[2]}.${parts[3]}.${parts[4]} Build ${parts[5]}`,
                versionMajor: +parts[2],
                versionMinor: +parts[3],
                versionPatch: +parts[4],
                versionBuild: +parts[5],
                date: parts[6],
                stack: +parts[7],
                memory: +parts[8],
                program: +parts[9],
            }
            if (parts.length >= 29) {
                // New format with DB info + flags: ...counter_struct,db_table_offset,db_slot_count,db_entry_size,flags,device
                return {
                    ...base,
                    system_offset: +parts[10],
                    system_size: +parts[11],
                    input_offset: +parts[12],
                    input_size: +parts[13],
                    output_offset: +parts[14],
                    output_size: +parts[15],
                    marker_offset: +parts[16],
                    marker_size: +parts[17],
                    timer_offset: +parts[18],
                    timer_count: +parts[19],
                    timer_struct_size: +parts[20],
                    counter_offset: +parts[21],
                    counter_count: +parts[22],
                    counter_struct_size: +parts[23],
                    db_table_offset: +parts[24],
                    db_slot_count: +parts[25],
                    db_entry_size: +parts[26],
                    flags: parseInt(parts[27], 16),
                    device: parts[28],
                }
            }
            if (parts.length >= 28) {
                // DB info without flags: ...counter_struct,db_table_offset,db_slot_count,db_entry_size,device
                return {
                    ...base,
                    system_offset: +parts[10],
                    system_size: +parts[11],
                    input_offset: +parts[12],
                    input_size: +parts[13],
                    output_offset: +parts[14],
                    output_size: +parts[15],
                    marker_offset: +parts[16],
                    marker_size: +parts[17],
                    timer_offset: +parts[18],
                    timer_count: +parts[19],
                    timer_struct_size: +parts[20],
                    counter_offset: +parts[21],
                    counter_count: +parts[22],
                    counter_struct_size: +parts[23],
                    db_table_offset: +parts[24],
                    db_slot_count: +parts[25],
                    db_entry_size: +parts[26],
                    device: parts[27],
                }
            }
            if (parts.length >= 26) {
                // Legacy format with flags but no DB info
                return {
                    ...base,
                    system_offset: +parts[10],
                    system_size: +parts[11],
                    input_offset: +parts[12],
                    input_size: +parts[13],
                    output_offset: +parts[14],
                    output_size: +parts[15],
                    marker_offset: +parts[16],
                    marker_size: +parts[17],
                    timer_offset: +parts[18],
                    timer_count: +parts[19],
                    timer_struct_size: +parts[20],
                    counter_offset: +parts[21],
                    counter_count: +parts[22],
                    counter_struct_size: +parts[23],
                    flags: parseInt(parts[24], 16),
                    device: parts[25],
                }
            }
            if (parts.length >= 25) {
                // Legacy format with timer and counter info but no flags
                return {
                    ...base,
                    system_offset: +parts[10],
                    system_size: +parts[11],
                    input_offset: +parts[12],
                    input_size: +parts[13],
                    output_offset: +parts[14],
                    output_size: +parts[15],
                    marker_offset: +parts[16],
                    marker_size: +parts[17],
                    timer_offset: +parts[18],
                    timer_count: +parts[19],
                    timer_struct_size: +parts[20],
                    counter_offset: +parts[21],
                    counter_count: +parts[22],
                    counter_struct_size: +parts[23],
                    device: parts[24],
                }
            }
            if (parts.length >= 19) {
                // @ts-ignore // Legacy format without timer/counter info
                return {
                    ...base,
                    system_offset: +parts[10],
                    system_size: +parts[11],
                    input_offset: +parts[12],
                    input_size: +parts[13],
                    output_offset: +parts[14],
                    output_size: +parts[15],
                    marker_offset: +parts[16],
                    marker_size: +parts[17],
                    device: parts[18],
                }
            } // @ts-ignore // Very old legacy format
            return {                
                ...base,
                input_offset: +parts[10],
                input_size: +parts[11],
                output_offset: +parts[12],
                output_size: +parts[13],
                device: parts[14],
            }
        }
        console.error(`Invalid info response:`, raw)
        return raw
    }

    /**
     * Retrieves runtime information and configuration from the PLC.
     * Parses the output string containing version, architecture, memory sizes, and offsets.
     *
     * @returns {RuntimeInfo|string} - An object containing runtime properties (version, offsets, etc.) or a raw string if parsing fails.
     */
    printInfo = () => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.printInfo) throw new Error("'printInfo' function not found")
        this.wasm_exports.printInfo()
        return this.parseInfoString(this.readStream().trim())
    }

    /**
     * @typedef {{
     *     header: string,
     *     arch: string,
     *     version: string,
     *     versionMajor: number,
     *     versionMinor: number,
     *     versionPatch: number,
     *     versionBuild: number,
     *     date: string,
     *     device: string,
     *     stack: number,
     *     memory: number,
     *     program: number,
     *     system_offset: number,
     *     system_size: number,
     *     input_offset: number,
     *     input_size: number,
     *     output_offset: number,
     *     output_size: number,
     *     marker_offset: number,
     *     marker_size: number,
     *     timer_offset: number,
     *     timer_count: number,
     *     timer_struct_size: number,
     *     counter_offset: number,
     *     counter_count: number,
     *     counter_struct_size: number,
     *     db_table_offset: number,
     *     db_slot_count: number,
     *     db_entry_size: number,
     *     flags: number,
     * }} RuntimeInfo
     */

    /**
     * Retrieves runtime information and configuration from the PLC using direct buffer access.
     * This is the preferred method over printInfo() as it avoids stream parsing overhead.
     *
     * @returns {RuntimeInfo | string} - An object containing runtime properties (version, offsets, etc.).
     */
    getInfo = () => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')

        // Check for the direct getter function
        if (!this.wasm_exports.getInfoString) {
            // Fall back to printInfo for older WASM builds
            return this.printInfo()
        }

        const ptr = this.wasm_exports.getInfoString()
        const raw = this.readCString(ptr)
        return this.parseInfoString(raw)
    }

    /**
     * Retrieves current health statistics of the virtual device.
     * Includes cycle times (last, min, max), RAM usage, period, and jitter.
     * Efficiently reads all stats in a single WASM call via structure pointer.
     *
     * @returns {DeviceHealth} - Object containing performance and memory metrics.
     */
    getDeviceHealth = () => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.getDeviceHealthPtr) throw new Error("'getDeviceHealthPtr' function not found")

        const ptr = this.wasm_exports.getDeviceHealthPtr()
        const view = new Uint32Array(this.wasm_exports.memory.buffer, ptr, 13)

        return {
            last_cycle_time_us: view[0],
            min_cycle_time_us: view[1],
            max_cycle_time_us: view[2],
            ram_free: view[3],
            min_ram_free: view[4],
            max_ram_free: view[5],
            total_ram_size: view[6],
            last_period_us: view[7],
            min_period_us: view[8],
            max_period_us: view[9],
            last_jitter_us: view[10],
            min_jitter_us: view[11],
            max_jitter_us: view[12],
        }
    }

    /**
     * Resets the device health statistics (min/max cycle times, ram tracking).
     */
    resetDeviceHealth = () => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.resetDeviceHealth) throw new Error("'resetDeviceHealth' function not found")
        this.wasm_exports.resetDeviceHealth()
    }

    /**
     * Gets the total RAM (SRAM) size available on the device in bytes.
     *
     * @returns {number} - Total RAM size in bytes.
     */
    getTotalRam = () => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.getTotalRam) throw new Error("'getTotalRam' function not found")
        return this.wasm_exports.getTotalRam()
    }

    /**
     * Sets the memory offsets for the PLC runtime memory areas.
     * This allows custom memory layout configuration for system, input, output, and marker areas.
     *
     * @param {number} systemOffset - Offset for the system area.
     * @param {number} inputOffset - Offset for the input area.
     * @param {number} outputOffset - Offset for the output area.
     * @param {number} markerOffset - Offset for the marker area.
     */
    setRuntimeOffsets = (systemOffset, inputOffset, outputOffset, markerOffset) => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.setRuntimeOffsets) throw new Error("'setRuntimeOffsets' function not found")
        this.wasm_exports.setRuntimeOffsets(systemOffset, inputOffset, outputOffset, markerOffset)
    }

    /**
     * Downloads assembly code to the PLC runtime line-by-line via the stream interface.
     * Does not compile, just loads the text into the internal buffer.
     *
     * @param {string} assembly - The assembly code string.
     * @returns {boolean} - True if an error occurred during download, false otherwise.
     */
    downloadAssembly = assembly => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.streamIn) throw new Error("'streamIn' function not found")
        if (!this.wasm_exports.loadAssembly) throw new Error("'loadAssembly' function not found")

        // Clear any stale data in the stream buffer before loading new assembly
        if (this.wasm_exports.streamClear) this.wasm_exports.streamClear()

        let ok = true
        for (let i = 0; i < assembly.length && ok; i++) {
            const char = assembly[i]
            const c = char.charCodeAt(0)
            ok = this.wasm_exports.streamIn(c)
        }
        if (!ok) throw new Error('Failed to download assembly')
        this.wasm_exports.loadAssembly()
        const error = !ok
        return error
    }

    /**
     * @typedef {{ type: 'bytecode' | 'plcasm' | 'stl', size: number, output: string }} CompileResult
     * @typedef {{ id: string, type: string, symbol: string, x: number, y: number, inverted?: boolean, trigger?: string, preset?: string }} LadderGraphNode
     * @typedef {{ id?: string, sources: string[], destinations: string[] }} LadderGraphConnection
     * @typedef {{ nodes: LadderGraphNode[], connections: LadderGraphConnection[] }} LadderGraph
     */

    /**
     * Compiles PLCASM assembly code into executable bytecode.
     *
     * @param {string} plcasm - The PLCASM source code.
     * @param {{ run?: boolean }} [options={}] - Options: run=true to execute after compile.
     * @returns {CompileResult} - The compilation result with type='bytecode'.
     * @throws {Error} If compilation fails.
     */
    compilePLCASM(plcasm, options = {}) {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.compileAssembly) throw new Error("'compileAssembly' function not found")
        if (!this.wasm_exports.loadCompiledProgram) throw new Error("'loadCompiledProgram' function not found")

        const run = options.run || false

        this.downloadAssembly(plcasm)
        if (this.wasm_exports.compileAssembly(false)) throw new Error('Failed to compile assembly')

        if (run) {
            this.wasm_exports.loadCompiledProgram()
            this.runDebug()
        }

        const result = this.extractProgram()
        return {
            type: 'bytecode',
            size: result.size,
            output: result.output,
        }
    }

    /**
     * WCET (Worst-Case Execution Time) Analysis.
     * Performs static analysis on compiled bytecode to determine:
     * - Control Flow Graph (CFG) with basic blocks, edges, loops
     * - Best/Worst case execution time in cycle units
     * - Stack depth analysis (max/min/exit depth)
     * - Dead code and unreachable block detection
     * - Loop detection and infinite loop warnings
     * - Opcode frequency and cost breakdown
     *
     * @param {'compiled' | 'project' | 'runtime'} [source='compiled'] - Which bytecode to analyze:
     *   - 'compiled': PLCASM compiler output (after compilePLCASM)
     *   - 'project': Project compiler output (after compileProject)
     *   - 'runtime': Currently loaded runtime program
     * @param {{ print?: boolean, target?: string }} [options={}] - Options.
     *   print: also print report to stdout.
     *   target: select a calibrated target profile by name (e.g., 'stm32f401') for ns estimates.
     * @returns {WCETReport} The full analysis report.
     * @throws {Error} If analysis fails or no bytecode available.
     *
     * @typedef {{
     *     bytecode_size: number,
     *     instruction_count: number,
     *     unique_opcodes: number,
     *     block_count: number,
     *     edge_count: number,
     *     loop_count: number,
     *     unreachable_blocks: number,
     *     dead_code_bytes: number,
     *     bcet_cycles: number,
     *     wcet_cycles: number,
     *     bcet_instructions: number,
     *     wcet_instructions: number,
     *     bcet_ns: number,
     *     wcet_ns: number,
     *     has_target: boolean,
     *     target: { name: string, arch: string, clock_mhz: number, match_quality: number, match_reason: string } | null,
     *     max_stack_depth: number,
     *     min_stack_depth: number,
     *     stack_at_exit: number,
     *     max_call_depth: number,
     *     has_recursion: boolean,
     *     total_paths: number,
     *     shortest_path_blocks: number,
     *     longest_path_blocks: number,
     *     warning_count: number,
     *     warnings: {
     *         dead_code: boolean,
     *         infinite_loop: boolean,
     *         stack_overflow: boolean,
     *         stack_underflow: boolean,
     *         unbalanced_stack: boolean,
     *     },
     *     opcode_frequency: Array<{
     *         opcode: number,
     *         name: string,
     *         count: number,
     *         total_bcet: number,
     *         total_wcet: number,
     *     }>,
     *     cfg: {
     *         blocks: Array<{ start: number, end: number, bcet: number, wcet: number, unreachable: boolean, stack_delta: number }>,
     *         edges: Array<{ from: number, to: number, type: string, is_back_edge: boolean }>,
     *         loops: Array<{ header: number, back_edge: number, max_iterations: number }>,
     *     },
     * }} WCETReport
     */
    analyzeWCET(source = 'compiled', options = {}) {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        const wasm = this.wasm_exports

        // Select target profile if specified
        if (options.target && wasm.wcet_target_count) {
            const targetLC = options.target.toLowerCase()
            const count = wasm.wcet_target_count()
            let matched = false
            for (let i = 0; i < count; i++) {
                const namePtr = wasm.wcet_target_list_name(i)
                const archPtr = wasm.wcet_target_list_arch(i)
                const name = namePtr ? this.readCString(namePtr) : ''
                const arch = archPtr ? this.readCString(archPtr) : ''
                if (name.toLowerCase().includes(targetLC) || arch.toLowerCase().includes(targetLC)) {
                    wasm.wcet_target_select_by_index(i)
                    matched = true
                    break
                }
            }
            if (!matched && wasm.wcet_target_reset) wasm.wcet_target_reset()
        } else if (wasm.wcet_target_reset) {
            wasm.wcet_target_reset()
        }

        // Run the appropriate analysis
        let ok = false
        if (source === 'compiled' && wasm.wcet_analyze_compiled) {
            ok = wasm.wcet_analyze_compiled()
        } else if (source === 'project' && wasm.wcet_analyze_project) {
            ok = wasm.wcet_analyze_project()
        } else if (source === 'runtime' && wasm.wcet_analyze_runtime) {
            ok = wasm.wcet_analyze_runtime()
        } else {
            throw new Error(`WCET analysis not available for source '${source}'`)
        }
        if (!ok) throw new Error(`WCET analysis failed for source '${source}' — no bytecode available?`)

        // Optionally print the report to stdout
        if (options.print && wasm.wcet_do_print_report) wasm.wcet_do_print_report()

        // Edge type name lookup
        const edgeTypeNames = ['fallthrough', 'jump', 'branch_true', 'branch_false', 'call', 'return']

        // Read opcode frequency table
        const opcodeFrequency = []
        const freqCount = wasm.wcet_get_opcode_freq_count ? wasm.wcet_get_opcode_freq_count() : 0
        for (let i = 0; i < freqCount; i++) {
            const opcode = wasm.wcet_get_opcode_freq_opcode(i)
            opcodeFrequency.push({
                opcode,
                name: this._getOpcodeName(opcode),
                count: wasm.wcet_get_opcode_freq_count_at(i),
                total_bcet: wasm.wcet_get_opcode_freq_bcet(i),
                total_wcet: wasm.wcet_get_opcode_freq_wcet(i),
            })
        }

        // Read CFG blocks
        const blockCount = wasm.wcet_get_block_count ? wasm.wcet_get_block_count() : 0
        const cfgBlocks = []
        for (let i = 0; i < blockCount; i++) {
            cfgBlocks.push({
                start: wasm.wcet_get_cfg_block_start(i),
                end: wasm.wcet_get_cfg_block_end(i),
                bcet: wasm.wcet_get_cfg_block_bcet(i),
                wcet: wasm.wcet_get_cfg_block_wcet(i),
                unreachable: !!wasm.wcet_get_cfg_block_is_unreachable(i),
                stack_delta: wasm.wcet_get_cfg_block_stack_delta(i),
            })
        }

        // Read CFG edges
        const edgeCount = wasm.wcet_get_edge_count ? wasm.wcet_get_edge_count() : 0
        const cfgEdges = []
        for (let i = 0; i < edgeCount; i++) {
            const typeId = wasm.wcet_get_cfg_edge_type(i)
            cfgEdges.push({
                from: wasm.wcet_get_cfg_edge_from(i),
                to: wasm.wcet_get_cfg_edge_to(i),
                type: edgeTypeNames[typeId] || `unknown(${typeId})`,
                is_back_edge: !!wasm.wcet_get_cfg_edge_is_back(i),
            })
        }

        // Read loops
        const loopCount = wasm.wcet_get_loop_count ? wasm.wcet_get_loop_count() : 0
        const cfgLoops = []
        for (let i = 0; i < loopCount; i++) {
            cfgLoops.push({
                header: wasm.wcet_get_loop_header(i),
                back_edge: wasm.wcet_get_loop_back_edge(i),
                max_iterations: wasm.wcet_get_loop_max_iterations(i),
            })
        }

        // Read target profile info
        const hasTarget = wasm.wcet_get_has_target ? !!wasm.wcet_get_has_target() : false
        let targetInfo = null
        if (hasTarget) {
            targetInfo = {
                name: wasm.wcet_target_get_active_name ? this.readCString(wasm.wcet_target_get_active_name()) : '',
                arch: wasm.wcet_target_get_active_arch ? this.readCString(wasm.wcet_target_get_active_arch()) : '',
                clock_mhz: wasm.wcet_target_get_active_clock ? wasm.wcet_target_get_active_clock() : 0,
                match_quality: wasm.wcet_target_get_match_quality ? wasm.wcet_target_get_match_quality() : 0,
                match_reason: wasm.wcet_target_get_match_reason ? this.readCString(wasm.wcet_target_get_match_reason()) : '',
            }
        }

        return {
            bytecode_size: wasm.wcet_get_bytecode_size(),
            instruction_count: wasm.wcet_get_instruction_count(),
            unique_opcodes: wasm.wcet_get_unique_opcodes(),
            block_count: blockCount,
            edge_count: edgeCount,
            loop_count: loopCount,
            unreachable_blocks: wasm.wcet_get_unreachable_blocks(),
            dead_code_bytes: wasm.wcet_get_dead_code_bytes(),
            bcet_cycles: wasm.wcet_get_bcet_cycles(),
            wcet_cycles: wasm.wcet_get_wcet_cycles(),
            bcet_instructions: wasm.wcet_get_bcet_instructions(),
            wcet_instructions: wasm.wcet_get_wcet_instructions(),
            bcet_ns: wasm.wcet_get_bcet_ns ? wasm.wcet_get_bcet_ns() : 0,
            wcet_ns: wasm.wcet_get_wcet_ns ? wasm.wcet_get_wcet_ns() : 0,
            has_target: hasTarget,
            target: targetInfo,
            max_stack_depth: wasm.wcet_get_max_stack_depth(),
            min_stack_depth: wasm.wcet_get_min_stack_depth(),
            stack_at_exit: wasm.wcet_get_stack_at_exit(),
            max_call_depth: wasm.wcet_get_max_call_depth(),
            has_recursion: !!wasm.wcet_get_has_recursion(),
            total_paths: wasm.wcet_get_total_paths(),
            shortest_path_blocks: wasm.wcet_get_shortest_path_blocks(),
            longest_path_blocks: wasm.wcet_get_longest_path_blocks(),
            warning_count: wasm.wcet_get_warning_count(),
            warnings: {
                dead_code: !!wasm.wcet_get_has_dead_code(),
                infinite_loop: !!wasm.wcet_get_has_infinite_loop(),
                stack_overflow: !!wasm.wcet_get_has_stack_overflow(),
                stack_underflow: !!wasm.wcet_get_has_stack_underflow(),
                unbalanced_stack: !!wasm.wcet_get_has_unbalanced_stack(),
            },
            opcode_frequency: opcodeFrequency,
            cfg: {
                blocks: cfgBlocks,
                edges: cfgEdges,
                loops: cfgLoops,
            },
        }
    }

    /**
     * Lists all available WCET target profiles for calibrated hardware timing estimates.
     * @returns {Array<{ name: string, arch: string, clock_mhz: number, capabilities: number }>}
     */
    listWCETTargets() {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        const wasm = this.wasm_exports
        if (!wasm.wcet_target_count) return []
        const count = wasm.wcet_target_count()
        const targets = []
        for (let i = 0; i < count; i++) {
            const namePtr = wasm.wcet_target_list_name(i)
            const archPtr = wasm.wcet_target_list_arch(i)
            targets.push({
                name: namePtr ? this.readCString(namePtr) : '',
                arch: archPtr ? this.readCString(archPtr) : '',
                clock_mhz: wasm.wcet_target_list_clock ? wasm.wcet_target_list_clock(i) : 0,
                capabilities: wasm.wcet_target_list_caps ? wasm.wcet_target_list_caps(i) : 0,
            })
        }
        return targets
    }

    /**
     * Selects a WCET target profile by name for subsequent analyzeWCET calls.
     * @param {string} name - Target name or partial match (e.g., 'stm32f401', 'esp32').
     * @returns {{ matched: boolean, name: string, arch: string, clock_mhz: number, quality: number }} Selection result.
     */
    selectWCETTarget(name) {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        const wasm = this.wasm_exports
        if (!wasm.wcet_target_count) return { matched: false, name: '', arch: '', clock_mhz: 0, quality: 0 }
        const targetLC = name.toLowerCase()
        const count = wasm.wcet_target_count()
        for (let i = 0; i < count; i++) {
            const namePtr = wasm.wcet_target_list_name(i)
            const archPtr = wasm.wcet_target_list_arch(i)
            const tname = namePtr ? this.readCString(namePtr) : ''
            const tarch = archPtr ? this.readCString(archPtr) : ''
            if (tname.toLowerCase().includes(targetLC) || tarch.toLowerCase().includes(targetLC)) {
                wasm.wcet_target_select_by_index(i)
                return {
                    matched: true,
                    name: tname,
                    arch: tarch,
                    clock_mhz: wasm.wcet_target_list_clock ? wasm.wcet_target_list_clock(i) : 0,
                    quality: 3,
                }
            }
        }
        if (wasm.wcet_target_reset) wasm.wcet_target_reset()
        return { matched: false, name: '', arch: '', clock_mhz: 0, quality: 0 }
    }

    /** @private Helper to get opcode name string (best-effort) */
    _getOpcodeName(opcode) {
        const names = {
            0x00: 'NOP', 0x01: 'PTR', 0x02: 'BOOL', 0x03: 'U8', 0x04: 'U16', 0x05: 'U32', 0x06: 'U64',
            0x07: 'I8', 0x08: 'I16', 0x09: 'I32', 0x0A: 'I64', 0x0B: 'F32', 0x0C: 'F64', 0x0D: 'CHAR',
            0x10: 'CVT', 0x11: 'LOAD', 0x12: 'MOVE', 0x13: 'MOVE_COPY',
            0x14: 'COPY', 0x15: 'SWAP', 0x16: 'DROP', 0x17: 'CLEAR',
            0x18: 'LOAD_FROM', 0x19: 'MOVE_TO', 0x1A: 'INC_MEM', 0x1B: 'DEC_MEM',
            0x1C: 'PICK', 0x1D: 'POKE', 0x1E: 'MEM_FILL',
            0x20: 'ADD', 0x21: 'SUB', 0x22: 'MUL', 0x23: 'DIV', 0x24: 'MOD',
            0x25: 'POW', 0x26: 'SQRT', 0x27: 'NEG', 0x29: 'ABS', 0x2A: 'SIN', 0x2B: 'COS',
            0x30: 'TON_CONST', 0x31: 'TON_MEM', 0x32: 'TOF_CONST', 0x33: 'TOF_MEM',
            0x34: 'TP_CONST', 0x35: 'TP_MEM', 0x36: 'CTU_CONST', 0x37: 'CTU_MEM',
            0x38: 'CTD_CONST', 0x39: 'CTD_MEM',
            0xC0: 'LOGIC_AND', 0xC1: 'LOGIC_OR', 0xC2: 'LOGIC_XOR', 0xC3: 'LOGIC_NOT',
            0xD0: 'CMP_EQ', 0xD1: 'CMP_NEQ', 0xD2: 'CMP_GT', 0xD3: 'CMP_LT',
            0xD4: 'CMP_GTE', 0xD5: 'CMP_LTE',
            0xE0: 'JMP', 0xE1: 'JMP_IF', 0xE2: 'JMP_IF_NOT',
            0xE3: 'CALL', 0xE4: 'CALL_IF', 0xE5: 'CALL_IF_NOT',
            0xE6: 'RET', 0xE7: 'RET_IF', 0xE8: 'RET_IF_NOT',
            0xE9: 'JMP_REL', 0xEA: 'JMP_IF_REL', 0xEB: 'JMP_IF_NOT_REL',
            0xEC: 'CALL_REL', 0xED: 'CALL_IF_REL', 0xEE: 'CALL_IF_NOT_REL',
            0xF0: 'FFI_CALL', 0xF1: 'FFI_CALL_STACK',
            0xFD: 'LANG', 0xFE: 'COMMENT', 0xFF: 'EXIT',
        }
        return names[opcode] || `OP_0x${opcode.toString(16).toUpperCase().padStart(2, '0')}`
    }

    /**
     * Transpiles STL (Siemens Statement List) code to PLCASM assembly.
     *
     * @param {string} stl - The STL source code.
     * @returns {CompileResult} - The compilation result with type='plcasm'.
     * @throws {Error} If transpilation fails.
     */
    compileSTL(stl) {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.stl_load_from_stream) throw new Error("'stl_load_from_stream' function not found - STL compiler not available")
        if (!this.wasm_exports.stl_compile) throw new Error("'stl_compile' function not found")
        if (!this.wasm_exports.stl_get_output) throw new Error("'stl_get_output' function not found")
        if (!this.wasm_exports.stl_has_error) throw new Error("'stl_has_error' function not found")

        // Return empty result for empty/whitespace-only input
        if (!stl || !stl.trim()) return { type: 'plcasm', size: 0, output: '' }

        // Clear any stale data in the stream buffer first
        if (this.wasm_exports.streamClear) this.wasm_exports.streamClear()

        // Stream STL code to compiler
        let ok = true
        for (let i = 0; i < stl.length && ok; i++) {
            ok = this.wasm_exports.streamIn(stl.charCodeAt(i))
        }
        if (!ok) throw new Error('Failed to stream STL code')
        this.wasm_exports.streamIn(0) // Null terminator

        // Load from stream and compile STL to PLCASM
        this.wasm_exports.stl_load_from_stream()
        const stlSuccess = this.wasm_exports.stl_compile()

        if (!stlSuccess) {
            const hasError = this.wasm_exports.stl_has_error()
            if (hasError) {
                const errorLine = this.wasm_exports.stl_get_error_line ? this.wasm_exports.stl_get_error_line() : 0
                const errorCol = this.wasm_exports.stl_get_error_column ? this.wasm_exports.stl_get_error_column() : 0
                throw new Error(`STL compilation failed at line ${errorLine}, column ${errorCol}`)
            }
            throw new Error('STL compilation failed')
        }

        // Get the generated PLCASM via stream buffer
        let plcasmCode = ''
        if (this.wasm_exports.stl_output_to_stream) {
            this.flushOutBuffer() // Clear any previous output
            this.wasm_exports.stl_output_to_stream()
            plcasmCode = this.readOutBuffer()
        }

        return {
            type: 'plcasm',
            size: plcasmCode.length,
            output: plcasmCode,
        }
    }

    /**
     * Transpiles Ladder Graph JSON to STL (Statement List) code.
     * Uses the graph format with nodes and connections.
     *
     * @param {string | LadderGraph} ladder - The Ladder Graph as JSON string or object.
     * @returns {CompileResult} - The compilation result with type='stl'.
     * @throws {Error} If transpilation fails.
     */
    compileLadder(ladder) {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.ladder_standalone_load_stream) throw new Error("'ladder_standalone_load_stream' function not found - Ladder Graph compiler not available")
        if (!this.wasm_exports.ladder_standalone_compile) throw new Error("'ladder_standalone_compile' function not found")
        if (!this.wasm_exports.ladder_standalone_get_output_len) throw new Error("'ladder_standalone_get_output_len' function not found")

        // Convert object to JSON string if needed
        const ladderJson = typeof ladder === 'string' ? ladder : JSON.stringify(ladder)

        // Return empty result for empty/whitespace-only input
        if (!ladderJson || !ladderJson.trim()) return { type: 'stl', size: 0, output: '' }

        // Clear any stale data in the stream buffer first
        if (this.wasm_exports.streamClear) this.wasm_exports.streamClear()

        // Clear ladder compiler state
        if (this.wasm_exports.ladder_standalone_clear) this.wasm_exports.ladder_standalone_clear()

        // Stream Ladder Graph JSON to compiler
        let ok = true
        for (let i = 0; i < ladderJson.length && ok; i++) {
            ok = this.wasm_exports.streamIn(ladderJson.charCodeAt(i))
        }
        if (!ok) throw new Error('Failed to stream Ladder Graph JSON')
        this.wasm_exports.streamIn(0) // Null terminator

        // Load from stream and compile Ladder Graph to STL
        this.wasm_exports.ladder_standalone_load_stream()
        const ladderSuccess = this.wasm_exports.ladder_standalone_compile()

        if (!ladderSuccess) {
            // Get error message if available
            if (this.wasm_exports.ladder_standalone_has_error && this.wasm_exports.ladder_standalone_has_error()) {
                const errPtr = this.wasm_exports.ladder_standalone_get_error()
                if (errPtr) {
                    const mem = new Uint8Array(this.wasm_exports.memory.buffer)
                    let errMsg = ''
                    for (let i = 0; i < 256 && mem[errPtr + i] !== 0; i++) {
                        errMsg += String.fromCharCode(mem[errPtr + i])
                    }
                    throw new Error(`Ladder Graph compilation failed: ${errMsg}`)
                }
            }
            throw new Error('Ladder Graph compilation failed')
        }

        // Use the return value from compile (which is output_len) directly
        // because getter functions are affected by WASM static initializer issues
        const outputLen = ladderSuccess  // compile() returns output_len on success
        const outputPtr = this.wasm_exports.ladder_standalone_get_output()
        let stlCode = ''
        if (outputLen > 0 && outputPtr) {
            const mem = new Uint8Array(this.wasm_exports.memory.buffer)
            for (let i = 0; i < outputLen; i++) {
                stlCode += String.fromCharCode(mem[outputPtr + i])
            }
        }

        return {
            type: 'stl',
            size: stlCode.length,
            output: stlCode,
        }
    }

    /**
     * Transpiles PLCScript code to PLCASM assembly.
     *
     * @param {string} plcscript - The PLCScript source code.
     * @returns {CompileResult} - The compilation result with type='plcasm'.
     * @throws {Error} If transpilation fails.
     */
    compilePLCScript(plcscript) {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.plcscript_load_from_stream) throw new Error("'plcscript_load_from_stream' function not found - PLCScript compiler not available")
        if (!this.wasm_exports.plcscript_compile) throw new Error("'plcscript_compile' function not found")

        // Return empty result for empty/whitespace-only input
        if (!plcscript || !plcscript.trim()) return { type: 'plcasm', size: 0, output: '' }

        // Reset compiler state
        if (this.wasm_exports.plcscript_reset) this.wasm_exports.plcscript_reset()

        // Clear any stale data in the stream buffer first
        if (this.wasm_exports.streamClear) this.wasm_exports.streamClear()

        // Stream PLCScript code to compiler
        let ok = true
        for (let i = 0; i < plcscript.length && ok; i++) {
            ok = this.wasm_exports.streamIn(plcscript.charCodeAt(i))
        }
        if (!ok) throw new Error('Failed to stream PLCScript code')
        this.wasm_exports.streamIn(0) // Null terminator

        // Load from stream and compile PLCScript to PLCASM
        this.wasm_exports.plcscript_load_from_stream()
        const success = this.wasm_exports.plcscript_compile()

        if (!success) {
            if (this.wasm_exports.plcscript_hasError && this.wasm_exports.plcscript_hasError()) {
                const errorLine = this.wasm_exports.plcscript_getErrorLine ? this.wasm_exports.plcscript_getErrorLine() : 0
                const errorCol = this.wasm_exports.plcscript_getErrorColumn ? this.wasm_exports.plcscript_getErrorColumn() : 0
                const errPtr = this.wasm_exports.plcscript_getError ? this.wasm_exports.plcscript_getError() : 0
                const errMsg = errPtr ? this.readCString(errPtr) : ''
                throw new Error(`PLCScript compilation failed at line ${errorLine}, column ${errorCol}: ${errMsg}`)
            }
            throw new Error('PLCScript compilation failed')
        }

        // Get the generated PLCASM output
        let plcasmCode = ''
        if (this.wasm_exports.plcscript_output_to_stream) {
            this.flushOutBuffer() // Clear any previous output
            this.wasm_exports.plcscript_output_to_stream()
            plcasmCode = this.readOutBuffer()
        } else if (this.wasm_exports.plcscript_getOutput && this.wasm_exports.plcscript_getOutputLength) {
            const outputPtr = this.wasm_exports.plcscript_getOutput()
            const outputLen = this.wasm_exports.plcscript_getOutputLength()
            if (outputLen > 0 && outputPtr) {
                plcasmCode = this.readCString(outputPtr, outputLen + 1)
            }
        }

        return {
            type: 'plcasm',
            size: plcasmCode.length,
            output: plcasmCode,
        }
    }

    /**
     * Transpiles ST (Structured Text) code to PLCScript.
     *
     * @param {string} st - The ST source code.
     * @returns {CompileResult} - The compilation result with type='plcscript'.
     * @throws {Error} If transpilation fails.
     */
    compileST(st) {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.st_compiler_load_from_stream) throw new Error("'st_compiler_load_from_stream' function not found - ST compiler not available")
        if (!this.wasm_exports.st_compiler_compile) throw new Error("'st_compiler_compile' function not found")

        // Return empty result for empty/whitespace-only input
        if (!st || !st.trim()) return { type: 'plcscript', size: 0, output: '' }

        // Clear any stale data in the stream buffer first
        if (this.wasm_exports.streamClear) this.wasm_exports.streamClear()

        // Stream ST code to compiler
        let ok = true
        for (let i = 0; i < st.length && ok; i++) {
            ok = this.wasm_exports.streamIn(st.charCodeAt(i))
        }
        if (!ok) throw new Error('Failed to stream ST code')
        this.wasm_exports.streamIn(0) // Null terminator

        // Load from stream and compile ST to PLCScript
        this.wasm_exports.st_compiler_load_from_stream()
        const errorCode = this.wasm_exports.st_compiler_compile()

        if (errorCode !== 0) {
            if (this.wasm_exports.st_compiler_has_error && this.wasm_exports.st_compiler_has_error()) {
                const errorLine = this.wasm_exports.st_compiler_get_error_line ? this.wasm_exports.st_compiler_get_error_line() : 0
                const errorCol = this.wasm_exports.st_compiler_get_error_column ? this.wasm_exports.st_compiler_get_error_column() : 0
                const errPtr = this.wasm_exports.st_compiler_get_error ? this.wasm_exports.st_compiler_get_error() : 0
                const errMsg = errPtr ? this.readCString(errPtr) : ''
                const tokenPtr = this.wasm_exports.st_compiler_get_error_token_text ? this.wasm_exports.st_compiler_get_error_token_text() : 0
                const tokenText = tokenPtr ? this.readCString(tokenPtr) : ''
                throw new Error(`ST compilation failed at line ${errorLine}, column ${errorCol}: ${errMsg}${tokenText ? ` (token: "${tokenText}")` : ''}`)
            }
            throw new Error('ST compilation failed')
        }

        // Get the generated PLCScript output
        let plcscriptCode = ''
        if (this.wasm_exports.st_compiler_output_to_stream) {
            this.flushOutBuffer() // Clear any previous output
            this.wasm_exports.st_compiler_output_to_stream()
            plcscriptCode = this.readOutBuffer()
        } else if (this.wasm_exports.st_compiler_get_output && this.wasm_exports.st_compiler_get_output_length) {
            const outputPtr = this.wasm_exports.st_compiler_get_output()
            const outputLen = this.wasm_exports.st_compiler_get_output_length()
            if (outputLen > 0 && outputPtr) {
                plcscriptCode = this.readCString(outputPtr, outputLen + 1)
            }
        }

        return {
            type: 'plcscript',
            size: plcscriptCode.length,
            output: plcscriptCode,
        }
    }

    /**
     * @typedef {{ ladderGraph?: string, stl?: string, plcscript?: string, plcasm?: string, bytecode?: string }} CompileAllResult
     */

    /**
     * Compiles source code through the full pipeline based on starting language.
     * Returns all intermediate representations.
     *
     * Pipeline: Ladder → STL → PLCASM → Bytecode
     *           ST → PLCScript → PLCASM → Bytecode
     *           PLCScript → PLCASM → Bytecode
     *           STL → PLCASM → Bytecode
     *           PLCASM → Bytecode
     *
     * @param {string | LadderGraph} source - The source code.
     * @param {'ladder-graph' | 'stl' | 'st' | 'plcscript' | 'plcasm'} language - The source language.
     * @returns {CompileAllResult} - Object containing all compilation stages.
     * @throws {Error} If any compilation step fails.
     */
    compileAll(source, language) {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')

        /** @type {CompileAllResult} */
        const result = {}

        let currentSource = typeof source === 'string' ? source : JSON.stringify(source)
        let currentLang = language

        // Stage: Ladder Graph → STL
        if (currentLang === 'ladder-graph') {
            result.ladderGraph = currentSource
            const ladderResult = this.compileLadder(currentSource)
            result.stl = ladderResult.output
            currentSource = ladderResult.output
            currentLang = 'stl'
        }

        // Stage: ST → PLCScript
        if (currentLang === 'st') {
            result.st = currentSource
            const stResult = this.compileST(currentSource)
            result.plcscript = stResult.output
            currentSource = stResult.output
            currentLang = 'plcscript'
        }

        // Stage: PLCScript → PLCASM
        if (currentLang === 'plcscript') {
            if (!result.plcscript) result.plcscript = currentSource
            const plcscriptResult = this.compilePLCScript(currentSource)
            result.plcasm = plcscriptResult.output
            currentSource = plcscriptResult.output
            currentLang = 'plcasm'
        }

        // Stage: STL → PLCASM
        if (currentLang === 'stl') {
            if (!result.stl) result.stl = currentSource
            const stlResult = this.compileSTL(currentSource)
            result.plcasm = stlResult.output
            currentSource = stlResult.output
            currentLang = 'plcasm'
        }

        // Stage: PLCASM → Bytecode
        if (currentLang === 'plcasm') {
            if (!result.plcasm) result.plcasm = currentSource
            const plcasmResult = this.compilePLCASM(currentSource)
            result.bytecode = plcasmResult.output
        }

        return result
    }

    /** @type {Record<number, string>} */
    static LANG_MAP = {
        0: 'UNKNOWN',
        1: 'PLCASM',
        2: 'STL',
        3: 'LADDER',
        4: 'FBD',
        5: 'SFC',
        6: 'ST',
        7: 'IL',
        8: 'PLCSCRIPT',
    }

    /**
     * Reads all accumulated project problems from WASM memory.
     * @returns {ProjectCompileProblem[]}
     */
    _readProjectProblems = () => {
        const count = this.wasm_exports.project_getProblemCount ? this.wasm_exports.project_getProblemCount() : 0
        if (count === 0) return []
        const pointer = this.wasm_exports.project_getProblems ? this.wasm_exports.project_getProblems() : 0
        if (!pointer) return []

        const struct_size = 348
        const view = new DataView(this.wasm_exports.memory.buffer)
        /** @type {ProjectCompileProblem[]} */
        const problems = []

        for (let i = 0; i < count; i++) {
            const offset = pointer + i * struct_size
            const type_int = view.getUint32(offset + 0, true)
            const line = view.getUint32(offset + 4, true)
            const column = view.getUint32(offset + 8, true)
            const length = view.getUint32(offset + 12, true)

            const readFixedStr = (start, maxLen) => {
                let s = ''
                for (let j = 0; j < maxLen; j++) {
                    const c = view.getUint8(offset + start + j)
                    if (c === 0) break
                    s += String.fromCharCode(c)
                }
                return s
            }

            const message = readFixedStr(16, 128)
            const block = readFixedStr(144, 64)
            const program = readFixedStr(208, 64)
            const lang = view.getUint32(offset + 272, true)
            const token = readFixedStr(276, 64)
            const db_number = view.getInt32(offset + 344, true)
            const langName = VovkPLC_class.LANG_MAP[lang] || 'UNKNOWN'

            problems.push({
                type: type_int === 2 ? 'error' : type_int === 1 ? 'warning' : 'info',
                message,
                line,
                column,
                length,
                program: program || undefined,
                block: block || undefined,
                lang,
                compiler: langName,
                token: token || undefined,
                db: db_number >= 0 ? db_number : undefined,
            })
        }

        return problems
    }

    /**
     * @typedef {{
     *     type: 'error' | 'warning' | 'info',
     *     message: string,
     *     line: number,
     *     column: number,
     *     length?: number,
     *     program?: string,
     *     block?: string,
     *     lang?: number,
     *     compiler?: string,
     *     token?: string,
     *     db?: number
     * }} ProjectCompileProblem
     */

    /**
     * @typedef {{
     *     memory: { used: number, available: number },
     *     memory_map: { [area: string]: [number, number] },
     *     flash: { used: number, size: number },
     *     execution: { steps: number, stackSize: number }
     * }} ProjectCompileOutput
     */

    /**
     * @typedef {{ bytecode: string, compileTime: number, problem: null, warnings: ProjectCompileProblem[], output: ProjectCompileOutput } | { bytecode: null, compileTime: number, problem: ProjectCompileProblem, warnings: ProjectCompileProblem[], output: null }} ProjectCompileResult
     */

    /**
     * @typedef {Object} ProjectCompileOptions
     * @property {number} [targetFlags] - Target device feature flags for cross-compilation validation.
     *   Use VovkPLC.RUNTIME_FLAGS constants or a value from decodeRuntimeFlags().raw.
     *   Default is 0xFFFF (all features enabled). Set to a device's actual flags to get errors
     *   when the project uses unsupported features like timers, counters, or strings.
     */

    /**
     * Compiles a complete PLC project definition into bytecode.
     * The project format supports multiple files, blocks, symbols, and mixed languages (PLCASM, STL, LADDER).
     *
     * @param {string} projectSource - The project definition string (starts with VOVKPLCPROJECT).
     * @param {ProjectCompileOptions} [options] - Compilation options including target device flags.
     * @returns {ProjectCompileResult} - Object with either { bytecode, problem: null } on success or { bytecode: null, problem } on failure.
     *
     * @example
     * const result = runtime.compileProject(`
     * VOVKPLCPROJECT MyProject
     * VERSION 1.0
     *
     * PROGRAM Main
     *     BLOCK Code LANG=PLCASM
     *         u8.const 42
     *         exit
     *     END_BLOCK
     * END_PROGRAM
     * `)
     *
     * if (result.problem) {
     *     console.error(`Error at line ${result.problem.line}: ${result.problem.message}`)
     * } else {
     *     console.log('Bytecode:', result.bytecode)
     * }
     *
     * @example
     * // Cross-compile for a device without timer support
     * const deviceFlags = 0x0023; // Little-endian, strings, no timers/counters
     * const result = runtime.compileProject(projectSource, { targetFlags: deviceFlags });
     * // Will error if project uses timers or counters
     */
    compileProject = (projectSource, options = {}) => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.project_compile) throw new Error("'project_compile' function not found - Project compiler not available")
        if (!this.wasm_exports.project_reset) throw new Error("'project_reset' function not found")
        if (!this.wasm_exports.project_hasError) throw new Error("'project_hasError' function not found")
        if (!this.wasm_exports.project_getBytecode) throw new Error("'project_getBytecode' function not found")
        if (!this.wasm_exports.project_getBytecodeLength) throw new Error("'project_getBytecodeLength' function not found")

        // Start timing
        const startTime = performance.now()

        // Reset compiler state
        this.wasm_exports.project_reset()

        // Set or clear target flags based on options
        // If targetFlags provided explicitly, use them (API takes priority)
        // If not provided, clear API flag so FLAGS section in project can be used
        if (typeof options.targetFlags === 'number') {
            if (this.wasm_exports.project_setTargetFlags) {
                this.wasm_exports.project_setTargetFlags(options.targetFlags)
            }
        } else {
            // No explicit flags - clear API flag so FLAGS section or default (0xFFFF) is used
            if (this.wasm_exports.project_clearTargetFlags) {
                this.wasm_exports.project_clearTargetFlags()
            }
        }

        // Clear any stale data in the stream buffer first
        if (this.wasm_exports.streamClear) this.wasm_exports.streamClear()

        // Stream project source to compiler
        let ok = true
        for (let i = 0; i < projectSource.length && ok; i++) {
            ok = this.wasm_exports.streamIn(projectSource.charCodeAt(i))
        }
        if (!ok) {
            return {
                bytecode: null,
                compileTime: +(performance.now() - startTime).toFixed(1),
                problem: {
                    type: 'error',
                    message: 'Failed to stream project source - buffer overflow',
                    line: 0,
                    column: 0,
                },
                warnings: [],
                output: null,
            }
        }

        // Compile the project (reads from stream buffer)
        const success = this.wasm_exports.project_compile(false)

        // Check for errors using accumulated problems API
        if (!success || this.wasm_exports.project_hasError()) {
            const allProblems = this._readProjectProblems()
            const warnings = allProblems.filter(p => p.type !== 'error')

            if (allProblems.length > 0) {
                // Find first error, or fall back to first problem
                const firstError = allProblems.find(p => p.type === 'error') || allProblems[0]

                return {
                    bytecode: null,
                    compileTime: +(performance.now() - startTime).toFixed(1),
                    problem: firstError,
                    warnings,
                    output: null,
                }
            }

            // Fallback to old single-error API if no accumulated problems
            const errorPtr = this.wasm_exports.project_getError ? this.wasm_exports.project_getError() : 0
            const errorLine = this.wasm_exports.project_getErrorLine ? this.wasm_exports.project_getErrorLine() : 0
            const errorColumn = this.wasm_exports.project_getErrorColumn ? this.wasm_exports.project_getErrorColumn() : 0
            const errorBlock = this.wasm_exports.project_getErrorBlock ? this.wasm_exports.project_getErrorBlock() : 0
            const errorCompiler = this.wasm_exports.project_getErrorCompiler ? this.wasm_exports.project_getErrorCompiler() : 0

            // Read error message from memory
            let message = 'Unknown compilation error'
            if (errorPtr) {
                const memory = new Uint8Array(this.wasm_exports.memory.buffer)
                let str = ''
                let i = errorPtr
                while (memory[i] !== 0 && i < memory.length && str.length < 512) {
                    str += String.fromCharCode(memory[i])
                    i++
                }
                if (str) message = str
            }

            // Read block name if available
            let block = undefined
            if (errorBlock) {
                const memory = new Uint8Array(this.wasm_exports.memory.buffer)
                let str = ''
                let i = errorBlock
                while (memory[i] !== 0 && i < memory.length && str.length < 64) {
                    str += String.fromCharCode(memory[i])
                    i++
                }
                if (str) block = str
            }

            // Read compiler name if available
            let compiler = undefined
            if (errorCompiler) {
                const memory = new Uint8Array(this.wasm_exports.memory.buffer)
                let str = ''
                let i = errorCompiler
                while (memory[i] !== 0 && i < memory.length && str.length < 64) {
                    str += String.fromCharCode(memory[i])
                    i++
                }
                if (str) compiler = str
            }

            return {
                bytecode: null,
                compileTime: +(performance.now() - startTime).toFixed(1),
                problem: {
                    type: 'error',
                    message,
                    line: errorLine,
                    column: errorColumn,
                    ...(block && {block}),
                    ...(compiler && {compiler}),
                },
                warnings: [],
                output: null,
            }
        }

        // Get bytecode
        const bytecodePtr = this.wasm_exports.project_getBytecode()
        const bytecodeLen = this.wasm_exports.project_getBytecodeLength()

        if (!bytecodePtr || bytecodeLen === 0) {
            return {
                bytecode: null,
                compileTime: +(performance.now() - startTime).toFixed(1),
                problem: {
                    type: 'error',
                    message: 'Compilation produced no bytecode',
                    line: 0,
                    column: 0,
                },
                warnings: [],
                output: null,
            }
        }

        // Convert bytecode to hex string
        const memory = new Uint8Array(this.wasm_exports.memory.buffer)
        let hex = ''
        for (let i = 0; i < bytecodeLen; i++) {
            hex += memory[bytecodePtr + i].toString(16).padStart(2, '0').toUpperCase()
            if (i < bytecodeLen - 1) hex += ' '
        }

        // Get memory and flash usage
        const memUsed = this.wasm_exports.project_getMemoryUsed ? this.wasm_exports.project_getMemoryUsed() : 0
        const memAvailable = this.wasm_exports.project_getMemoryAvailable ? this.wasm_exports.project_getMemoryAvailable() : 0
        const flashUsed = this.wasm_exports.project_getFlashUsed ? this.wasm_exports.project_getFlashUsed() : bytecodeLen
        const flashSize = this.wasm_exports.project_getFlashSize ? this.wasm_exports.project_getFlashSize() : 32768

        // Get timer and counter configuration
        const timerOffset = this.wasm_exports.project_getTimerOffset ? this.wasm_exports.project_getTimerOffset() : 0
        const timerCount = this.wasm_exports.project_getTimerCount ? this.wasm_exports.project_getTimerCount() : 0
        const counterOffset = this.wasm_exports.project_getCounterOffset ? this.wasm_exports.project_getCounterOffset() : 0
        const counterCount = this.wasm_exports.project_getCounterCount ? this.wasm_exports.project_getCounterCount() : 0

        // Build complete memory map: { [area: string]: [offset: number, size: number] }
        /** @type {{ [area: string]: [number, number] }} */
        const memoryMap = {}
        const areaCount = this.wasm_exports.project_getMemoryAreaCount ? this.wasm_exports.project_getMemoryAreaCount() : 0
        for (let i = 0; i < areaCount; i++) {
            const namePtr = this.wasm_exports.project_getMemoryAreaName(i)
            const start = this.wasm_exports.project_getMemoryAreaStart(i)
            const end = this.wasm_exports.project_getMemoryAreaEnd(i)
            const name = this.readCString(namePtr)
            if (name) {
                memoryMap[name] = [start, end - start + 1]
            }
        }
        // Add timer and counter areas if they exist
        if (timerCount > 0) {
            const timerStructSize = 9 // Timer struct: 1 byte state + 4 byte preset + 4 byte elapsed
            memoryMap['T'] = [timerOffset, timerCount * timerStructSize]
        }
        if (counterCount > 0) {
            const counterStructSize = 5 // Counter struct: 1 byte state + 2 byte preset + 2 byte count
            memoryMap['C'] = [counterOffset, counterCount * counterStructSize]
        }

        // Load and run the program to get execution stats
        let steps = 0
        let stackSize = 0
        const loaded = this.wasm_exports.project_load ? this.wasm_exports.project_load() : false
        if (loaded) {
            if (this.wasm_exports.clearStack) this.wasm_exports.clearStack()
            if (this.wasm_exports.run) this.wasm_exports.run()
            steps = this.wasm_exports.getLastInstructionCount ? this.wasm_exports.getLastInstructionCount() : 0
            stackSize = this.wasm_exports.getStackSize ? this.wasm_exports.getStackSize() || 0 : 0
        }

        // Collect any accumulated warnings/info from compilation (e.g. from sub-compilers)
        const allProblems = this._readProjectProblems()
        const warnings = allProblems.filter(p => p.type !== 'error')

        return {
            bytecode: hex,
            compileTime: +(performance.now() - startTime).toFixed(1),
            problem: null,
            warnings,
            output: {
                memory: { used: memUsed, available: memAvailable },
                memory_map: memoryMap,
                flash: { used: flashUsed, size: flashSize },
                execution: { steps, stackSize },
            },
        }
    }

    /**
     * @typedef {{
     *     name: string,
     *     type: string,
     *     address: string,
     *     byteAddress: number,
     *     bit?: number,
     *     isBit: boolean,
     *     typeSize: number
     * }} ProjectSymbol
     */

    /**
     * @typedef {{
     *     name: string,
     *     start: number,
     *     end: number,
     *     size: number
     * }} ProjectMemoryArea
     */

    /**
     * @typedef {{
     *     name: string,
     *     file: string,
     *     program: string,
     *     language: string,
     *     offset: number,
     *     size: number
     * }} ProjectBlock
     */

    /**
     * @typedef {{
     *     path: string,
     *     firstBlockIndex: number,
     *     blockCount: number,
     *     executionOrder: number
     * }} ProjectFile
     */

    /**
     * @typedef {{
     *     success: true,
     *     project: { name: string, version: string },
     *     memory: { used: number, available: number },
     *     flash: { used: number, size: number },
     *     symbols: ProjectSymbol[],
     *     memoryAreas: ProjectMemoryArea[],
     *     blocks: ProjectBlock[],
     *     files: ProjectFile[]
     * } | {
     *     success: false,
     *     error: string
     * }} ProjectIR
     */

    /**
     * Compiles a PLC project and returns the intermediate representation (IR) including
     * symbols, memory areas, blocks, and files. Useful for debugging, hot-updating values,
     * and understanding the memory layout without needing the bytecode.
     *
     * @param {string} projectSource - The project definition string (starts with VOVKPLCPROJECT).
     * @returns {ProjectIR} - Object with project structure or error.
     *
     * @example
     * const ir = runtime.getProjectIR(projectSource)
     * if (ir.success) {
     *     // Find a symbol to hot-update
     *     const timer = ir.symbols.find(s => s.name === 'delay_timer')
     *     console.log(`Timer at address ${timer.address} (byte ${timer.byteAddress})`)
     * }
     */
    getProjectIR = projectSource => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.project_compile) throw new Error("'project_compile' function not found - Project compiler not available")

        const wasm = this.wasm_exports

        // Helper to read null-terminated string from WASM memory
        /** @param {number} ptr */
        const getString = ptr => {
            if (!ptr) return ''
            const memory = new Uint8Array(wasm.memory.buffer)
            let str = ''
            let i = ptr
            while (memory[i] !== 0 && i < memory.length && str.length < 512) {
                str += String.fromCharCode(memory[i])
                i++
            }
            return str
        }

        // Compile the project first
        wasm.project_reset()
        if (wasm.streamClear) wasm.streamClear()
        for (let i = 0; i < projectSource.length; i++) {
            wasm.streamIn(projectSource.charCodeAt(i))
        }
        const success = wasm.project_compile(false)

        if (!success || wasm.project_hasError()) {
            const errorPtr = wasm.project_getError ? wasm.project_getError() : 0
            return {
                success: false,
                error: getString(errorPtr) || 'Compilation failed',
            }
        }

        const langNames = ['UNKNOWN', 'PLCASM', 'STL', 'LADDER', 'FBD', 'SFC', 'ST', 'IL']

        // Get memory areas first (needed for symbol address formatting)
        /** @type {ProjectMemoryArea[]} */
        const memoryAreas = []
        const memAreaCount = wasm.project_getMemoryAreaCount()
        for (let i = 0; i < memAreaCount; i++) {
            const name = getString(wasm.project_getMemoryAreaName(i))
            const start = wasm.project_getMemoryAreaStart(i)
            const end = wasm.project_getMemoryAreaEnd(i)
            memoryAreas.push({ name, start, end, size: end - start })
        }

        // Helper to convert byte address to partitioned address (e.g., 448 -> "M0")
        /** @param {number} byteAddress @param {number} bit @param {boolean} isBit */
        const toPartitionedAddress = (byteAddress, bit, isBit) => {
            for (const area of memoryAreas) {
                if (byteAddress >= area.start && byteAddress <= area.end) {
                    const offset = byteAddress - area.start
                    if (isBit) {
                        return `${area.name}${offset}.${bit}`
                    }
                    return `${area.name}${offset}`
                }
            }
            // Fallback to raw address if not in any area
            return isBit ? `${byteAddress}.${bit}` : `${byteAddress}`
        }

        // Get symbols
        /** @type {ProjectSymbol[]} */
        const symbols = []
        const symbolCount = wasm.project_getSymbolCount()
        for (let i = 0; i < symbolCount; i++) {
            const name = getString(wasm.project_getSymbolName(i))
            const type = getString(wasm.project_getSymbolType(i))
            const byteAddress = wasm.project_getSymbolByteAddress(i)
            const bit = wasm.project_getSymbolBit(i)
            const isBit = !!wasm.project_getSymbolIsBit(i)
            const typeSize = wasm.project_getSymbolTypeSize(i)
            const address = toPartitionedAddress(byteAddress, bit, isBit)

            symbols.push({
                name,
                type,
                address,
                byteAddress,
                ...(isBit && { bit }),
                isBit,
                typeSize,
            })
        }

        // Get program blocks
        /** @type {ProjectBlock[]} */
        const blocks = []
        const blockCount = wasm.project_getBlockCount()
        for (let i = 0; i < blockCount; i++) {
            const name = getString(wasm.project_getBlockName(i))
            const filePath = getString(wasm.project_getBlockFilePath(i))
            const programName = getString(wasm.project_getBlockProgramName(i))
            const lang = wasm.project_getBlockLanguage(i)
            const offset = wasm.project_getBlockOffset(i)
            const size = wasm.project_getBlockSize(i)

            blocks.push({
                name,
                file: filePath,
                program: programName,
                language: langNames[lang] || 'UNKNOWN',
                offset,
                size,
            })
        }

        // Get files
        /** @type {ProjectFile[]} */
        const files = []
        const fileCount = wasm.project_getFileCount()
        for (let i = 0; i < fileCount; i++) {
            const filePath = getString(wasm.project_getFilePath(i))
            const fileDirectory = wasm.project_getFileDirectory ? getString(wasm.project_getFileDirectory(i)) : '/'
            const firstBlockIndex = wasm.project_getFileFirstBlockIndex(i)
            const fileBlockCount = wasm.project_getFileBlockCount(i)
            const executionOrder = wasm.project_getFileExecutionOrder(i)
            files.push({
                path: filePath,
                directory: fileDirectory,
                firstBlockIndex,
                blockCount: fileBlockCount,
                executionOrder,
            })
        }

        // Get memory usage
        const memUsed = wasm.project_getMemoryUsed ? wasm.project_getMemoryUsed() : 0
        const memAvailable = wasm.project_getMemoryAvailable ? wasm.project_getMemoryAvailable() : 0
        const flashUsed = wasm.project_getFlashUsed ? wasm.project_getFlashUsed() : 0
        const flashSize = wasm.project_getFlashSize ? wasm.project_getFlashSize() : 32768

        return {
            success: true,
            project: {
                name: getString(wasm.project_getName()),
                version: getString(wasm.project_getVersion()),
            },
            memory: {
                used: memUsed,
                available: memAvailable,
            },
            flash: {
                used: flashUsed,
                size: flashSize,
            },
            symbols,
            memoryAreas,
            blocks,
            files,
        }
    }

    /**
     * @typedef {{
     *     name: string,
     *     location: 'memory' | 'program',
     *     offset: string,
     *     byteOffset: number,
     *     datatype: string,
     *     size: number,
     *     file: string,
     *     program: string,
     *     block: string,
     *     line: number,
     *     column: number,
     *     length: number,
     *     token: string,
     *     description: string
     * }} ProjectModifier
     */

    /**
     * @typedef {{
     *     success: true,
     *     modifiers: ProjectModifier[]
     * } | {
     *     success: false,
     *     error: string
     * }} ProjectModifiersResult
     */

    /**
     * Compiles a PLC project and returns all modifiable values (constants, timer presets, etc.)
     * that can be hot-patched at runtime. This is useful for creating editor UI that allows
     * precision patching of program bytecode or memory values while the program is running.
     *
     * @param {string} projectSource - The project definition string (starts with VOVKPLCPROJECT).
     * @returns {ProjectModifiersResult} - Object with modifiers array or error.
     *
     * @example
     * const result = runtime.getProjectIRModifiers(projectSource)
     * if (result.success) {
     *     for (const mod of result.modifiers) {
     *         console.log(`${mod.name}: ${mod.location} at ${mod.offset} (${mod.datatype})`)
     *     }
     * }
     */
    getProjectIRModifiers = projectSource => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.project_compile) throw new Error("'project_compile' function not found - Project compiler not available")

        const wasm = this.wasm_exports

        // Helper to read null-terminated string from WASM memory
        /** @param {number} ptr */
        const getString = ptr => {
            if (!ptr) return ''
            const memory = new Uint8Array(wasm.memory.buffer)
            let str = ''
            let i = ptr
            while (memory[i] !== 0 && i < memory.length && str.length < 512) {
                str += String.fromCharCode(memory[i])
                i++
            }
            return str
        }

        // Compile the project first
        wasm.project_reset()
        if (wasm.streamClear) wasm.streamClear()
        for (let i = 0; i < projectSource.length; i++) {
            wasm.streamIn(projectSource.charCodeAt(i))
        }
        const success = wasm.project_compile(false)

        if (!success || wasm.project_hasError()) {
            const errorPtr = wasm.project_getError ? wasm.project_getError() : 0
            return {
                success: false,
                error: getString(errorPtr) || 'Compilation failed',
            }
        }

        // Get memory areas (needed for address formatting)
        /** @type {{ name: string, start: number, end: number }[]} */
        const memoryAreas = []
        const memAreaCount = wasm.project_getMemoryAreaCount()
        for (let i = 0; i < memAreaCount; i++) {
            const name = getString(wasm.project_getMemoryAreaName(i))
            const start = wasm.project_getMemoryAreaStart(i)
            const end = wasm.project_getMemoryAreaEnd(i)
            memoryAreas.push({ name, start, end })
        }

        // Helper to convert byte address to partitioned address
        /** @param {number} byteAddress */
        const toPartitionedAddress = byteAddress => {
            for (const area of memoryAreas) {
                if (byteAddress >= area.start && byteAddress <= area.end) {
                    const offset = byteAddress - area.start
                    return `${area.name}${offset}`
                }
            }
            return `${byteAddress}`
        }

        /** @type {ProjectModifier[]} */
        const modifiers = []

        // Check if we have the modifier API available
        if (wasm.project_getModifierCount) {
            const modCount = wasm.project_getModifierCount()
            for (let i = 0; i < modCount; i++) {
                // @ts-ignore - these functions exist if project_getModifierCount exists
                const name = getString(wasm.project_getModifierName(i))
                // @ts-ignore
                const locationType = wasm.project_getModifierLocation(i) // 0 = memory, 1 = program
                // @ts-ignore
                const byteOffset = wasm.project_getModifierByteOffset(i)
                // @ts-ignore
                const datatype = getString(wasm.project_getModifierDatatype(i))
                // @ts-ignore
                const size = wasm.project_getModifierSize(i)
                // @ts-ignore
                const file = getString(wasm.project_getModifierFile(i))
                const program = wasm.project_getModifierProgram ? getString(wasm.project_getModifierProgram(i)) : file
                // @ts-ignore
                const block = getString(wasm.project_getModifierBlock(i))
                // @ts-ignore
                const line = wasm.project_getModifierLine(i)
                // @ts-ignore
                const column = wasm.project_getModifierColumn(i)
                const length = wasm.project_getModifierLength ? wasm.project_getModifierLength(i) : datatype.length
                const token = wasm.project_getModifierToken ? getString(wasm.project_getModifierToken(i)) : name
                // @ts-ignore
                const description = getString(wasm.project_getModifierDescription(i))

                const location = locationType === 0 ? 'memory' : 'program'
                const offset = location === 'memory' ? toPartitionedAddress(byteOffset) : `${byteOffset}`

                modifiers.push({
                    name,
                    location,
                    offset,
                    byteOffset,
                    datatype,
                    size,
                    file,
                    program,
                    block,
                    line,
                    column,
                    length,
                    token,
                    description,
                })
            }
        }

        // Fallback: derive modifiers from symbols for memory-based values
        // This provides basic support even without the full modifier API
        if (modifiers.length === 0 && wasm.project_getSymbolCount) {
            const symbolCount = wasm.project_getSymbolCount()
            for (let i = 0; i < symbolCount; i++) {
                const name = getString(wasm.project_getSymbolName(i))
                const type = getString(wasm.project_getSymbolType(i))
                const byteAddress = wasm.project_getSymbolByteAddress(i)
                const isBit = !!wasm.project_getSymbolIsBit(i)
                const typeSize = wasm.project_getSymbolTypeSize(i)

                // Skip bit-level symbols (they're not directly modifiable as values)
                if (isBit) continue

                // Determine size based on type
                let size = typeSize
                if (size === 0) {
                    // Infer size from type name
                    if (type.includes('8')) size = 1
                    else if (type.includes('16')) size = 2
                    else if (type.includes('32') || type === 'f32') size = 4
                    else if (type.includes('64') || type === 'f64') size = 8
                    else size = 2 // Default to 2 bytes
                }

                // Determine description based on type
                let description = `${type} variable`
                if (type.toLowerCase().includes('timer') || name.toLowerCase().includes('timer')) {
                    description = 'Timer preset/elapsed value'
                } else if (type.toLowerCase().includes('counter') || name.toLowerCase().includes('counter')) {
                    description = 'Counter preset/current value'
                }

                modifiers.push({
                    name,
                    location: 'memory',
                    offset: toPartitionedAddress(byteAddress),
                    byteOffset: byteAddress,
                    datatype: type,
                    size,
                    file: '',
                    program: '',
                    block: '',
                    line: 0, // Not available from symbols
                    column: 0,
                    length: name.length,
                    token: name,
                    description,
                })
            }
        }

        return {
            success: true,
            modifiers,
        }
    }

    /**
     * @typedef {{
     *     type: 'error' | 'warning' | 'info',
     *     message: string,
     *     line: number,
     *     column: number,
     *     length: number,
     *     program?: string,
     *     block: string | undefined,
     *     lang: number,
     *     compiler?: string,
     *     token?: string,
     *     sourceLine?: string,
     *     db?: number
     * }} ProjectLinterProblem
     */

    /**
     * Lints a complete PLC project definition and returns all problems found.
     * The project format supports multiple files, blocks, symbols, and mixed languages (PLCASM, STL, LADDER).
     *
     * @param {string} projectSource - The project definition string (starts with VOVKPLCPROJECT).
     * @param {ProjectCompileOptions} [options] - Compilation options including target device flags.
     * @returns {ProjectLinterProblem[]} - Array of problems found (empty if valid).
     *
     * @example
     * const problems = runtime.lintProject(`
     * VOVKPLCPROJECT MyProject
     * VERSION 1.0
     *
     * PROGRAM Main
     *     BLOCK Code LANG=PLCASM
     *         invalid_instruction
     *         exit
     *     END_BLOCK
     * END_PROGRAM
     * `)
     *
     * for (const problem of problems) {
     *     console.log(`${problem.type} at line ${problem.line}: ${problem.message}`)
     * }
     *
     * @example
     * // Lint for a device without timer support
     * const problems = runtime.lintProject(projectSource, { targetFlags: 0x0023 });
     */
    lintProject = (projectSource, options = {}) => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.project_compile) throw new Error("'project_compile' function not found - Project compiler not available")
        if (!this.wasm_exports.project_reset) throw new Error("'project_reset' function not found")
        if (!this.wasm_exports.project_hasError) throw new Error("'project_hasError' function not found")
        if (!this.wasm_exports.project_getProblemCount) throw new Error("'project_getProblemCount' function not found")
        if (!this.wasm_exports.project_getProblems) throw new Error("'project_getProblems' function not found")

        // Reset compiler state
        this.wasm_exports.project_reset()

        // Set or clear target flags based on options
        // If targetFlags provided explicitly, use them (API takes priority)
        // If not provided, clear API flag so FLAGS section in project can be used
        if (typeof options.targetFlags === 'number') {
            if (this.wasm_exports.project_setTargetFlags) {
                this.wasm_exports.project_setTargetFlags(options.targetFlags)
            }
        } else {
            // No explicit flags - clear API flag so FLAGS section or default (0xFFFF) is used
            if (this.wasm_exports.project_clearTargetFlags) {
                this.wasm_exports.project_clearTargetFlags()
            }
        }

        // Clear any stale data in the stream buffer first
        if (this.wasm_exports.streamClear) this.wasm_exports.streamClear()

        // Stream project source to compiler
        let ok = true
        for (let i = 0; i < projectSource.length && ok; i++) {
            ok = this.wasm_exports.streamIn(projectSource.charCodeAt(i))
        }
        if (!ok) {
            return [
                {
                    type: 'error',
                    message: 'Failed to stream project source - buffer overflow',
                    line: 0,
                    column: 0,
                    length: 0,
                    block: undefined,
                    lang: 0,
                },
            ]
        }
        this.wasm_exports.streamIn(0) // Null terminator

        // Compile the project (reads from stream buffer)
        const success = this.wasm_exports.project_compile(false)

        // Read all accumulated problems
        /** @type {ProjectLinterProblem[]} */
        const problems = this._readProjectProblems()

        // If compile failed but no problems recorded (e.g. fatal parser error not using addProblem), fallback to old error method
        if ((!success || this.wasm_exports.project_hasError()) && problems.length === 0) {
            const errorPtr = this.wasm_exports.project_getError ? this.wasm_exports.project_getError() : 0
            const errorLine = this.wasm_exports.project_getErrorLine ? this.wasm_exports.project_getErrorLine() : 0
            const errorColumn = this.wasm_exports.project_getErrorColumn ? this.wasm_exports.project_getErrorColumn() : 0
            const errorBlock = this.wasm_exports.project_getErrorBlock ? this.wasm_exports.project_getErrorBlock() : 0
            const errorCompiler = this.wasm_exports.project_getErrorCompiler ? this.wasm_exports.project_getErrorCompiler() : 0
            const errorToken = this.wasm_exports.project_getErrorToken ? this.wasm_exports.project_getErrorToken() : 0
            const errorTokenLength = this.wasm_exports.project_getErrorTokenLength ? this.wasm_exports.project_getErrorTokenLength() : 0
            const errorSourceLine = this.wasm_exports.project_getErrorSourceLine ? this.wasm_exports.project_getErrorSourceLine() : 0

            const memory = new Uint8Array(this.wasm_exports.memory.buffer)

            // Helper to read C string from memory
            const readString = (ptr = 0, maxLen = 512) => {
                if (!ptr) return ''
                let str = ''
                let i = ptr
                while (memory[i] !== 0 && i < memory.length && str.length < maxLen) {
                    str += String.fromCharCode(memory[i])
                    i++
                }
                return str
            }

            const message = readString(errorPtr) || 'Unknown compilation error'
            const block = readString(errorBlock, 64) || undefined
            const compiler = readString(errorCompiler, 64) || undefined

            let token = undefined
            if (errorToken) {
                if (errorTokenLength > 0) {
                    // errorToken is a buffer in C, so it is null terminated there likely, but we can use length if provided
                    // Actually project_getErrorToken returns pointer to char array error_token[64]
                    // So we can safely use readString(errorToken) as it is null terminated in C++
                    token = readString(errorToken, 128)
                } else {
                    token = readString(errorToken, 128)
                }
            }

            const sourceLine = readString(errorSourceLine, 256) || undefined

            problems.push({
                type: 'error',
                message,
                line: errorLine,
                column: errorColumn,
                length: errorTokenLength || (token ? token.length : 0),
                lang: 0,
                block,
                ...(compiler && {compiler}),
                ...(token && {token}),
                ...(sourceLine && {sourceLine}),
            })
        }

        return problems
    }

    /**
     * Lint only the project metadata sections (MEMORY, FLASH, FLAGS, TYPES, DATABLOCKS, SYMBOLS)
     * without parsing or compiling program blocks. Fast enough to call on every keystroke
     * when editing those sections.
     *
     * Returns an array of `ProjectLinterProblem` objects (same format as `lintProject`).
     * Each problem from a metadata section will have `block` set to the section name
     * (e.g. "DATABLOCKS", "SYMBOLS") so the front-end can display it correctly.
     *
     * @param {string} projectSource - The full project source text.
     * @returns {ProjectLinterProblem[]} Array of problems found in metadata sections.
     *
     * @example
     * // Call when the user edits DATABLOCKS or SYMBOLS
     * const problems = runtime.lintProjectMetadata(projectSource);
     * for (const p of problems) {
     *     console.log(`[${p.block}] ${p.type} at line ${p.line}: ${p.message}`);
     * }
     */
    lintProjectMetadata = (projectSource) => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.project_lintMetadata) throw new Error("'project_lintMetadata' function not found - update VovkPLC.wasm")
        if (!this.wasm_exports.project_getProblemCount) throw new Error("'project_getProblemCount' function not found")
        if (!this.wasm_exports.project_getProblems) throw new Error("'project_getProblems' function not found")

        // Clear any stale data in the stream buffer first
        if (this.wasm_exports.streamClear) this.wasm_exports.streamClear()

        // Stream project source
        let ok = true
        for (let i = 0; i < projectSource.length && ok; i++) {
            ok = this.wasm_exports.streamIn(projectSource.charCodeAt(i))
        }
        if (!ok) {
            return [{
                type: 'error',
                message: 'Failed to stream project source - buffer overflow',
                line: 0,
                column: 0,
                length: 0,
            }]
        }

        // Lint metadata sections only (no block compilation)
        this.wasm_exports.project_lintMetadata()

        // Read accumulated problems
        return this._readProjectProblems()
    }

    /**
     * Verifies size and CRC checksum during upload.
     *
     * @param {string | number[]} program - Bytecode as a hex string or array of bytes.
     * @returns {number} - 0 if success. Positive integer (1 or 2) indicates error code (size or checksum mismatch).
     * @throws {Error} If verification fails.
     */
    downloadBytecode = program => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.streamIn) throw new Error("'streamIn' function not found")
        if (!this.wasm_exports.downloadProgram) throw new Error("'downloadProgram' function not found")
        const code = Array.isArray(program) ? program : this.parseHex(program)
        const size = code.length
        const crc = this.crc8(code)

        // Clear any stale data in the stream buffer first
        if (this.wasm_exports.streamClear) this.wasm_exports.streamClear()

        for (let i = 0; i < size; i++) {
            const c = code[i]
            this.wasm_exports.streamIn(c)
        }
        const error = this.wasm_exports.downloadProgram(size, crc)
        if (error === 1) throw new Error('Failed to download program -> size mismatch')
        if (error === 2) throw new Error('Failed to download program -> checksum mismatch')
        return error
    }

    /**
     * Downloads pre-compiled bytecode to the PLC using direct hex string transfer.
     * This bypasses the stream system entirely - writes the hex string directly to
     * a WASM buffer and parses it in C++.
     *
     * @param {string | number[]} program - Bytecode as a hex string or array of bytes.
     * @returns {number} - 0 if success. 1=size error, 2=CRC mismatch, 3=invalid hex.
     * @throws {Error} If verification fails.
     */
    downloadBytecodeHex = program => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.downloadProgramHex) throw new Error("'downloadProgramHex' function not found")
        if (!this.wasm_exports.getHexDownloadBuffer) throw new Error("'getHexDownloadBuffer' function not found")

        // Convert to hex string if array
        let hex
        if (Array.isArray(program)) {
            hex = program.map(b => b.toString(16).padStart(2, '0')).join('')
        } else {
            hex = program.replace(/[\s,]/g, '') // Strip whitespace and commas
        }

        const byteCount = hex.length / 2
        if (byteCount !== Math.floor(byteCount)) throw new Error('Hex string must have even length')

        const crc = this.crc8(this.parseHex(hex))

        // Write hex string directly into WASM memory
        const bufPtr = this.wasm_exports.getHexDownloadBuffer()
        const bufSize = this.wasm_exports.getHexDownloadBufferSize
            ? this.wasm_exports.getHexDownloadBufferSize()
            : 129071
        if (hex.length + 1 > bufSize) throw new Error(`Hex string too large (${hex.length} chars, max ${bufSize - 1})`)

        const view = new Uint8Array(this.wasm_exports.memory.buffer, bufPtr, hex.length + 1)
        for (let i = 0; i < hex.length; i++) {
            view[i] = hex.charCodeAt(i)
        }
        view[hex.length] = 0 // Null terminator

        const error = this.wasm_exports.downloadProgramHex(bufPtr, byteCount, crc)
        if (error === 1) throw new Error('Failed to download program -> size error')
        if (error === 2) throw new Error('Failed to download program -> checksum mismatch')
        if (error === 3) throw new Error('Failed to download program -> invalid hex character')
        return error
    }

    /**
     * Executes the loaded program once (Single Scan).
     * This is the fast execution path without debug overhead.
     *
     * @returns {number} - Result code from execution.
     */
    run = () => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.run) throw new Error("'runFullProgram' function not found")
        // this.updateTime() // Update millis and micros
        return this.wasm_exports.run()
    }

    /**
     * Starts the main-thread runtime loop.
     * Executes the PLC run function repeatedly in a loop (burst mode to avoid blocking UI).
     * WARNING: This runs on the Main Thread. For high performance without blocking UI, use VovkPLC.createWorker().
     *
     * @param {number} [interval=10] - Interval in ms between bursts.
     * @returns {void}
     */
    startRuntime = (interval = 10) => {
        if (this.mainLoopActive) return
        this.mainLoopActive = true

        const loop = () => {
            if (!this.mainLoopActive) return

            // Execute a burst of cycles (optimized)
            const start = performance.now()
            // Try to run for 8ms max to leave breathing room for UI
            while (performance.now() - start < 8) {
                if (this.wasm_exports) this.wasm_exports.run()
                else break
            }

            // Schedule next burst
            if (this.mainLoopActive) {
                setTimeout(loop, interval)
            }
        }
        loop()
    }

    /**
     * Stops the main-thread runtime loop.
     */
    stopRuntime = () => {
        this.mainLoopActive = false
    }

    /**
     * Sets the system millisecond counter.
     * Useful for testing timer-based logic with deterministic time values.
     * Pass null or undefined to revert to real-time (performance.now()).
     *
     * @param {number | null} millis - The millisecond value to set, or null to use real-time.
     */
    setMillis = millis => {
        this._millisOverride = (millis != null) ? Math.round(millis) : null
    }

    /**
     * Sets the system microsecond counter.
     * Useful for testing timer-based logic with deterministic time values.
     * Pass null or undefined to revert to real-time (performance.now() * 1000).
     *
     * @param {number | null} micros - The microsecond value to set, or null to use real-time.
     */
    setMicros = micros => {
        this._microsOverride = (micros != null) ? Math.round(micros) : null
    }

    /**
     * Gets the current system millisecond counter value.
     *
     * @returns {number} - The current millisecond counter value.
     */
    getMillis = () => {
        if (this._millisOverride !== null) return this._millisOverride
        return Math.round(this.perf.now())
    }

    /**
     * Gets the current system microsecond counter value.
     *
     * @returns {number} - The current microsecond counter value.
     */
    getMicros = () => {
        if (this._microsOverride !== null) return this._microsOverride
        return Math.round(this.perf.now() * 1000)
    }

    /**
     * Executes the loaded program once in DEBUG mode.
     * Prints execution trace and stack state to stdout.
     * Use this for step-by-step debugging or detailed analysis.
     *
     * @returns {void}
     */
    runDebug = () => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.runFullProgramDebug) throw new Error("'runFullProgramDebug' function not found")
        // this.updateTime() // Update millis and micros
        return this.wasm_exports.runFullProgramDebug()
    }

    /**
     * Extracts the currently loaded bytecode from the PLC memory.
     * Useful for verifying compilation or saving the binary.
     *
     * @returns {{size: number, output: string}} - Object containing program size and the raw byte string (if streamed).
     */
    extractProgram = () => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.uploadProgram) throw new Error("'uploadProgram' function not found")
        this.flushOutBuffer() // Clear any previous output
        const size = +this.wasm_exports.uploadProgram()
        const output = this.readOutBuffer()
        return {size, output}
    }

    /**
     * Reads a chunk of memory from the PLC's RAM.
     * Starts reading from the global memory offset defined by the runtime.
     *
     * @param {number} address - Relative address within the PLC memory area.
     * @param {number} [size=1] - Number of bytes to read.
     * @returns {Uint8Array} - Buffer containing the read bytes.
     */
    readMemoryArea = (address, size = 1) => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        // const { getMemoryArea } = this.wasm_exports
        // if (!getMemoryArea) throw new Error("'getMemoryArea' function not found")
        // getMemoryArea(address, size)
        // const output = this.readStream()
        // const { memory, getMemoryLocation } = this.wasm_exports
        if (!this.wasm_exports.memory) throw new Error('WebAssembly memory not found')
        if (!this.wasm_exports.getMemoryLocation) throw new Error("'getMemoryLocation' function not found")
        const offset = this.wasm_exports.getMemoryLocation()
        const buffer = new Uint8Array(this.wasm_exports.memory.buffer, offset + address, size)
        return buffer
    }

    /**
     * Writes a single byte to memory.
     * @param {number} address - Address to write to
     * @param {number} byte - Byte value
     * @returns {number} 1 on success
     */
    writeMemoryByte = (address, byte) => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.writeMemoryByte) throw new Error("'writeMemoryByte' function not found")
        if (address < MEMORY_LAYOUT.SYSTEM_SIZE) {
            throw new Error(`Cannot write to System partition (address ${address} < ${MEMORY_LAYOUT.SYSTEM_SIZE}). Use X/Y/M addresses instead.`)
        }
        return this.wasm_exports.writeMemoryByte(address, byte)
    }

    /**
     * Writes data to the PLC's RAM.
     *
     * @param {number} address - Relative address to start writing to.
     * @param {number[]} data - Array of bytes to write.
     * @returns {string} - Any output generated by the write operation (usually empty).
     * @throws {Error} If write fails.
     */
    writeMemoryArea = (address, data) => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.memory) throw new Error('WebAssembly memory not found')
        if (!this.wasm_exports.getMemoryLocation) throw new Error("'getMemoryLocation' function not found")
        if (address < MEMORY_LAYOUT.SYSTEM_SIZE) {
            throw new Error(`Cannot write to System partition (address ${address} < ${MEMORY_LAYOUT.SYSTEM_SIZE}). Use X/Y/M addresses instead.`)
        }
        if (address + data.length <= MEMORY_LAYOUT.SYSTEM_SIZE) {
            throw new Error(`Cannot write to System partition (range ${address}-${address + data.length - 1} overlaps system memory). Use X/Y/M addresses instead.`)
        }
        const offset = this.wasm_exports.getMemoryLocation()
        const buffer = new Uint8Array(this.wasm_exports.memory.buffer, offset + address, data.length)
        for (let i = 0; i < data.length; i++) buffer[i] = data[i] & 0xff
        const output = this.readStream()
        return output
    }

    /**
     * Writes data to the PLC's RAM with a bitmask.
     * Only bits set in the mask are modified in the target memory.
     *
     * @param {number} address - Relative address.
     * @param {number[]} data - Bytes to write.
     * @param {number[]} mask - Bitmask for each byte (1=write, 0=keep original).
     * @returns {string} - Output logs.
     */
    writeMemoryAreaMasked = (address, data, mask) => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.memory) throw new Error('WebAssembly memory not found')
        if (!this.wasm_exports.getMemoryLocation) throw new Error("'getMemoryLocation' function not found")
        if (data.length !== mask.length) throw new Error('Mask length must match data length')
        if (address < MEMORY_LAYOUT.SYSTEM_SIZE) {
            throw new Error(`Cannot write to System partition (address ${address} < ${MEMORY_LAYOUT.SYSTEM_SIZE}). Use X/Y/M addresses instead.`)
        }
        if (address + data.length <= MEMORY_LAYOUT.SYSTEM_SIZE) {
            throw new Error(`Cannot write to System partition (range ${address}-${address + data.length - 1} overlaps system memory). Use X/Y/M addresses instead.`)
        }
        const offset = this.wasm_exports.getMemoryLocation()
        const buffer = new Uint8Array(this.wasm_exports.memory.buffer, offset + address, data.length)
        for (let i = 0; i < data.length; i++) {
            const maskByte = mask[i] & 0xff
            buffer[i] = (buffer[i] & ~maskByte) | (data[i] & maskByte)
        }
        const output = this.readStream()
        return output
    }

    /**
     * Returns the raw WebAssembly exports object.
     * Use this to access low-level WASM functions directly.
     *
     * @returns {VovkPLCExportTypes} - The exports object.
     */
    getExports = () => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        return this.wasm_exports
    }

    // ========================================================================
    // DataBlock Methods
    // ========================================================================

    /**
     * @typedef {{
     *     db_number: number,
     *     alias: string,
     *     totalSize: number,
     *     computedOffset: number,
     *     fields: DataBlockFieldInfo[]
     * }} DataBlockDeclInfo
     */

    /**
     * @typedef {{
     *     name: string,
     *     typeName: string,
     *     typeSize: number,
     *     offset: number,
     *     hasDefault: boolean,
     *     defaultValue: number
     * }} DataBlockFieldInfo
     */

    /**
     * @typedef {{
     *     slot: number,
     *     db_number: number,
     *     offset: number,
     *     size: number
     * }} DataBlockEntry
     */

    /**
     * Returns the number of DB slots available in the runtime.
     * @returns {number}
     */
    dbGetSlotCount = () => {
        if (!this.wasm_exports?.db_getSlotCount) throw new Error('db_getSlotCount not available')
        return this.wasm_exports.db_getSlotCount()
    }

    /**
     * Returns the start address of the DB lookup table in memory.
     * @returns {number}
     */
    dbGetTableOffset = () => {
        if (!this.wasm_exports?.db_getTableOffset) throw new Error('db_getTableOffset not available')
        return this.wasm_exports.db_getTableOffset()
    }

    /**
     * Returns the number of active (allocated) DataBlocks.
     * @returns {number}
     */
    dbGetActiveCount = () => {
        if (!this.wasm_exports?.db_getActiveCount) throw new Error('db_getActiveCount not available')
        return this.wasm_exports.db_getActiveCount()
    }

    /**
     * Returns free memory bytes between the user area end and the lowest DB data.
     * @returns {number}
     */
    dbGetFreeSpace = () => {
        if (!this.wasm_exports?.db_getFreeSpace) throw new Error('db_getFreeSpace not available')
        return this.wasm_exports.db_getFreeSpace()
    }

    /**
     * Returns the lowest allocated DB data address (watermark).
     * @returns {number}
     */
    dbGetLowestAddress = () => {
        if (!this.wasm_exports?.db_getLowestAddress) throw new Error('db_getLowestAddress not available')
        return this.wasm_exports.db_getLowestAddress()
    }

    /**
     * Returns total bytes used by all active DataBlocks.
     * @returns {number}
     */
    dbGetTotalDataUsed = () => {
        if (!this.wasm_exports?.db_getTotalDataUsed) throw new Error('db_getTotalDataUsed not available')
        return this.wasm_exports.db_getTotalDataUsed()
    }

    /**
     * Gets information about a DB slot by its slot index.
     * @param {number} slot - Slot index (0-based).
     * @returns {DataBlockEntry} - Entry info (db_number=0 means unused).
     */
    dbGetEntry = (slot) => {
        if (!this.wasm_exports?.db_getEntryDB) throw new Error('db_getEntryDB not available')
        return {
            slot,
            db_number: this.wasm_exports.db_getEntryDB(slot),
            offset: this.wasm_exports.db_getEntryOffset(slot),
            size: this.wasm_exports.db_getEntrySize(slot),
        }
    }

    /**
     * Returns all active DB entries.
     * @returns {DataBlockEntry[]}
     */
    dbGetActiveEntries = () => {
        const count = this.dbGetSlotCount()
        const entries = []
        for (let i = 0; i < count; i++) {
            const entry = this.dbGetEntry(i)
            if (entry.db_number !== 0) entries.push(entry)
        }
        return entries
    }

    /**
     * Declares a new DataBlock in the runtime.
     * Allocates memory for the DB and adds it to the lookup table.
     *
     * @param {number} dbNumber - The DB number (1-based).
     * @param {number} size - Size in bytes to allocate.
     * @returns {number} - Slot index on success, -1 on failure.
     */
    dbDeclare = (dbNumber, size) => {
        if (!this.wasm_exports?.db_declare) throw new Error('db_declare not available')
        return this.wasm_exports.db_declare(dbNumber, size)
    }

    /**
     * Removes a DataBlock from the runtime by DB number.
     *
     * @param {number} dbNumber - The DB number to remove.
     * @returns {boolean} - True on success.
     */
    dbRemove = (dbNumber) => {
        if (!this.wasm_exports?.db_remove) throw new Error('db_remove not available')
        return this.wasm_exports.db_remove(dbNumber) === 1
    }

    /**
     * Migrates a DataBlock to a new absolute memory offset.
     *
     * @param {number} dbNumber - The DB number to migrate.
     * @param {number} targetOffset - New absolute memory address.
     * @returns {boolean} - True on success.
     */
    dbMigrate = (dbNumber, targetOffset) => {
        if (!this.wasm_exports?.db_migrate) throw new Error('db_migrate not available')
        return this.wasm_exports.db_migrate(dbNumber, targetOffset) === 1
    }

    /**
     * Compacts all DataBlocks, packing them tightly against the lookup table.
     *
     * @returns {number} - New lowest allocated address.
     */
    dbCompact = () => {
        if (!this.wasm_exports?.db_compact) throw new Error('db_compact not available')
        return this.wasm_exports.db_compact()
    }

    /**
     * Resolves a DB-relative address to an absolute memory address.
     *
     * @param {number} dbNumber - The DB number.
     * @param {number} dbOffset - Byte offset within the DB.
     * @returns {number} - Absolute address, or 0xFFFF on error.
     */
    dbResolveAddress = (dbNumber, dbOffset) => {
        if (!this.wasm_exports?.db_resolveAddress) throw new Error('db_resolveAddress not available')
        return this.wasm_exports.db_resolveAddress(dbNumber, dbOffset)
    }

    /**
     * Clears all DataBlock entries (formats the DB table).
     */
    dbFormat = () => {
        if (!this.wasm_exports?.db_format) throw new Error('db_format not available')
        this.wasm_exports.db_format()
    }

    /**
     * Re-initializes the DB manager with a new slot count.
     * Must be called before any dbDeclare calls.
     *
     * @param {number} count - Number of DB slots (1-256).
     */
    dbSetSlotCount = (count) => {
        if (!this.wasm_exports?.db_setSlotCount) throw new Error('db_setSlotCount not available')
        this.wasm_exports.db_setSlotCount(count)
    }

    /**
     * Reads a typed value from a DataBlock.
     * Resolves the DB-relative address and reads from WASM memory using the correct endianness.
     *
     * @param {number} dbNumber - The DB number.
     * @param {number} dbOffset - Byte offset within the DB.
     * @param {'u8' | 'i8' | 'u16' | 'i16' | 'u32' | 'i32' | 'f32' | 'f64'} type - Data type.
     * @returns {number} - The value read.
     * @throws {Error} If the DB or offset is invalid.
     */
    dbRead = (dbNumber, dbOffset, type = 'u8') => {
        if (!this.wasm_exports?.db_resolveAddress) throw new Error('db_resolveAddress not available')
        if (!this.wasm_exports?.memory) throw new Error('WASM memory not available')
        if (!this.wasm_exports?.getMemoryLocation) throw new Error('getMemoryLocation not available')
        const absAddr = this.wasm_exports.db_resolveAddress(dbNumber, dbOffset)
        if (absAddr === 0xFFFF) throw new Error(`Invalid DB${dbNumber} offset ${dbOffset}`)
        const memBase = this.wasm_exports.getMemoryLocation()
        const view = new DataView(this.wasm_exports.memory.buffer)
        const addr = memBase + absAddr
        const le = this.isLittleEndian
        switch (type) {
            case 'u8':  return view.getUint8(addr)
            case 'i8':  return view.getInt8(addr)
            case 'u16': return view.getUint16(addr, le)
            case 'i16': return view.getInt16(addr, le)
            case 'u32': return view.getUint32(addr, le)
            case 'i32': return view.getInt32(addr, le)
            case 'f32': return view.getFloat32(addr, le)
            case 'f64': return view.getFloat64(addr, le)
            default: throw new Error(`Unknown type: ${type}`)
        }
    }

    /**
     * Writes a typed value to a DataBlock.
     * Resolves the DB-relative address and writes to WASM memory using the correct endianness.
     *
     * @param {number} dbNumber - The DB number.
     * @param {number} dbOffset - Byte offset within the DB.
     * @param {number} value - The value to write.
     * @param {'u8' | 'i8' | 'u16' | 'i16' | 'u32' | 'i32' | 'f32' | 'f64'} type - Data type.
     * @throws {Error} If the DB or offset is invalid.
     */
    dbWrite = (dbNumber, dbOffset, value, type = 'u8') => {
        if (!this.wasm_exports?.db_resolveAddress) throw new Error('db_resolveAddress not available')
        if (!this.wasm_exports?.memory) throw new Error('WASM memory not available')
        if (!this.wasm_exports?.getMemoryLocation) throw new Error('getMemoryLocation not available')
        const absAddr = this.wasm_exports.db_resolveAddress(dbNumber, dbOffset)
        if (absAddr === 0xFFFF) throw new Error(`Invalid DB${dbNumber} offset ${dbOffset}`)
        const memBase = this.wasm_exports.getMemoryLocation()
        const view = new DataView(this.wasm_exports.memory.buffer)
        const addr = memBase + absAddr
        const le = this.isLittleEndian
        switch (type) {
            case 'u8':  view.setUint8(addr, value); break
            case 'i8':  view.setInt8(addr, value); break
            case 'u16': view.setUint16(addr, value, le); break
            case 'i16': view.setInt16(addr, value, le); break
            case 'u32': view.setUint32(addr, value, le); break
            case 'i32': view.setInt32(addr, value, le); break
            case 'f32': view.setFloat32(addr, value, le); break
            case 'f64': view.setFloat64(addr, value, le); break
            default: throw new Error(`Unknown type: ${type}`)
        }
    }

    /**
     * Reads an entire DataBlock's raw data as a Uint8Array.
     *
     * @param {number} dbNumber - The DB number.
     * @returns {{ data: Uint8Array, offset: number, size: number }} - The raw bytes, absolute offset, and size.
     * @throws {Error} If the DB is not found.
     */
    dbReadAll = (dbNumber) => {
        if (!this.wasm_exports?.memory) throw new Error('WASM memory not available')
        if (!this.wasm_exports?.getMemoryLocation) throw new Error('getMemoryLocation not available')
        // Find the entry
        const count = this.dbGetSlotCount()
        for (let i = 0; i < count; i++) {
            const entry = this.dbGetEntry(i)
            if (entry.db_number === dbNumber) {
                const memBase = this.wasm_exports.getMemoryLocation()
                const data = new Uint8Array(this.wasm_exports.memory.buffer, memBase + entry.offset, entry.size)
                return { data: new Uint8Array(data), offset: entry.offset, size: entry.size }
            }
        }
        throw new Error(`DB${dbNumber} not found`)
    }

    /**
     * Returns the number of DB declarations from the last compilation.
     * These declarations contain field metadata (names, types, offsets).
     *
     * @returns {number}
     */
    dbGetDeclCount = () => {
        if (!this.wasm_exports?.db_getDeclCount) throw new Error('db_getDeclCount not available')
        return this.wasm_exports.db_getDeclCount()
    }

    /**
     * Returns full declaration info for a compiler-declared DataBlock by index.
     * Includes field names, types, offsets, and default values.
     *
     * @param {number} index - Declaration index (0-based, up to dbGetDeclCount()-1).
     * @returns {DataBlockDeclInfo}
     */
    dbGetDecl = (index) => {
        if (!this.wasm_exports?.db_getDeclDBNumber) throw new Error('db_getDeclDBNumber not available')
        const db_number = this.wasm_exports.db_getDeclDBNumber(index)
        const aliasPtr = this.wasm_exports.db_getDeclAlias(index)
        const alias = aliasPtr ? this.readCString(aliasPtr) : ''
        const fieldCount = this.wasm_exports.db_getDeclFieldCount(index)
        const totalSize = this.wasm_exports.db_getDeclTotalSize(index)
        const computedOffset = this.wasm_exports.db_getDeclComputedOffset(index)
        const fields = []
        for (let f = 0; f < fieldCount; f++) {
            const namePtr = this.wasm_exports.db_getDeclFieldName(index, f)
            const typeNamePtr = this.wasm_exports.db_getDeclFieldTypeName(index, f)
            const typeSize = this.wasm_exports.db_getDeclFieldTypeSize(index, f)
            const offset = this.wasm_exports.db_getDeclFieldOffset(index, f)
            const hasDefault = this.wasm_exports.db_getDeclFieldHasDefault(index, f) === 1
            const isFloat = typeNamePtr ? this.readCString(typeNamePtr) === 'f32' : false
            const defaultValue = hasDefault
                ? (isFloat ? this.wasm_exports.db_getDeclFieldDefaultFloat(index, f) : this.wasm_exports.db_getDeclFieldDefaultInt(index, f))
                : 0
            fields.push({
                name: namePtr ? this.readCString(namePtr) : '',
                typeName: typeNamePtr ? this.readCString(typeNamePtr) : '',
                typeSize,
                offset,
                hasDefault,
                defaultValue,
            })
        }
        return { db_number, alias, totalSize, computedOffset, fields }
    }

    /**
     * Returns all compiler-declared DataBlock definitions.
     * Available after compilation of a project with DATABLOCKS section.
     *
     * @returns {DataBlockDeclInfo[]}
     */
    dbGetAllDecls = () => {
        const count = this.dbGetDeclCount()
        const decls = []
        for (let i = 0; i < count; i++) {
            decls.push(this.dbGetDecl(i))
        }
        return decls
    }

    /**
     * Reads a named field from a DataBlock using compiler metadata.
     * Looks up the field by name in the compiler's declaration registry,
     * then reads the value using the correct type and offset.
     *
     * @param {number} dbNumber - The DB number.
     * @param {string} fieldName - The field name (e.g., "speed", "position").
     * @returns {number} - The field value.
     * @throws {Error} If the DB or field is not found.
     *
     * @example
     * const speed = plc.dbReadField(1, 'speed');
     * const position = plc.dbReadField(1, 'position');
     */
    dbReadField = (dbNumber, fieldName) => {
        const decl = this._findDBDecl(dbNumber)
        const field = decl.fields.find(f => f.name === fieldName)
        if (!field) throw new Error(`Field '${fieldName}' not found in DB${dbNumber}`)
        return this.dbRead(dbNumber, field.offset, /** @type {any} */ (field.typeName))
    }

    /**
     * Writes a named field to a DataBlock using compiler metadata.
     * Looks up the field by name in the compiler's declaration registry,
     * then writes the value using the correct type and offset.
     *
     * @param {number} dbNumber - The DB number.
     * @param {string} fieldName - The field name (e.g., "speed", "position").
     * @param {number} value - The value to write.
     * @throws {Error} If the DB or field is not found.
     *
     * @example
     * plc.dbWriteField(1, 'speed', 1500);
     * plc.dbWriteField(1, 'position', 3.14);
     */
    dbWriteField = (dbNumber, fieldName, value) => {
        const decl = this._findDBDecl(dbNumber)
        const field = decl.fields.find(f => f.name === fieldName)
        if (!field) throw new Error(`Field '${fieldName}' not found in DB${dbNumber}`)
        this.dbWrite(dbNumber, field.offset, value, /** @type {any} */ (field.typeName))
    }

    /**
     * Reads all fields of a DataBlock as a key-value object.
     * Uses compiler metadata to resolve field names and types.
     *
     * @param {number} dbNumber - The DB number.
     * @returns {Record<string, number>} - Object mapping field names to their current values.
     *
     * @example
     * const motor = plc.dbReadFields(1);
     * // { speed: 1500, position: 3.14, status: 1 }
     */
    dbReadFields = (dbNumber) => {
        const decl = this._findDBDecl(dbNumber)
        /** @type {Record<string, number>} */
        const result = {}
        for (const field of decl.fields) {
            result[field.name] = this.dbRead(dbNumber, field.offset, /** @type {any} */ (field.typeName))
        }
        return result
    }

    /**
     * Writes multiple fields to a DataBlock from a key-value object.
     * Only writes fields present in the provided object.
     *
     * @param {number} dbNumber - The DB number.
     * @param {Record<string, number>} values - Object mapping field names to values.
     *
     * @example
     * plc.dbWriteFields(1, { speed: 1500, status: 1 });
     */
    dbWriteFields = (dbNumber, values) => {
        const decl = this._findDBDecl(dbNumber)
        for (const [name, value] of Object.entries(values)) {
            const field = decl.fields.find(f => f.name === name)
            if (!field) throw new Error(`Field '${name}' not found in DB${dbNumber}`)
            this.dbWrite(dbNumber, field.offset, value, /** @type {any} */ (field.typeName))
        }
    }

    /**
     * Finds a DB declaration by DB number from compiler metadata.
     * @private
     * @param {number} dbNumber
     * @returns {DataBlockDeclInfo}
     */
    _findDBDecl = (dbNumber) => {
        const count = this.dbGetDeclCount()
        for (let i = 0; i < count; i++) {
            const decl = this.dbGetDecl(i)
            if (decl.db_number === dbNumber) return decl
        }
        throw new Error(`DB${dbNumber} declaration not found (was the project compiled with DATABLOCKS?)`)
    }

    // ========================================================================
    // FFI (Foreign Function Interface) Methods
    // ========================================================================

    /** Type sizes for FFI parameter marshalling */
    static FFI_TYPE_SIZES = [0, 1, 1, 1, 2, 2, 4, 4, 8, 8, 4, 8]

    /**
     * Internal handler for FFI calls from WASM to JS.
     * Called via the js_ffi_invoke import when runtime executes a JS-registered FFI.
     * @private
     */
    _ffiInvoke = (ffi_index, param_types_ptr, param_addrs_ptr, param_count, ret_addr, ret_type) => {
        const callback = this.ffiCallbacks.get(ffi_index)
        if (!callback) {
            console.error(`FFI callback not found for index ${ffi_index}`)
            return 1 // Error
        }

        if (!this.wasm_exports || !this.wasm_exports.memory) {
            console.error('WASM not initialized for FFI call')
            return 1
        }

        const memory = this.wasm_exports.memory
        const memOffset = this.wasm_exports.getMemoryLocation ? this.wasm_exports.getMemoryLocation() : 0
        const view = new DataView(memory.buffer)

        // Read parameter types from WASM memory
        const paramTypes = new Uint8Array(memory.buffer, param_types_ptr, param_count)
        
        // Read parameter addresses manually using DataView to avoid alignment issues
        const paramAddrs = []
        for (let i = 0; i < param_count; i++) {
            paramAddrs.push(view.getUint16(param_addrs_ptr + i * 2, true)) // little endian
        }

        // Read parameter values from PLC memory
        const params = []
        for (let i = 0; i < param_count; i++) {
            const typeCode = paramTypes[i]
            const addr = memOffset + paramAddrs[i]
            const val = this._ffiReadValue(view, addr, typeCode)
            params.push(val)
        }

        // Call the JS function
        try {
            const result = callback.fn(...params)

            // Write return value if not void
            if (ret_type !== 0 && result !== undefined) {
                const absRetAddr = memOffset + ret_addr
                this._ffiWriteValue(view, absRetAddr, ret_type, result)
            }
            return 0 // Success
        } catch (e) {
            console.error(`FFI callback error: ${e.message}`)
            return 1 // Error
        }
    }

    /**
     * Read a value from WASM memory based on type code.
     * @private
     */
    _ffiReadValue = (view, addr, typeCode) => {
        const le = this.isLittleEndian
        switch (typeCode) {
            case 0: return undefined // void
            case 1: return view.getUint8(addr) !== 0 // bool
            case 2: return view.getUint8(addr) // u8
            case 3: return view.getInt8(addr) // i8
            case 4: return view.getUint16(addr, le) // u16
            case 5: return view.getInt16(addr, le) // i16
            case 6: return view.getUint32(addr, le) // u32
            case 7: return view.getInt32(addr, le) // i32
            case 8: return view.getBigUint64(addr, le) // u64
            case 9: return view.getBigInt64(addr, le) // i64
            case 10: return view.getFloat32(addr, le) // f32
            case 11: return view.getFloat64(addr, le) // f64
            default: return 0
        }
    }

    /**
     * Write a value to WASM memory based on type code.
     * @private
     */
    _ffiWriteValue = (view, addr, typeCode, value) => {
        if (addr < MEMORY_LAYOUT.SYSTEM_SIZE && typeCode !== 0) {
            throw new Error(`FFI cannot write to System partition (address ${addr} < ${MEMORY_LAYOUT.SYSTEM_SIZE}). Use X/Y/M addresses instead.`)
        }
        const le = this.isLittleEndian
        switch (typeCode) {
            case 0: break // void
            case 1: view.setUint8(addr, value ? 1 : 0); break // bool
            case 2: view.setUint8(addr, value); break // u8
            case 3: view.setInt8(addr, value); break // i8
            case 4: view.setUint16(addr, value, le); break // u16
            case 5: view.setInt16(addr, value, le); break // i16
            case 6: view.setUint32(addr, value, le); break // u32
            case 7: view.setInt32(addr, value, le); break // i32
            case 8: view.setBigUint64(addr, BigInt(value), le); break // u64
            case 9: view.setBigInt64(addr, BigInt(value), le); break // i64
            case 10: view.setFloat32(addr, value, le); break // f32
            case 11: view.setFloat64(addr, value, le); break // f64
        }
    }

    /**
     * Register a JavaScript function as an FFI handler.
     * The function will be callable from PLC programs via the FFI instruction.
     *
     * @param {string} name - The FFI function name (e.g., "F_my_function")
     * @param {string} signature - Type signature (e.g., "i32,i32->i32")
     * @param {string} description - Human-readable description
     * @param {Function} fn - The JavaScript function to call
     * @returns {number} - The FFI index on success, -1 on failure
     */
    registerFFI = (name, signature, description, fn) => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.ffi_registerJS) throw new Error("'ffi_registerJS' export not found")
        if (!this.wasm_exports.ffi_getStringBuffer) throw new Error("'ffi_getStringBuffer' export not found")

        // Write strings to static buffers (no allocation needed)
        const namePtr = this._writeToStringBuffer(0, name)
        const sigPtr = this._writeToStringBuffer(1, signature)
        const descPtr = this._writeToStringBuffer(2, description)

        // Register with WASM
        const index = this.wasm_exports.ffi_registerJS(namePtr, sigPtr, descPtr)

        if (index >= 0) {
            this.ffiCallbacks.set(index, { name, signature, fn })
        }

        return index
    }

    /**
     * Unregister a JS FFI function by index.
     * @param {number} index - The FFI index
     * @returns {boolean} - True if unregistered successfully
     */
    unregisterFFI = (index) => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.ffi_unregister) throw new Error("'ffi_unregister' export not found")

        const result = this.wasm_exports.ffi_unregister(index)
        if (result) {
            this.ffiCallbacks.delete(index)
        }
        return result !== 0
    }

    /**
     * Get the number of registered FFI functions.
     * @returns {number}
     */
    getFFICount = () => {
        if (!this.wasm_exports || !this.wasm_exports.ffi_getCount) return 0
        return this.wasm_exports.ffi_getCount()
    }

    /**
     * Clear all FFI registrations (both C++ and JS).
     */
    clearFFI = () => {
        if (!this.wasm_exports) return
        if (this.wasm_exports.ffi_clear) this.wasm_exports.ffi_clear()
        this.ffiCallbacks.clear()
    }

    /**
     * Write a string to a static WASM buffer (no allocation).
     * @private
     * @param {number} bufferIndex - Buffer index (0-3)
     * @param {string} str - String to write
     * @returns {number} - Pointer to the buffer
     */
    _writeToStringBuffer = (bufferIndex, str) => {
        if (!this.wasm_exports || !this.wasm_exports.ffi_getStringBuffer) {
            throw new Error('ffi_getStringBuffer export not found')
        }
        const ptr = this.wasm_exports.ffi_getStringBuffer(bufferIndex)
        if (ptr === 0) throw new Error(`Invalid string buffer index ${bufferIndex}`)
        
        const maxLen = this.wasm_exports.ffi_getStringBufferSize ? 
            this.wasm_exports.ffi_getStringBufferSize() : 128
        const writeLen = Math.min(str.length, maxLen - 1)
        
        const view = new Uint8Array(this.wasm_exports.memory.buffer, ptr, maxLen)
        for (let i = 0; i < writeLen; i++) {
            view[i] = str.charCodeAt(i)
        }
        view[writeLen] = 0 // Null terminator
        return ptr
    }

    // ========================================================================
    // Console/Stream Methods
    // ========================================================================

    /**
     * Calls a specific WebAssembly export by name with arguments.
     *
     * @param {string} name - The name of the exported function.
     * @param {...any} args - Arguments to pass to the function.
     * @returns {any} - The result of the function call.
     * @throws {Error} If export is missing or not a function.
     */
    callExport = (name, ...args) => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized') // @ts-ignore
        const fn = this.wasm_exports[name]
        if (typeof fn !== 'function') throw new Error(`'${name}' export not found`)
        return fn(...args)
    }

    /** @type { (charcode: number) => void } */
    console_print = c => {
        const char = String.fromCharCode(c)
        if (char === '\n') {
            const callback = this.stdout_callback || console.log
            if (this.console_message && this.console_message.length > 0 && !this.silent) callback(this.console_message)
            this.console_message = ''
        } else {
            this.console_message += char
        }
    }

    /** @type { (charcode: number | number[] | string) => void } */
    console_error = charcode => {
        if (typeof charcode === 'string') {
            if (charcode.length === 0) return
            if (charcode.length === 1) return this.console_error(charcode.charCodeAt(0))
            return charcode.split('').forEach(this.console_error)
        }
        if (Array.isArray(charcode)) return charcode.forEach(this.console_error)
        const char = String.fromCharCode(charcode)
        if (char === '\0' || char === '\n') {
            // console.error(this.error_message)
            const callback = this.stderr_callback || console.error
            callback(this.error_message)
            this.error_message = ''
        } else this.error_message += char
    }

    /** @param { (message: string) => void } callback */
    onStdout = callback => {
        this.stdout_callback = callback
    }
    /** @param { (message: string) => void } callback */
    onStderr = callback => {
        this.stderr_callback = callback
    }

    /** @type { (charcode: number | number[] | string) => void } */
    console_stream = charcode => {
        if (typeof charcode === 'string') {
            if (charcode.length === 0) return
            if (charcode.length === 1) return this.console_stream(charcode.charCodeAt(0))
            return charcode.split('').forEach(this.console_stream)
        }
        if (Array.isArray(charcode)) return charcode.forEach(this.console_stream)
        const char = String.fromCharCode(charcode)
        this.stream_message += char
        if (this.stream_message.length > 100000) this.stream_message = this.stream_message.substring(this.stream_message.length - 100000 + 1)
    }

    readStream = () => {
        const output = this.stream_message
        this.stream_message = ''
        return output
    }

    /**
     * Reads from the WASM output buffer (__wasm_stream_out__).
     * This is the NEW buffer-based output mechanism used by functions like
     * stl_output_to_stream() and ladder_graph_output_to_stream().
     * 
     * @param {boolean} [flush=true] - If true, clears the buffer after reading.
     * @returns {string} - The content of the output buffer as a string.
     */
    readOutBuffer = (flush = true) => {
        if (!this.wasm_exports || !this.wasm_exports.get_out_buffer_ptr || !this.wasm_exports.get_out_index) {
            // Fallback to readStream if buffer exports not available
            return this.readStream()
        }
        const ptr = this.wasm_exports.get_out_buffer_ptr()
        const len = this.wasm_exports.get_out_index()
        if (len <= 0) return ''
        const mem = new Uint8Array(this.wasm_exports.memory.buffer)
        let result = ''
        for (let i = 0; i < len; i++) {
            result += String.fromCharCode(mem[ptr + i])
        }
        if (flush && this.wasm_exports.flush_out_buffer) {
            this.wasm_exports.flush_out_buffer()
        }
        return result
    }

    /**
     * Clears the WASM output buffer.
     */
    flushOutBuffer = () => {
        if (this.wasm_exports && this.wasm_exports.flush_out_buffer) {
            this.wasm_exports.flush_out_buffer()
        }
    }

    /** @param { number | number[] } data * @param { number } [crc] */
    crc8 = (data, crc = 0) => {
        if (!this.crc8_table_loaded) {
            this.crc8_table_loaded = true
            for (let i = 0; i < 256; i++) {
                let crc8 = i
                for (let j = 0; j < 8; j++) crc8 = crc8 & 0x80 ? (crc8 << 1) ^ 0x31 : crc8 << 1
                this.crc8_table[i] = crc8 & 0xff
            }
        }
        data = Array.isArray(data) ? data : [data]
        const size = data.length
        for (let i = 0; i < size; i++) if (!(data[i] >= 0 && data[i] <= 255)) throw new Error(`Invalid data byte at index ${i}: ${data[i]}`)
        for (let i = 0; i < size; i++) {
            /** @type { number } */
            let index = (crc ^ data[i]) & 0xff
            crc = this.crc8_table[index] & 0xff
        }
        return crc
    }

    /** @param { string } hex_string * @returns { number[] } */
    parseHex = hex_string => {
        // Parse 02x formatted HEX string
        if (typeof hex_string !== 'string') throw new Error(`Invalid HEX string: ${hex_string}`)
        hex_string = hex_string.replace(/[^0-9a-fA-F]/g, '')
        if (hex_string.length % 2 !== 0) throw new Error(`Invalid HEX string length: ${hex_string.length}`)
        const hex_array = hex_string.match(/.{1,2}/g)
        if (!hex_array) throw new Error(`Invalid HEX string: ${hex_string}`)
        const num_array = []
        for (let i = 0; i < hex_array.length; i++) {
            const num = parseInt(hex_array[i], 16)
            if (num < 0 || num > 255) throw new Error(`Invalid HEX string byte at index ${i}: ${hex_array[i]}`)
            num_array.push(num)
        }
        return num_array
    }
    /** @param { string } str * @returns { string } */
    stringToHex = str =>
        str
            .split('')
            .map(c => c.charCodeAt(0).toString(16).padStart(2, '0'))
            .join('')

    //  - PLC reset:        'RS<u8>' (checksum)
    //  - Program download: 'PD<u32><u8[]><u8>' (size, data, checksum)
    //  - Program upload:   'PU<u8>' (checksum)
    //  - Program run:      'PR<u8>' (checksum)
    //  - Program stop:     'PS<u8>' (checksum)
    //  - Memory read:      'MR<u32><u32><u8>' (address, size, checksum)
    //  - Memory write:     'MW<u32><u32><u8[]><u8>' (address, size, data, checksum)
    //  - Memory write mask:'MM<u32><u32><u8[]><u8[]><u8>' (address, size, data, mask, checksum)
    //  - Memory format:    'MF<u32><u32><u8><u8>' (address, size, value, checksum)
    //  - Source download:  'SD<u32><u8[]><u8>' (size, data, checksum) // Only available if PLCRUNTIME_SOURCE_ENABLED is defined
    //  - Source upload:    'SU<u32><u8>' (size, checksum) // Only available if PLCRUNTIME_SOURCE_ENABLED is defined
    buildCommand = {
        /** @returns { string } */
        plcReset: () => {
            const cmd = 'RS'
            const cmd_hex = this.stringToHex(cmd)
            const checksum = this.crc8(this.parseHex(cmd_hex))
            const checksum_hex = checksum.toString(16).padStart(2, '0')
            const command = cmd + checksum_hex
            return command
        },

        /** @param { number[] | [number[]] | [string] } input * @returns { string } */
        programDownload: (...input) => {
            const cmd = 'PD'
            const cmd_hex = this.stringToHex(cmd)
            let checksum = this.crc8(this.parseHex(cmd_hex))
            input = Array.isArray(input[0]) ? input[0] : input
            const allowedChars = '0123456789abcdefABCDEF'
            if (typeof input[0] === 'string')
                input = this.parseHex(
                    input[0]
                        .split('')
                        .filter(c => allowedChars.includes(c))
                        .join('') || '',
                )
            /** @type { number[] } */ // @ts-ignore
            const data = input
            const data_hex = data.map(d => d.toString(16).padStart(2, '0'))
            const size = data.length
            const size_hex_u32 = size.toString(16).padStart(8, '0')
            checksum = this.crc8(this.parseHex(size_hex_u32), checksum)
            checksum = this.crc8(data, checksum)
            const checksum_hex = checksum.toString(16).padStart(2, '0')
            const command = cmd + size_hex_u32 + data_hex.join('') + checksum_hex
            return command.toUpperCase()
        },

        /** @returns { string } */
        programUpload: () => {
            const cmd = 'PU'
            const cmd_hex = this.stringToHex(cmd)
            const checksum = this.crc8(this.parseHex(cmd_hex))
            const checksum_hex = checksum.toString(16).padStart(2, '0')
            const command = cmd + checksum_hex
            return command
        },

        /** @returns { string } */
        programRun: () => {
            const cmd = 'PR'
            const cmd_hex = this.stringToHex(cmd)
            const checksum = this.crc8(this.parseHex(cmd_hex))
            const checksum_hex = checksum.toString(16).padStart(2, '0')
            const command = cmd + checksum_hex
            return command
        },

        /** @returns { string } */
        programStop: () => {
            const cmd = 'PS'
            const cmd_hex = this.stringToHex(cmd)
            const checksum = this.crc8(this.parseHex(cmd_hex))
            const checksum_hex = checksum.toString(16).padStart(2, '0')
            const command = cmd + checksum_hex
            return command
        },

        /** @param { number } address * @param { number } size * @returns { string } */
        memoryRead: (address, size = 1) => {
            const cmd = 'MR'
            const cmd_hex = this.stringToHex(cmd)
            const address_hex_u32 = address.toString(16).padStart(8, '0')
            const size_hex_u32 = size.toString(16).padStart(8, '0')
            let checksum = this.crc8(this.parseHex(cmd_hex))
            checksum = this.crc8(this.parseHex(address_hex_u32), checksum)
            checksum = this.crc8(this.parseHex(size_hex_u32), checksum)
            const checksum_hex = checksum.toString(16).padStart(2, '0')
            const command = cmd + address_hex_u32 + size_hex_u32 + checksum_hex
            return command
        },

        /** @param { number } address * @param { number[] | [number[]] | [string] } input * @returns { string } */
        memoryWrite: (address, input) => {
            const cmd = 'MW'
            const cmd_hex = this.stringToHex(cmd)
            let checksum = this.crc8(this.parseHex(cmd_hex))
            const address_hex_u32 = address.toString(16).padStart(8, '0')
            checksum = this.crc8(this.parseHex(address_hex_u32), checksum)
            input = Array.isArray(input[0]) ? input[0] : input
            const allowedChars = '0123456789abcdefABCDEF'
            if (typeof input[0] === 'string')
                input = this.parseHex(
                    input[0]
                        .split('')
                        .filter(c => allowedChars.includes(c))
                        .join('') || '',
                )
            /** @type { number[] } */ // @ts-ignore
            const data = input
            const data_hex = data.map(d => d.toString(16).padStart(2, '0')).join('')
            const size = data.length
            const size_hex_u32 = size.toString(16).padStart(8, '0')
            checksum = this.crc8(this.parseHex(size_hex_u32), checksum)
            checksum = this.crc8(data, checksum)
            const checksum_hex = checksum.toString(16).padStart(2, '0')
            const command = cmd + address_hex_u32 + size_hex_u32 + data_hex + checksum_hex
            return command
        },

        /** @type { (address: number, data: number[] | [number[]] | [string], mask: number[] | [number[]] | [string]) => string } */
        memoryWriteMask: (address, data, mask) => {
            const cmd = 'MM'
            const cmd_hex = this.stringToHex(cmd)
            let checksum = this.crc8(this.parseHex(cmd_hex))
            const address_hex_u32 = address.toString(16).padStart(8, '0')
            checksum = this.crc8(this.parseHex(address_hex_u32), checksum)
            data = Array.isArray(data[0]) ? data[0] : data
            mask = Array.isArray(mask[0]) ? mask[0] : mask
            const allowedChars = '0123456789abcdefABCDEF'
            if (typeof data[0] === 'string')
                data = this.parseHex(
                    data[0]
                        .split('')
                        .filter(c => allowedChars.includes(c))
                        .join('') || '',
                )
            if (typeof mask[0] === 'string')
                mask = this.parseHex(
                    mask[0]
                        .split('')
                        .filter(c => allowedChars.includes(c))
                        .join('') || '',
                )
            /** @type { number[] } */ // @ts-ignore
            const data_bytes = data
            /** @type { number[] } */ // @ts-ignore
            const mask_bytes = mask
            if (data_bytes.length !== mask_bytes.length) throw new Error('Mask length must match data length')
            const size = data_bytes.length
            const size_hex_u32 = size.toString(16).padStart(8, '0')
            checksum = this.crc8(this.parseHex(size_hex_u32), checksum)
            checksum = this.crc8(data_bytes, checksum)
            checksum = this.crc8(mask_bytes, checksum)
            const data_hex = data_bytes.map(d => d.toString(16).padStart(2, '0')).join('')
            const mask_hex = mask_bytes.map(d => d.toString(16).padStart(2, '0')).join('')
            const checksum_hex = checksum.toString(16).padStart(2, '0')
            const command = cmd + address_hex_u32 + size_hex_u32 + data_hex + mask_hex + checksum_hex
            return command
        },

        /** @param { number } address * @param { number } size * @param { number } value * @returns { string } */
        memoryFormat: (address, size, value) => {
            const cmd = 'MF'
            const cmd_hex = this.stringToHex(cmd)
            const address_hex_u32 = address.toString(16).padStart(8, '0')
            const size_hex_u32 = size.toString(16).padStart(8, '0')
            const value_hex = value.toString(16).padStart(2, '0')
            let checksum = this.crc8(this.parseHex(cmd_hex))
            checksum = this.crc8(this.parseHex(address_hex_u32), checksum)
            checksum = this.crc8(this.parseHex(size_hex_u32), checksum)
            checksum = this.crc8(this.parseHex(value_hex), checksum)
            const checksum_hex = checksum.toString(16).padStart(2, '0')
            const command = cmd + address_hex_u32 + size_hex_u32 + value_hex + checksum_hex
            return command
        },
        /** @param { number } timerOffset * @param { number } counterOffset * @returns { string } */
        tcConfig: (timerOffset, counterOffset) => {
            const cmd = 'TC'
            const cmd_hex = this.stringToHex(cmd)
            const timer_hex_u16 = timerOffset.toString(16).padStart(4, '0')
            const counter_hex_u16 = counterOffset.toString(16).padStart(4, '0')
            let checksum = this.crc8(this.parseHex(cmd_hex))
            checksum = this.crc8(this.parseHex(timer_hex_u16), checksum)
            checksum = this.crc8(this.parseHex(counter_hex_u16), checksum)
            const checksum_hex = checksum.toString(16).padStart(2, '0')
            const command = cmd + timer_hex_u16 + counter_hex_u16 + checksum_hex
            return command
        },

        /** Request DataBlock info from device (DA command) * @returns { string } */
        dbInfo: () => {
            const cmd = 'DA'
            const cmd_hex = this.stringToHex(cmd)
            const checksum = this.crc8(this.parseHex(cmd_hex))
            const checksum_hex = checksum.toString(16).padStart(2, '0')
            return cmd + checksum_hex
        },

        /**
         * Read a DataBlock from device memory (DR command)
         * @param { number } dbNumber - The DB number to read
         * @returns { string }
         */
        dbRead: (dbNumber) => {
            const cmd = 'DR'
            const cmd_hex = this.stringToHex(cmd)
            const db_hex_u16 = dbNumber.toString(16).padStart(4, '0')
            let checksum = this.crc8(this.parseHex(cmd_hex))
            checksum = this.crc8(this.parseHex(db_hex_u16), checksum)
            const checksum_hex = checksum.toString(16).padStart(2, '0')
            return cmd + db_hex_u16 + checksum_hex
        },
    }
}

const SHARED_BUFFER_SIZE = 64 * 1024 * 1024 // 64MB
const RING_SIZE = 1024 * 1024 // 1MB for each ring
const OFFSETS = {
    M2S_WRITE: 0, // Master Write Index
    M2S_READ: 4, // Slave Read Index
    S2M_WRITE: 8, // Slave Write Index
    S2M_READ: 12, // Master Read Index
    LOCK: 16,
    IO_OFFSET: 20,
    IO_IN_SIZE: 24,
    IO_OUT_SIZE: 28,
    M2S_START: 1024,
    S2M_START: 1024 + RING_SIZE,
    DATA_START: 1024 + RING_SIZE * 2,
}

/**
 * @typedef {{
 *   postMessage: (message: any, transfer?: Transferable[]) => void,
 *   terminate?: () => any,
 *   addEventListener?: (type: string, listener: (event: any) => void) => void,
 *   removeEventListener?: (type: string, listener: (event: any) => void) => void,
 *   on?: (type: string, listener: (event: any) => void) => void,
 *   off?: (type: string, listener: (event: any) => void) => void,
 *   once?: (type: string, listener: (event: any) => void) => void,
 *   removeListener?: (type: string, listener: (event: any) => void) => void,
 *   removeAllListeners?: (type?: string) => void,
 *   unref?: () => void,
 *   onmessage?: ((event: any) => void) | null,
 *   onerror?: ((error: any) => void) | null,
 * }} VovkPLCWorkerLike
 */

/**
 * @typedef {(url: URL | string) => VovkPLCWorkerLike | Promise<VovkPLCWorkerLike>} VovkPLCWorkerFactory
 */

/**
 * @typedef {{
 *   workerUrl?: URL | string,
 *   workerFactory?: VovkPLCWorkerFactory,
 *   debug?: boolean,
 *   silent?: boolean,
 *   batchFlushDelay?: number,
 *   forcePostMessage?: boolean
 * }} VovkPLCWorkerOptions
 */

/**
 * @typedef {{ resolve: (value: any) => void, reject: (reason?: any) => void }} VovkPLCPendingRequest
 */

class VovkPLCWorkerInstance {
    /** @type { VovkPLCWorkerClient } */
    client
    /** @type { number } */
    id
    /** @param { VovkPLCWorkerClient } client * @param { number } id */
    constructor(client, id) {
        this.client = client
        this.id = id
    }
    /** @type { (method: string, ...args: any[]) => Promise<any> } */
    call = (method, ...args) => this.client.callInstance(this.id, method, ...args)
    /** @type { (name: string, ...args: any[]) => Promise<any> } */
    callExport = (name, ...args) => this.client.callInstance(this.id, 'callExport', name, ...args)
    /** @type { () => Promise<string[]> } */
    getExports = () => this.client.callInstance(this.id, 'getExports')
    /** @type { (callback: (message: string, instanceId?: number) => void) => Promise<any> } */
    onStdout = callback => this.client.onStdout(callback, this.id)
    /** @type { (callback: (message: string, instanceId?: number) => void) => Promise<any> } */
    onStderr = callback => this.client.onStderr(callback, this.id)
    /** @type { () => Promise<any> } */
    dispose = () => this.client.disposeInstance(this.id)
}

class VovkPLCWorkerClient {
    /** @type { VovkPLCWorkerLike } */
    worker
    /** @type { number } */
    nextId = 1
    /** @type { Map<number, VovkPLCPendingRequest> } */
    pending = new Map()
    /** @type { Map<string | number, (message: string, instanceId?: number) => void> } */
    stdoutHandlers = new Map()
    /** @type { Map<string | number, (message: string, instanceId?: number) => void> } */
    stderrHandlers = new Map()
    /** @type { (message: any) => void } */
    _onMessage
    /** @type { (error: any) => void } */
    _onError

    /** @type { SharedArrayBuffer | null } */
    sab = null
    /** @type { Int32Array | null } */
    sabI32 = null
    /** @type { Uint8Array | null } */
    sabU8 = null

    encoder = new TextEncoder()
    decoder = new TextDecoder()

    isPolling = false

    // Batched postMessage fallback for high-throughput when SAB unavailable
    /** @type { Array<{id: number, type: string, payload: Record<string, any>}> } */
    batchQueue = []
    /** @type { boolean } */
    batchScheduled = false
    /** @type { number } */
    batchFlushDelay = 20 // ms - batching window for collecting requests (tune for latency vs throughput)
    /** @type { boolean } */
    useBatchedFallback = false
    /** @type { boolean } When true, disables SAB and forces batched postMessage mode */
    forcePostMessage = false

    /** @param { VovkPLCWorkerLike } worker */
    constructor(worker) {
        this.worker = worker
        this._onMessage = this._handleMessage
        this._onError = this._handleError

        // Performance optimization: Prefer direct property assignment for Browser Workers
        // This bypasses the EventTarget dispatch chain overhead significantly in high-frequency scenarios
        if ('onmessage' in worker) {
            worker.onmessage = this._onMessage
            worker.onerror = this._onError
        } else if (typeof worker.addEventListener === 'function') {
            worker.addEventListener('message', this._onMessage)
            worker.addEventListener('error', this._onError)
        } else if (typeof worker.on === 'function') {
            worker.on('message', this._onMessage)
            worker.on('error', this._onError)
        }
    }

    /** @type { () => void } */
    stopPolling = () => {
        this.isPolling = false
    }

    /** @type { () => void } */
    startPolling = () => {
        if (this.isPolling) return
        this.isPolling = true

        const poll = () => {
            if (!this.sabI32 || !this.sabU8 || !this.isPolling) return

            // Allow checking for multiple messages in one poll tick
            while (true) {
                // Check if Data in S2M Ring
                const readIdx = Atomics.load(this.sabI32, OFFSETS.S2M_READ / 4)
                const writeIdx = Atomics.load(this.sabI32, OFFSETS.S2M_WRITE / 4)

                if (readIdx === writeIdx) break // Buffer Empty

                const start = OFFSETS.S2M_START
                let current = readIdx

                // Helper to read wrapping buffer
                const readByte = (/** @type {number} */ idx) => (this.sabU8 ? this.sabU8[start + (idx % RING_SIZE)] : 0)
                const readU32 = (/** @type {number} */ idx) => {
                    let val = 0
                    val |= readByte(idx)
                    val |= readByte(idx + 1) << 8
                    val |= readByte(idx + 2) << 16
                    val |= readByte(idx + 3) << 24
                    return val
                }

                const frameSize = readU32(current)
                const msgId = readU32(current + 4)
                const ok = readByte(current + 8)

                // Payload
                const payloadLen = frameSize - 9
                let payload = null

                if (payloadLen > 0) {
                    // Extract payload. Since it might wrap, we might need two copies
                    const payloadStart = (current + 9) % RING_SIZE
                    const payloadEnd = (current + 9 + payloadLen) % RING_SIZE

                    if (this.sab && this.sabU8) {
                        if (payloadEnd > payloadStart) {
                            const view = new Uint8Array(this.sab, start + payloadStart, payloadLen)
                            // Use copy-less decode if supported, otherwise fallback to copy
                            const str = this.decoder.decode(SUPPORT.decodeShared ? view : new Uint8Array(view))
                            if (str) payload = JSON.parse(str)
                        } else {
                            // Wrapping
                            const part1Len = RING_SIZE - payloadStart
                            const buf = new Uint8Array(payloadLen)
                            buf.set(new Uint8Array(this.sab, start + payloadStart, part1Len))
                            buf.set(new Uint8Array(this.sab, start, payloadLen - part1Len), part1Len)
                            const str = this.decoder.decode(buf)
                            if (str) payload = JSON.parse(str)
                        }
                    }
                }

                // Handling Message
                const pending = this.pending.get(msgId)
                if (pending) {
                    this.pending.delete(msgId)
                    if (ok) pending.resolve(payload && typeof payload.result !== 'undefined' ? payload.result : payload)
                    else pending.reject(new Error(payload && payload.error ? payload.error : 'Worker call failed'))
                } else if (msgId === 0) {
                    // EVENTS have ID 0
                    // Structure for events: { type: 'event', event: ..., ... }
                    // payload is the message object
                    if (payload && payload.type === 'event') {
                        this._handleEvent(payload)
                    }
                }

                // Advance Read Pointer
                const nextRead = readIdx + frameSize
                Atomics.store(this.sabI32, OFFSETS.S2M_READ / 4, nextRead)
            }

            if (this.isPolling) {
                if (isNodeRuntime) setImmediate(poll)
                else requestAnimationFrame(poll)
            }
        }
        poll()
    }

    /** @type { (message: any) => void } */
    _handleMessage = message => {
        const data = message.data || message

        // Check for batched ArrayBuffer response
        if (data instanceof ArrayBuffer) {
            this._parseBatchResponse(data)
            return
        }

        // Handle Init Response special case if needed, or fallback for non-shared setup
        if (data.id) {
            const pending = this.pending.get(data.id)
            if (pending) {
                this.pending.delete(data.id)
                if (data.ok) {
                    if (data.type === 'init_ack') {
                        // Received Ack for Init with Shared Memory
                        this.startPolling()
                    }
                    pending.resolve(data.result)
                } else pending.reject(new Error(data.error || 'Worker call failed'))
                return
            }
        }
        if (data.type === 'event') {
            this._handleEvent(data)
        }
    }

    /** @type { (data: any) => void } */
    _handleEvent = data => {
        if (!data || typeof data.event !== 'string') return
        const key = data.instanceId == null ? 'default' : data.instanceId
        if (data.event === 'stdout') {
            const handler = this.stdoutHandlers.get(key) || this.stdoutHandlers.get('default')
            if (handler) handler(data.message, data.instanceId)
            return
        }
        if (data.event === 'stderr') {
            const handler = this.stderrHandlers.get(key) || this.stderrHandlers.get('default')
            if (handler) handler(data.message, data.instanceId)
        }
    }

    /** @type { (error: any) => void } */
    _handleError = error => {
        const message = error && error.message ? error.message : String(error)
        const err = error instanceof Error ? error : new Error(message)
        for (const pending of this.pending.values()) pending.reject(err)
        this.pending.clear()
    }

    /** @type { (type: string, payload?: Record<string, any>) => Promise<any> } */
    _send = (type, payload = {}) => {
        const id = this.nextId++
        return new Promise((resolve, reject) => {
            this.pending.set(id, {resolve, reject})

            // If Shared Memory is active and not forced to use postMessage, use Ring Buffer
            if (!this.forcePostMessage && this.sab && this.sabI32 && this.sabU8) {
                try {
                    this._writeToRing({id, type, ...payload})
                } catch (e) {
                    reject(e)
                }
            } else if (this.useBatchedFallback) {
                // High-throughput batched fallback
                this._enqueueBatch(id, type, payload)
            } else {
                // Simple postMessage (Init only, before batching is enabled)
                this.worker.postMessage({id, type, ...payload})
            }
        })
    }

    /** @type { (id: number, type: string, payload: Record<string, any>) => void } */
    _enqueueBatch = (id, type, payload) => {
        this.batchQueue.push({id, type, payload})
        if (!this.batchScheduled) {
            this.batchScheduled = true
            // Use queueMicrotask for minimal latency, or setTimeout for batching window
            if (this.batchFlushDelay <= 0) {
                queueMicrotask(() => this._flushBatch())
            } else {
                setTimeout(() => this._flushBatch(), this.batchFlushDelay)
            }
        }
    }

    /** @type { () => void } */
    _flushBatch = () => {
        this.batchScheduled = false
        if (this.batchQueue.length === 0) return

        const ops = this.batchQueue.splice(0, this.batchQueue.length)

        // Calculate total size needed
        // Format: [u32 count][...ops]
        // Each op: [u32 id][u8 typeLen][type bytes][u32 payloadLen][payload bytes]
        let totalSize = 4 // count
        const encodedOps = ops.map(op => {
            const typeBytes = this.encoder.encode(op.type)
            const payloadBytes = this.encoder.encode(JSON.stringify(op.payload))
            totalSize += 4 + 1 + typeBytes.length + 4 + payloadBytes.length
            return {id: op.id, typeBytes, payloadBytes}
        })

        // Build the buffer
        const buf = new ArrayBuffer(totalSize)
        const dv = new DataView(buf)
        const u8 = new Uint8Array(buf)
        let off = 0

        dv.setUint32(off, encodedOps.length, true)
        off += 4

        for (const op of encodedOps) {
            dv.setUint32(off, op.id, true)
            off += 4
            dv.setUint8(off, op.typeBytes.length)
            off += 1
            u8.set(op.typeBytes, off)
            off += op.typeBytes.length
            dv.setUint32(off, op.payloadBytes.length, true)
            off += 4
            u8.set(op.payloadBytes, off)
            off += op.payloadBytes.length
        }

        // Transfer the buffer (zero-copy)
        this.worker.postMessage(buf, [buf])
    }

    /** @type { (buffer: ArrayBuffer) => void } */
    _parseBatchResponse = buffer => {
        // Format: [u32 count][...responses]
        // Each response: [u32 id][u8 ok][u32 payloadLen][payload bytes]
        const dv = new DataView(buffer)
        const u8 = new Uint8Array(buffer)
        let off = 0

        const count = dv.getUint32(off, true)
        off += 4

        for (let i = 0; i < count; i++) {
            const id = dv.getUint32(off, true)
            off += 4
            const ok = dv.getUint8(off) === 1
            off += 1
            const payloadLen = dv.getUint32(off, true)
            off += 4

            let result = undefined
            let error = undefined
            if (payloadLen > 0) {
                const payloadBytes = u8.subarray(off, off + payloadLen)
                const payloadStr = this.decoder.decode(payloadBytes)
                try {
                    const parsed = JSON.parse(payloadStr)
                    if (ok) result = parsed.result
                    else error = parsed.error
                } catch (e) {
                    error = payloadStr
                }
            }
            off += payloadLen

            const pending = this.pending.get(id)
            if (pending) {
                this.pending.delete(id)
                if (ok) pending.resolve(result)
                else pending.reject(new Error(error || 'Worker call failed'))
            }
        }
    }

    /** @param { Record<string, any> } msg */
    _writeToRing = msg => {
        if (!this.sabI32 || !this.sabU8) throw new Error('Shared Buffer not initialized')
        // Frame: [TotalSize(4)][ID(4)][TypeLen(1)][Type(utf8)][Payload(json_utf8)]
        const {id, type, ...rest} = msg
        const typeBytes = this.encoder.encode(type)
        const payloadStr = JSON.stringify(rest)
        const payloadBytes = this.encoder.encode(payloadStr)

        const totalSize = 4 + 4 + 1 + typeBytes.length + payloadBytes.length

        // Wait for space?
        // Simple spin-wait with timeout to avoid freezing main thread indefinitely if worker dead
        const startWait = Date.now()
        let writeIdx, readIdx
        while (true) {
            writeIdx = Atomics.load(this.sabI32, OFFSETS.M2S_WRITE / 4)
            readIdx = Atomics.load(this.sabI32, OFFSETS.M2S_READ / 4)
            if (writeIdx - readIdx + totalSize <= RING_SIZE) break
            if (Date.now() - startWait > 1000) throw new Error('Command Queue Full (Timeout)')
            // Yield? No yield in JS sync function...
        }

        const start = OFFSETS.M2S_START
        const current = writeIdx

        // Write Helper
        const writeByte = (/** @type {number} */ idx, /** @type {number} */ val) => {
            if (this.sabU8) this.sabU8[start + (idx % RING_SIZE)] = val
        }
        const writeU32 = (/** @type {number} */ idx, /** @type {number} */ val) => {
            writeByte(idx, val & 0xff)
            writeByte(idx + 1, (val >> 8) & 0xff)
            writeByte(idx + 2, (val >> 16) & 0xff)
            writeByte(idx + 3, (val >> 24) & 0xff)
        }

        writeU32(current, totalSize)
        writeU32(current + 4, id)
        writeByte(current + 8, typeBytes.length)

        // Write Type
        let i = 0
        for (; i < typeBytes.length; i++) writeByte(current + 9 + i, typeBytes[i])

        // Write Payload
        const payloadStart = 9 + typeBytes.length
        for (let j = 0; j < payloadBytes.length; j++) writeByte(current + payloadStart + j, payloadBytes[j])

        // Commit
        const nextWrite = writeIdx + totalSize
        Atomics.store(this.sabI32, OFFSETS.M2S_WRITE / 4, nextWrite)
        Atomics.notify(this.sabI32, OFFSETS.M2S_WRITE / 4) // Wake worker
    }

    /** @type { (stream: 'stdout' | 'stderr', callback: (message: string, instanceId?: number) => void, instanceId?: number | null) => Promise<any> } */
    _setStreamHandler = (stream, callback, instanceId) => {
        if (typeof callback !== 'function') throw new Error('Stream callback must be a function')
        const key = instanceId == null ? 'default' : instanceId
        if (stream === 'stdout') this.stdoutHandlers.set(key, callback)
        else if (stream === 'stderr') this.stderrHandlers.set(key, callback)
        else throw new Error(`Unknown stream type: ${stream}`)
        return this._send('subscribe', {stream, instanceId})
    }

    /** @type { (wasmPath?: string, debug?: boolean, silent?: boolean) => Promise<any> } */
    initialize = (wasmPath = '', debug = false, silent = false) => {
        // Initialize Shared Buffer if supported and not forced to use postMessage
        if (!this.forcePostMessage && SUPPORT.sab && SUPPORT.atomics) {
            try {
                this.sab = new SharedArrayBuffer(SHARED_BUFFER_SIZE)
                this.sabI32 = new Int32Array(this.sab)
                this.sabU8 = new Uint8Array(this.sab)

                // Init Queues
                this.sabI32[OFFSETS.M2S_WRITE / 4] = 0
                this.sabI32[OFFSETS.M2S_READ / 4] = 0
                this.sabI32[OFFSETS.S2M_WRITE / 4] = 0
                this.sabI32[OFFSETS.S2M_READ / 4] = 0

                // Send init with SAB via postMessage
                // We fake '_send' logic here because we need to attach the SAB
                const id = this.nextId++
                return new Promise((resolve, reject) => {
                    this.pending.set(id, {resolve, reject})
                    // @ts-ignore
                    this.worker.postMessage({id, type: 'init', wasmPath, debug, silent, sharedBuffer: this.sab})
                }).then(res => {
                    // Start Polling once initialized
                    this.startPolling()
                    return res
                })
            } catch (e) {
                console.warn('Failed to create SharedArrayBuffer, falling back to batched postMessage', e)
            }
        }
        // Use batched fallback for high-throughput after init completes
        return this._send('init', {wasmPath, debug, silent}).then(res => {
            // Enable batched mode after successful init (when SAB not available or forcePostMessage is set)
            if (!this.sab || this.forcePostMessage) {
                this.useBatchedFallback = true
            }
            return res
        })
    }
    /** @type { (method: string, ...args: any[]) => Promise<any> } */
    call = (method, ...args) => this._send('call', {method, args})
    /** @type { (instanceId: number | null | undefined, method: string, ...args: any[]) => Promise<any> } */
    callInstance = (instanceId, method, ...args) => this._send('call', {instanceId, method, args})
    /** @type { (wasmPath?: string, debug?: boolean) => Promise<VovkPLCWorkerInstance> } */
    createInstance = (wasmPath = '', debug = false) => this._send('create', {wasmPath, debug}).then(id => new VovkPLCWorkerInstance(this, id))
    /** @type { (instanceId: number | null | undefined) => Promise<any> } */
    disposeInstance = instanceId => this._send('dispose', {instanceId})
    /** @type { (callback: (message: string, instanceId?: number) => void, instanceId?: number | null) => Promise<any> } */
    onStdout = (callback, instanceId = null) => this._setStreamHandler('stdout', callback, instanceId)
    /** @type { (callback: (message: string, instanceId?: number) => void, instanceId?: number | null) => Promise<any> } */
    onStderr = (callback, instanceId = null) => this._setStreamHandler('stderr', callback, instanceId)
    /** @type { (sharedBuffer: SharedArrayBuffer, instanceId?: number | null) => Promise<any> } */
    setupSharedMemory = (sharedBuffer, instanceId = null) => this._send('setup_shared_memory', {sharedBuffer, instanceId})

    /**
     * Terminate the worker and clean up resources.
     * @param {Object} options - Termination options
     * @param {boolean} [options.exit=false] - If true, call process.exit(0) after cleanup (Node.js only).
     *   Due to Node.js worker_threads behavior, the process may not exit naturally even after
     *   worker.terminate(). Use exit:true for CLI tools or when this is the last operation.
     * @returns {Promise<number>} - Returns 0 on success
     */
    terminate = async (options = {}) => {
        // Stop polling loop first
        this.stopPolling()

        // Reject all pending requests
        for (const pending of this.pending.values()) pending.reject(new Error('Worker terminated'))
        this.pending.clear()
        this.stdoutHandlers.clear()
        this.stderrHandlers.clear()

        // Remove all event listeners BEFORE terminating
        if (typeof this.worker.removeEventListener === 'function') {
            this.worker.removeEventListener('message', this._onMessage)
            this.worker.removeEventListener('error', this._onError)
        } else if (typeof this.worker.off === 'function') {
            this.worker.off('message', this._onMessage)
            this.worker.off('error', this._onError)
        } else if (typeof this.worker.removeListener === 'function') {
            this.worker.removeListener('message', this._onMessage)
            this.worker.removeListener('error', this._onError)
        }

        // Unref before terminate so the worker doesn't keep the process alive
        if (typeof this.worker.unref === 'function') this.worker.unref()

        // Terminate and wait for exit
        if (typeof this.worker.terminate === 'function') {
            // For Node.js worker_threads, wait for the 'exit' event for proper cleanup
            const exitPromise = new Promise(resolve => {
                if (typeof this.worker.once === 'function') {
                    this.worker.once('exit', resolve)
                } else {
                    resolve(0)
                }
            })
            const result = this.worker.terminate()
            if (result && typeof result.then === 'function') await result
            await exitPromise
        }

        // Remove any remaining listeners (belt and suspenders)
        if (typeof this.worker.removeAllListeners === 'function') {
            this.worker.removeAllListeners()
        }

        // In Node.js, optionally force process exit after cleanup
        // This is needed because Node.js worker_threads may keep internal refs even after terminate
        if (options.exit && isNodeRuntime && typeof process !== 'undefined' && typeof process.exit === 'function') {
            setImmediate(() => process.exit(0))
        }
        return 0
    }
}

class VovkPLCWorker extends VovkPLCWorkerClient {
    /** @type { VovkPLC_class } */
    helper
    /** @type { VovkPLC_class['buildCommand'] } */
    buildCommand
    /** @param { VovkPLCWorkerLike } worker */
    constructor(worker) {
        super(worker)
        this.helper = new VovkPLC_class()
        this.buildCommand = this.helper.buildCommand
    }

    /** @type { (wasmPath?: string, options?: VovkPLCWorkerOptions) => Promise<VovkPLCWorker> } */
    static create = async (wasmPath = '', {workerUrl, workerFactory, debug = false, silent = false, batchFlushDelay = 20, forcePostMessage = false} = {}) => {
        const resolvedUrl = workerUrl || new URL('./VovkPLC.worker.js', import.meta.url)
        const factory = workerFactory || (await getDefaultWorkerFactory())
        const worker = await createWorker(factory, resolvedUrl)
        const client = new VovkPLCWorker(worker)
        // Allow tuning batch flush delay (0 = immediate via microtask, >0 = collect requests for N ms)
        client.batchFlushDelay = batchFlushDelay
        // Force postMessage mode (disable SAB even if available)
        client.forcePostMessage = forcePostMessage
        await client.initialize(wasmPath, debug, silent)
        return client
    }

    /** @type { (assembly: string, debug?: boolean) => Promise<any> } */
    lintPLCASM = (assembly, debug = false) => this.call('lintPLCASM', assembly, debug)
    /** @type { (stl: string, debug?: boolean) => Promise<{ problems: STLLinterProblem[], output: string }> } */
    lintSTL = (stl, debug = false) => this.call('lintSTL', stl, debug)
    /** @type { (script: string, debug?: boolean) => Promise<PLCScriptLintResult> } */
    lintPLCScript = (script, debug = false) => this.call('lintPLCScript', script, debug)
    /** @type { (st: string, debug?: boolean) => Promise<STLintResult> } */
    lintST = (st, debug = false) => this.call('lintST', st, debug)
    /** @type { (ladder: string | LadderGraph, debug?: boolean) => Promise<{ problems: LadderLinterProblem[], output: string }> } */
    lintLadder = (ladder, debug = false) => this.call('lintLadder', ladder, debug)
    /** @type { (value?: boolean) => Promise<any> } */
    setSilent = value => this.call('setSilent', value)
    /** @type { () => Promise<any> } */
    printInfo = () => this.call('printInfo')
    /** @type { () => Promise<DeviceHealth> } */
    getDeviceHealth = () => this.call('getDeviceHealth')
    /** @type { () => Promise<void> } */
    resetDeviceHealth = () => this.call('resetDeviceHealth')
    /** @type { (systemOffset: number, inputOffset: number, outputOffset: number, markerOffset: number) => Promise<void> } */
    setRuntimeOffsets = (systemOffset, inputOffset, outputOffset, markerOffset) => this.call('setRuntimeOffsets', systemOffset, inputOffset, outputOffset, markerOffset)
    /** @type { (assembly: string) => Promise<any> } */
    downloadAssembly = assembly => this.call('downloadAssembly', assembly)
    /** @type { (plcasm: string, options?: { run?: boolean }) => Promise<CompileResult> } */
    compilePLCASM = (plcasm, options = {}) => this.call('compilePLCASM', plcasm, options)
    /** @type { (stl: string) => Promise<CompileResult> } */
    compileSTL = stl => this.call('compileSTL', stl)
    /** @type { (ladder: string | LadderGraph) => Promise<CompileResult> } */
    compileLadder = ladder => this.call('compileLadder', ladder)
    /** @type { (plcscript: string) => Promise<CompileResult> } */
    compilePLCScript = plcscript => this.call('compilePLCScript', plcscript)
    /** @type { (st: string) => Promise<CompileResult> } */
    compileST = st => this.call('compileST', st)
    /** @type { (source: string | LadderGraph, language: 'ladder-graph' | 'stl' | 'st' | 'plcscript' | 'plcasm') => Promise<CompileAllResult> } */
    compileAll = (source, language) => this.call('compileAll', source, language)
    /** @type { (projectSource: string, options?: ProjectCompileOptions) => Promise<ProjectCompileResult> } */
    compileProject = (projectSource, options = {}) => this.call('compileProject', projectSource, options)
    /** @type { (source?: 'compiled' | 'project' | 'runtime', options?: { print?: boolean }) => Promise<WCETReport> } */
    analyzeWCET = (source = 'compiled', options = {}) => this.call('analyzeWCET', source, options)
    /** @type { (projectSource: string, options?: ProjectCompileOptions) => Promise<ProjectLinterProblem[]> } */
    lintProject = (projectSource, options = {}) => this.call('lintProject', projectSource, options)
    /** @type { (projectSource: string) => Promise<ProjectLinterProblem[]> } */
    lintProjectMetadata = (projectSource) => this.call('lintProjectMetadata', projectSource)
    /** @type { (program: string | number[]) => Promise<any> } */
    downloadBytecode = program => this.call('downloadBytecode', program)
    /** @type { () => Promise<any> } */
    run = () => this.call('run')
    /** @type { () => Promise<any> } */
    runDebug = () => this.call('runDebug')
    /** @type { () => Promise<{ size: number, output: string }> } */
    extractProgram = () => this.call('extractProgram')
    /** @type { (address: number, size?: number) => Promise<Uint8Array> } */
    readMemoryArea = (address, size = 1) => this.call('readMemoryArea', address, size)
    /** @type { (address: number, data: number[]) => Promise<string> } */
    writeMemoryArea = (address, data) => this.call('writeMemoryArea', address, data)
    /** @type { (address: number, data: number[], mask: number[]) => Promise<string> } */
    writeMemoryAreaMasked = (address, data, mask) => this.call('writeMemoryAreaMasked', address, data, mask)
    /** @type { () => Promise<string> } */
    readStream = () => this.call('readStream')
    /** @type { (flush?: boolean) => Promise<string> } */
    readOutBuffer = (flush = true) => this.call('readOutBuffer', flush)
    /** @type { () => Promise<void> } */
    flushOutBuffer = () => this.call('flushOutBuffer')
    /** @type { () => Promise<string[]> } */
    getExports = () => this.call('getExports')
    /** @type { (name: string, ...args: any[]) => Promise<any> } */
    callExport = (name, ...args) => this.call('callExport', name, ...args)
    /** @type { (millis: number) => Promise<void> } */
    setMillis = millis => this.call('setMillis', millis)
    /** @type { (micros: number) => Promise<void> } */
    setMicros = micros => this.call('setMicros', micros)
    /** @type { () => Promise<number> } */
    getMillis = () => this.call('getMillis')
    /** @type { () => Promise<number> } */
    getMicros = () => this.call('getMicros')
    /** @type { () => Promise<number> } */
    getTotalRam = () => this.call('getTotalRam')

    // FFI (Foreign Function Interface) methods
    /**
     * Register a JavaScript function as an FFI handler in the worker.
     * The function will be callable from PLC programs via the FFI instruction.
     * 
     * NOTE: The function is serialized as a string and recreated in the worker,
     * so it cannot close over any variables from the main thread scope.
     * Use simple, self-contained functions only.
     *
     * @param {string} name - The FFI function name (e.g., "F_my_function")
     * @param {string} signature - Type signature (e.g., "i32,i32->i32")
     * @param {string} description - Human-readable description
     * @param {Function} fn - The JavaScript function to call (must be serializable)
     * @returns {Promise<number>} - The FFI index on success, -1 on failure
     */
    registerFFI = (name, signature, description, fn) => {
        const fnString = fn.toString()
        return this._send('ffi_register', { name, signature, description, fnString })
    }

    /**
     * Unregister a JS FFI function by index.
     * @param {number} index - The FFI index
     * @returns {Promise<boolean>} - True if unregistered successfully
     */
    unregisterFFI = (index) => {
        return this._send('ffi_unregister', { index })
    }

    /**
     * Get the number of registered FFI functions.
     * @returns {Promise<number>}
     */
    getFFICount = () => {
        return this._send('ffi_count', {})
    }

    /**
     * Clear all FFI registrations (both C++ and JS).
     * @returns {Promise<boolean>}
     */
    clearFFI = () => {
        return this._send('ffi_clear', {})
    }

    // IR (Intermediate Representation) accessors
    /** @type { () => Promise<import('./VovkPLC.js').IR_Entry[]> } */
    getIR = () => this.call('getIR')
    /** @type { () => Promise<number> } */
    getLabelsCount = () => this.call('getLabelsCount')
    /** @type { () => Promise<number> } */
    getConstsCount = () => this.call('getConstsCount')

    /** @type { SharedArrayBuffer | null } */
    _sharedBuffer = null
    /** @type { Int32Array | null } */
    _sharedControl = null
    /** @type { Uint8Array | null } */
    _sharedInputs = null
    /** @type { Uint8Array | null } */
    _sharedOutputs = null

    get sharedInputs() {
        if (this.sabU8 && this.sabI32) {
            const offset = this.sabI32[OFFSETS.IO_OFFSET / 4]
            const size = this.sabI32[OFFSETS.IO_IN_SIZE / 4] // @ts-ignore
            if (offset && size) return new Uint8Array(this.sab, offset, size)
        }
        return this._sharedInputs
    }
    get sharedOutputs() {
        if (this.sabU8 && this.sabI32) {
            const offset = this.sabI32[OFFSETS.IO_OFFSET / 4]
            const inSize = this.sabI32[OFFSETS.IO_IN_SIZE / 4]
            const outSize = this.sabI32[OFFSETS.IO_OUT_SIZE / 4] // @ts-ignore
            if (offset && inSize && outSize) return new Uint8Array(this.sab, offset + inSize, outSize)
        }
        return this._sharedOutputs
    }
    get sharedControl() {
        return this._sharedControl
    }

    /** @type { () => Promise<boolean> } */
    enableSharedMemory = async () => {
        // If we are initialized with SAB, we just need to verify the PLC is ready and pointers are set
        // In VovkPLCWorker (this class), 'this.worker' is the VovkPLCWorkerLike/Client if it's wrapping?
        // Wait, VovkPLCWorker extends VovkPLCWorkerClient.
        // So 'this' IS the client.
        if (!this.sab) return false

        // Use the new IO area in the 64MB buffer
        await this.printInfo() // Refresh info internally via stream/console hack? No, we used call before.

        // Wait, printInfo writes to stdout. We need to catch it?
        // Actually, we can just call the worker to "map" the IO area now that it has the info.

        // We don't need 'enableSharedMemory' logic for buffer creation anymore,
        // but we might need to tell the worker to populate the IO offsets in the header.
        await this._send('setup_shared_io')
        return true
    }

    /** @type { (mode?: 'run' | 'pause' | 'step' | 'stop') => void } */
    setSharedMode = (mode = 'run') => {
        // Command is at IO_OFFSET (Control Struct)
        if (!this.sabI32) return
        const offset = this.sabI32[OFFSETS.IO_OFFSET / 4]
        if (!offset) return
        // @ts-ignore
        const i32 = new Int32Array(this.sab, offset)
        const map = {stop: 0, run: 1, pause: 2, step: 3}
        Atomics.store(i32, 0, map[mode])
        Atomics.notify(i32, 0)
    }

    /**
     * Retrieves the shared status from the worker thread (if using SharedArrayBuffer).
     * This provides atomic access to runtime statistics without overhead.
     *
     * @returns {{ status: number, cycles: number, last_time: number, min_time: number, max_time: number } | null} - Stats object.
     */
    getSharedStatus = () => {
        if (!this.sabI32) return null
        const offset = this.sabI32[OFFSETS.IO_OFFSET / 4]
        if (!offset) return null // @ts-ignore
        const i32 = new Int32Array(this.sab, offset)

        return {
            status: Atomics.load(i32, 1),
            cycles: Atomics.load(i32, 6),
            last_time: Atomics.load(i32, 7),
            min_time: Atomics.load(i32, 8),
            max_time: Atomics.load(i32, 9),
        }
    }

    /**
     * Resets execution statistics (cycles, min/max times) via the worker.
     *
     * @returns {Promise<boolean>}
     */
    resetStats = () => this._send('resetStats')

    /**
     * Starts the PLC execution loop in strict mode.
     */
    startRuntime = () => this.setSharedMode('run')

    /**
     * Stops the PLC execution.
     */
    stopRuntime = () => this.setSharedMode('stop')

    /** @type { (data: number | number[], crc?: number) => number } */
    crc8 = (data, crc = 0) => this.helper.crc8(data, crc)
    /** @type { (hex: string) => number[] } */
    parseHex = hex => this.helper.parseHex(hex)
    /** @type { (str: string) => string } */
    stringToHex = str => this.helper.stringToHex(str)
}

/** @type { () => Promise<VovkPLCWorkerFactory> } */
const getDefaultWorkerFactory = async () => {
    if (isNodeRuntime) {
        const {Worker} = await import('worker_threads') // @ts-ignore
        return url => { // @ts-ignore
            const worker = new Worker(url, {type: 'module'})
            // Don't keep the process alive just because of this worker
            if (typeof worker.unref === 'function') worker.unref()
            return worker
        }
    } // @ts-ignore
    if (typeof Worker !== 'undefined') return url => new Worker(url, {type: 'module'})
    throw new Error('Workers are not supported in this environment')
}

/** @type { (factory: VovkPLCWorkerFactory, url: URL | string) => Promise<VovkPLCWorkerLike> } */
const createWorker = async (factory, url) => {
    const worker = factory(url) // @ts-ignore
    return worker && typeof worker.then === 'function' ? await worker : worker
}

/** @type { (wasmPath?: string, options?: VovkPLCWorkerOptions) => Promise<VovkPLCWorker> } */ // @ts-ignore
VovkPLC_class.createWorker = (wasmPath = '', options = {}) => VovkPLCWorker.create(wasmPath, options)

/**
 * Runtime flags bit definitions - matches runtime-types.h
 * @readonly
 * @enum {number}
 */
const RUNTIME_FLAGS = {
    LITTLE_ENDIAN: 0x0001,  // Bit 0: Endianness (0 = big-endian, 1 = little-endian)
    STRINGS:       0x0002,  // Bit 1: Strings enabled
    COUNTERS:      0x0004,  // Bit 2: Counters enabled
    TIMERS:        0x0008,  // Bit 3: Timers enabled
    FFI:           0x0010,  // Bit 4: FFI enabled
    X64_OPS:       0x0020,  // Bit 5: 64-bit operations enabled
    SAFE_MODE:     0x0040,  // Bit 6: Safe mode enabled
    TRANSPORT:     0x0080,  // Bit 7: Transport system enabled
    FLOAT_OPS:     0x0100,  // Bit 8: Float (f32) operations enabled
    ADVANCED_MATH: 0x0200,  // Bit 9: Advanced math enabled (POW, SQRT, SIN, COS)
    OPS_32BIT:     0x0400,  // Bit 10: 32-bit integer operations enabled (u32, i32)
    CVT:           0x0800,  // Bit 11: Type conversion (CVT) enabled
    STACK_OPS:     0x1000,  // Bit 12: Stack manipulation enabled (SWAP, PICK, POKE)
    BITWISE_OPS:   0x2000,  // Bit 13: Bitwise operations enabled (AND, OR, XOR, NOT, SHIFT)
}

/**
 * @typedef {Object} RuntimeFlagsDecoded
 * @property {number} raw - The raw flags value (u16)
 * @property {boolean} littleEndian - Bit 0: Device endianness (true = little-endian)
 * @property {boolean} strings - Bit 1: String operations enabled
 * @property {boolean} counters - Bit 2: Counter instructions enabled
 * @property {boolean} timers - Bit 3: Timer instructions enabled
 * @property {boolean} ffi - Bit 4: Foreign Function Interface enabled
 * @property {boolean} x64Ops - Bit 5: 64-bit operations enabled
 * @property {boolean} safeMode - Bit 6: Safe mode / bounds checking enabled
 * @property {boolean} transport - Bit 7: Transport system enabled
 * @property {boolean} floatOps - Bit 8: Float (f32) operations enabled
 * @property {boolean} advancedMath - Bit 9: Advanced math enabled (POW, SQRT, SIN, COS)
 * @property {boolean} ops32bit - Bit 10: 32-bit integer operations enabled (u32, i32)
 * @property {boolean} cvt - Bit 11: Type conversion (CVT) enabled
 * @property {boolean} stackOps - Bit 12: Stack manipulation enabled (SWAP, PICK, POKE)
 * @property {boolean} bitwiseOps - Bit 13: Bitwise operations enabled (AND, OR, XOR, NOT, SHIFT)
 */

/**
 * Decodes runtime flags from a live device's S0-S1 memory or device info response.
 * Use this to understand which features are enabled on a connected PLC device.
 *
 * @param {number} flags - The u16 runtime flags value from the device
 * @returns {RuntimeFlagsDecoded} - Decoded flags object with boolean properties
 *
 * @example
 * // From device info response or reading S0-S1 memory
 * const flagsValue = 0x007F; // Example: all features enabled except transport
 * const decoded = VovkPLC.decodeRuntimeFlags(flagsValue);
 * console.log(decoded);
 * // { raw: 127, littleEndian: true, strings: true, counters: true, timers: true, ffi: true, x64Ops: true, safeMode: true, transport: false }
 *
 * @example
 * // Check specific features
 * if (decoded.timers) {
 *     console.log('Device supports timer instructions');
 * }
 * if (!decoded.strings) {
 *     console.warn('Device was compiled without string support');
 * }
 */// @ts-ignore
VovkPLC_class.decodeRuntimeFlags = (flags) => ({
    raw: flags,
    littleEndian: !!(flags & RUNTIME_FLAGS.LITTLE_ENDIAN),
    strings:      !!(flags & RUNTIME_FLAGS.STRINGS),
    counters:     !!(flags & RUNTIME_FLAGS.COUNTERS),
    timers:       !!(flags & RUNTIME_FLAGS.TIMERS),
    ffi:          !!(flags & RUNTIME_FLAGS.FFI),
    x64Ops:       !!(flags & RUNTIME_FLAGS.X64_OPS),
    safeMode:     !!(flags & RUNTIME_FLAGS.SAFE_MODE),
    transport:    !!(flags & RUNTIME_FLAGS.TRANSPORT),
    floatOps:     !!(flags & RUNTIME_FLAGS.FLOAT_OPS),
    advancedMath: !!(flags & RUNTIME_FLAGS.ADVANCED_MATH),
    ops32bit:     !!(flags & RUNTIME_FLAGS.OPS_32BIT),
    cvt:          !!(flags & RUNTIME_FLAGS.CVT),
    stackOps:     !!(flags & RUNTIME_FLAGS.STACK_OPS),
    bitwiseOps:   !!(flags & RUNTIME_FLAGS.BITWISE_OPS),
})

/**
 * Runtime flags constants - matches runtime-types.h PLCRUNTIME_FLAG_* definitions.
 * Useful for manual flag checking: `if (flags & VovkPLC.RUNTIME_FLAGS.TIMERS) { ... }`
 * @type {typeof RUNTIME_FLAGS}
 */// @ts-ignore
VovkPLC_class.RUNTIME_FLAGS = RUNTIME_FLAGS

// Export the module if we are in a browser
if (typeof window !== 'undefined') {
    // console.log(`WASM exported as window object`)
    Object.assign(window, {VovkPLC: VovkPLC_class})
}

// Export for CommonJS modules
if (typeof module !== 'undefined') {
    // console.log(`WASM exported as module`)
    module.exports = VovkPLC_class
}
// Export for ES modules
export default VovkPLC_class
export {VovkPLCWorker, VovkPLCWorkerClient, VovkPLCWorkerInstance}
