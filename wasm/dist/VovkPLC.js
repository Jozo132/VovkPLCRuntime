// @ts-check
'use strict'

/**
 * @file VovkPLC.js
 * @description
 * This file and its companion 'VovkPLC.worker.js' are manually authored components of the VovkPLCRuntime WASM build.
 * They are deliberately hand-written to interface with the bare-metal WASM output generated by clang++ and wasm-ld.
 * This approach avoids standard library bloat, ensuring maximum portability and performance.
 *
 * DO NOT REMOVE OR RENAME THIS FILE OR 'VovkPLC.worker.js'.
 *
 * This module provides a high-level JavaScript wrapper class `VovkPLC` that manages the WebAssembly instance,
 * handles memory interactions, exposes the PLC API, and facilitates communication with the worker thread if used.
 */

const isNodeRuntime = typeof process !== 'undefined' && !!(process.versions && process.versions.node)

/**
 * Robust detection for shared memory and decoding capabilities.
 */
const checkSupport = () => {
    const support = {
        sab: typeof SharedArrayBuffer !== 'undefined',
        atomics: typeof Atomics !== 'undefined',
        decodeShared: false
    }
    
    if (support.sab) {
        try {
            // Verify SAB is actually usable (might be blocked by COOP/COEP)
            new SharedArrayBuffer(8)
            
            // Check if TextDecoder can decode from SharedBufferView directly
            // This avoids an extra copy where supported (e.g. some browsers)
            const sab = new SharedArrayBuffer(1)
            const view = new Uint8Array(sab)
            new TextDecoder().decode(view)
            support.decodeShared = true
        } catch (e) {
            // If new SharedArrayBuffer throws, it's effectively unsupported
            if (e.name === 'ReferenceError' || e.name === 'TypeError') support.sab = false
        }
    }
    return support
}

const SUPPORT = checkSupport()

/**
 * @typedef {{
 *     initialize: () => void, // Initializes the runtime environment and resets internal state.
 *     printInfo: () => void, // Prints runtime configuration and version info to stdout.
 *     streamIn: (char: number) => boolean, // Receives a character byte into the input stream buffer. Returns false if buffer full.
 *     loadAssembly: () => void, // Moves the streamed input buffer into the assembly compiler.
 *     downloadProgram: (size: number, crc: number) => number, // Loads a pre-compiled bytecode program from the input stream. Returns 0 on success, >0 on error (1=size, 2=crc).
 *     compileAssembly: (debug?: boolean) => boolean, // Compiles the loaded assembly code. Returns true if compilation failed.
 *     loadCompiledProgram: () => boolean, // Loads the compiled bytecode into the runtime memory. Returns false on success.
 *     runFullProgram: () => void, // Executes the loaded program fully (standard run).
 *     runFullProgramDebug: () => void, // Executes the loaded program with debug tracing enabled.
 *     uploadProgram: () => number, // Streams the current bytecode out via stdout. Returns the size of the program.
 *     getMemoryLocation: () => number, // Returns the offset of the main memory area.
 *     getMemoryArea: (address: number, size: number) => number, // Streams a requested memory area to stdout. Returns the size processed.
 *     writeMemoryByte: (address: number, byte: number) => number, // Writes a single byte to memory at the specified address. Returns 1 on success.
 *     writeMemoryByteMasked: (address: number, byte: number, mask: number) => number, // Writes a masked byte to memory. (mem & ~mask) | (byte & mask). Returns 1 on success.
 *     getLastCycleTimeUs: () => number, // Returns the execution time of the last cycle in microseconds.
 *     getMinCycleTimeUs: () => number, // Returns the minimum cycle time recorded in microseconds.
 *     getMaxCycleTimeUs: () => number, // Returns the maximum cycle time recorded in microseconds.
 *     getRamFree: () => number, // Returns the current free RAM in bytes.
 *     getMinRamFree: () => number, // Returns the minimum free RAM recorded.
 *     getMaxRamFree: () => number, // Returns the maximum free RAM recorded.
 *     resetDeviceHealth: () => void, // Resets the min/max statistics for cycle time and RAM usage.
 *     get_free_memory: () => number, // Returns currently free memory (allocator status).
 *     doNothing: () => void, // No-op function for testing overhead.
 *     setMillis: (millis: number) => void, // Sets the system millisecond counter.
 *     setMicros: (micros: number) => void, // Sets the system microsecond counter.
 *     getMillis: () => number, // Gets the system millisecond counter.
 *     getMicros: () => number, // Gets the system microsecond counter.
 *     setRuntimeOffsets: (controlOffset: number, inputOffset: number, outputOffset: number, systemOffset: number, markerOffset: number) => void, // Sets the memory offsets for control, input, output, system, and marker areas.
 *     run: () => number, // Executes a single program scan cycle. Returns status code.
 *     runDirty: () => number, // Executed a single cycle without cleaning certain flags (Dirty).
 *     run_unit_test: () => void, // Runs the internal unit test suite.
 *     run_custom_test: () => void, // Runs custom test routines defined in the build.
 *     downloadAssembly: (assembly: string) => boolean, // Helper: Downloads assembly string directly (calls streamIn + loadAssembly).
 *     extractProgram: () => { size: number, output: string }, // Helper: Extracts program (calls uploadProgram + readStream).
 *     memory: WebAssembly.Memory, // The main WebAssembly linear memory.
 *     lint_load_assembly: () => void, // Moves streamed input to the linter buffer.
 *     lint_run: () => void, // Runs the linter on the loaded assembly.
 *     lint_get_problem_count: () => number, // Returns the number of problems found by the linter.
 *     lint_get_problems_pointer: () => number, // Returns a pointer to the array of linter problem structs.
 * }} VovkPLCExportTypes
 */

/**
 * @typedef {{
 *     last_cycle_time_us: number,
 *     min_cycle_time_us: number,
 *     max_cycle_time_us: number,
 *     ram_free: number,
 *     min_ram_free: number,
 *     max_ram_free: number,
 *     total_ram_size: number,
 *     last_period_us: number,
 *     min_period_us: number,
 *     max_period_us: number,
 *     last_jitter_us: number,
 *     min_jitter_us: number,
 *     max_jitter_us: number,
 * }} DeviceHealth
 */

/**
 * Main Interface for the VovkPLC Runtime.
 *
 * @example
 * // 1. Worker Usage (Recommended, Non-blocking)
 * import VovkPLC from './VovkPLC.js';
 * 
 * const worker = await VovkPLC.createWorker('./VovkPLC.wasm');
 * await worker.enableSharedMemory(); // Enable SharedArrayBuffer for high performance
 *
 * const assembly = `
 *   u8.const 10
 *   u8.const 20
 *   u8.add
 *   exit
 * `;
 *
 * // Compile
 * await worker.compile(assembly);
 *
 * // Start the PLC VM
 * await worker.startRuntime();
 *
 * // Monitor Real-time Statistics (Zero-overhead via Shared Memory)
 * setInterval(() => {
 *   const stats = worker.getSharedStatus();
 *   if(stats) console.log(`Cycles: ${stats.cycles} | Last Time: ${stats.last_time}us`);
 * }, 100);
 *
 * // Stop
 * await worker.stopRuntime();
 *
 * @example
 * // 2. Basic Usage (Main Thread / Synchronous)
 * const plc = new VovkPLC();
 * await plc.initialize('./VovkPLC.wasm');
 *
 * plc.compile(`
 *   ptr.const 0
 *   u8.const 42
 *   u8.move
 *   exit
 * `, true); // true = run immediately in debug mode
 * 
 * // Read Memory
 * const mem = plc.readMemoryArea(0, 1);
 * console.log('Value at 0:', mem[0]);
 */
/** @typedef */ // @ts-ignore
class VovkPLC_class {
    /** @type { WebAssembly.Instance | null } */
    wasm = null
    /** @type { VovkPLCExportTypes | null } */
    wasm_exports = null
    /** @type { any } */
    wasmImports
    running = false
    /** @type { boolean } */
    mainLoopActive = false
    silent = false
    console_message = ''
    error_message = ''
    stream_message = ''
    /** @type { Performance | null } */
    perf = null

    /** @type { Uint8Array } */
    crc8_table = new Uint8Array(256)
    crc8_table_loaded = false

    stdout_callback = console.log
    stderr_callback = console.error

    constructor(wasm_path = '') {
        this.wasm_path = wasm_path
    }

    /**
     * Initializes the VovkPLC WebAssembly Runtime.
     * Loads the WASM binary, instantiates the module, and sets up the environment (imports, exports).
     *
     * @param {string} [wasm_path=''] - Path to the VovkPLC.wasm file. If empty, defaults to local dist path.
     * @param {boolean} [debug=false] - If true, enables debug logging during initialization.
     * @param {boolean} [silent=false] - If true, suppresses standard output from the PLC.
     * @returns {Promise<this>} - Returns the initialized instance.
     */
    initialize = async (wasm_path = '', debug = false, silent = false) => {
        wasm_path = wasm_path || this.wasm_path || '/dist/VovkPLC.wasm' // "/wasm_test_cases/string_alloc.wasm"
        this.wasm_path = wasm_path
        if (this.running && this.wasm) return this
        this.running = true
        this.setSilent(!!silent)
        if (debug) console.log('Starting up...')
        /** @type { BufferSource | null } */
        let wasmBuffer = null
        if (!isNodeRuntime) {
            this.perf = globalThis.performance || null
            const wasmFile = await fetch(wasm_path + '?t=' + Date.now()) // Force clean cache
            wasmBuffer = await wasmFile.arrayBuffer()
        } else {
            // @ts-ignore
            this.perf = globalThis.performance || (await import('perf_hooks')).performance
            const fs = await import('fs')
            const path = await import('path')
            const {fileURLToPath} = await import('url')
            let resolvedPath = wasm_path
            if (!resolvedPath || resolvedPath === '/dist/VovkPLC.wasm') {
                resolvedPath = fileURLToPath(new URL('./VovkPLC.wasm', import.meta.url))
            } else if (resolvedPath.startsWith('file:')) {
                resolvedPath = fileURLToPath(resolvedPath)
            } else if (resolvedPath.startsWith('http://') || resolvedPath.startsWith('https://')) {
                const wasmFile = await fetch(resolvedPath)
                wasmBuffer = await wasmFile.arrayBuffer()
            }
            if (!wasmBuffer) {
                wasmBuffer = fs.readFileSync(path.resolve(resolvedPath))
            }
        }
        this.wasmImports = {
            env: {
                stdout: this.console_print,
                stderr: this.console_error,
                streamOut: this.console_stream, // @ts-ignore
                millis: () => Math.round(this.perf.now()), // @ts-ignore
                micros: () => Math.round(this.perf.now() * 1000),
                // memory: new WebAssembly.Memory({ initial: 256, maximum: 512 }),
            },
        }
        const wasmModule = await WebAssembly.compile(wasmBuffer)
        const wasmInstance = await WebAssembly.instantiate(wasmModule, this.wasmImports)
        if (typeof window !== 'undefined') Object.assign(window, wasmInstance.exports) // Assign all exports to the global scope
        if (!wasmInstance) throw new Error('Failed to instantiate WebAssembly module')
        this.wasm = wasmInstance // @ts-ignore
        this.wasm_exports = {...wasmInstance.exports}
        if (!this.wasm_exports) throw new Error('WebAssembly module exports not found')
        this.wasm_exports.initialize()
        this.wasm_exports.downloadAssembly = assembly => this.downloadAssembly(assembly)
        this.wasm_exports.extractProgram = () => this.extractProgram()
        const required_methods = ['printInfo', 'run_unit_test', 'run_custom_test', 'get_free_memory', 'doNothing', 'compileAssembly', 'loadCompiledProgram', 'runFullProgramDebug', 'runFullProgram', 'uploadProgram', 'getMemoryArea', 'writeMemoryByte']
        for (let i = 0; i < required_methods.length; i++) {
            const method = required_methods[i] // @ts-ignore
            if (!this.wasm_exports[method]) throw new Error(`${method} function not found`)
        }
        return this
    }

    /**
     * @typedef {{
     *     type: 'error' | 'warning' | 'info',
     *     line: number,
     *     column: number,
     *     length: number,
     *     message: string,
     *     token_text: string
     * }} LinterProblem
     */

    /**
     * Lints the provided PLCASM assembly code.
     * Streams the assembly to the linter, runs the analysis, and returns a list of problems (errors, warnings).
     *
     * @param {string} assembly - The PLCASM source code to lint.
     * @param {boolean} [debug=false] - If true, streams linter output to console.
     * @returns {LinterProblem[]} - Array of discovered problems.
     */
    lint = (assembly, debug = false) => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.lint_load_assembly) throw new Error("'lint_load_assembly' function not found")
        if (!this.wasm_exports.lint_run) throw new Error("'lint_run' function not found")
        if (!this.wasm_exports.lint_get_problem_count) throw new Error("'lint_get_problem_count' function not found")
        if (!this.wasm_exports.lint_get_problems_pointer) throw new Error("'lint_get_problems_pointer' function not found")

        const wasSilent = this.silent

        // Temporarily disable stream output unless debug is enabled
        if (!debug) {
            this.setSilent(true)
        }

        try {
            // 1. Download assembly to Linter
            let ok = true
            for (let i = 0; i < assembly.length && ok; i++) {
                const char = assembly[i]
                const c = char.charCodeAt(0)
                ok = this.wasm_exports.streamIn(c)
            }
            if (!ok) throw new Error('Failed to stream assembly')
            this.wasm_exports.lint_load_assembly()

            // 2. Run Linter
            this.wasm_exports.lint_run()

            // 3. Get results
            const count = this.wasm_exports.lint_get_problem_count()
            if (count === 0) return []

            const pointer = this.wasm_exports.lint_get_problems_pointer()
            /** @type { LinterProblem[] } */
            const problems = []

            // Struct size = 84 bytes  (4+4+4+4+64+4)
            const struct_size = 84

            // Access memory directly
            const memoryBuffer = this.wasm_exports.memory.buffer
            const view = new DataView(memoryBuffer)

            for (let i = 0; i < count; i++) {
                const offset = pointer + i * struct_size
                const type_int = view.getUint32(offset + 0, true)
                const line = view.getUint32(offset + 4, true)
                const column = view.getUint32(offset + 8, true)
                const length = view.getUint32(offset + 12, true)

                // token_text is 64 bytes at offset 16
                let message = ''
                for (let j = 0; j < 64; j++) {
                    const charCode = view.getUint8(offset + 16 + j)
                    if (charCode === 0) break
                    message += String.fromCharCode(charCode)
                }

                const token_ptr = view.getUint32(offset + 80, true)
                let token_text = ''
                if (token_ptr !== 0 && length > 0) {
                    const token_buf = new Uint8Array(memoryBuffer, token_ptr, length)
                    token_text = new TextDecoder().decode(token_buf)
                }

                problems.push({
                    type: type_int === 2 ? 'error' : type_int === 1 ? 'warning' : 'info',
                    line,
                    column,
                    length,
                    message,
                    token_text,
                })
            }

            return problems
        } finally {
            // Restore original stream callback
            this.setSilent(wasSilent)
            // Clear any accumulated stream output
            if (!debug) {
                this.readStream()
            }
        }
    }

    /**
     * IR Flag constants for instruction classification.
     */
    static IR_FLAGS = {
        NONE: 0x00,
        READ: 0x01,          // Instruction reads from memory
        WRITE: 0x02,         // Instruction writes to memory
        CONST: 0x04,         // Instruction uses an embedded constant
        JUMP: 0x08,          // Instruction is a jump/call
        TIMER: 0x10,         // Instruction is a timer
        LABEL_TARGET: 0x20,  // This address is a jump target (label)
        EDITABLE: 0x40,      // Constant can be edited in-place
    }

    /**
     * IR Operand Type constants.
     */
    static IR_OP_TYPES = {
        NONE: 0, BOOL: 1, I8: 2, U8: 3, I16: 4, U16: 5,
        I32: 6, U32: 7, I64: 8, U64: 9, F32: 10, F64: 11,
        PTR: 12, LABEL: 13
    }

    /**
     * @typedef {{
     *     type: number,        // IR_OP_TYPES value
     *     bytecode_pos: number, // Position within instruction where this operand starts
     *     value: number | bigint  // The operand value (number for 32-bit, bigint for 64-bit)
     * }} IR_Operand
     */

    /**
     * @typedef {{
     *     bytecode_offset: number,  // Offset in bytecode where this instruction starts
     *     source_line: number,       // Source line number (1-based)
     *     source_column: number,     // Source column number (1-based)
     *     bytecode_size: number,     // Size of this instruction in bytes
     *     opcode: number,            // The instruction opcode
     *     flags: number,             // IR_FLAGS combination
     *     operand_count: number,     // Number of operands (0-3)
     *     operands: IR_Operand[]     // Array of operands
     * }} IR_Entry
     */

    /**
     * Gets the Intermediate Representation (IR) for the last compiled assembly.
     * The IR contains metadata about each compiled instruction including:
     * - Bytecode offset and size
     * - Source location (line, column)
     * - Operand information (addresses, constants)
     * - Flags indicating if instruction reads/writes memory, uses constants, etc.
     *
     * This is useful for front-end editors to provide:
     * - Live value monitoring (track which memory addresses are used)
     * - Constant editing (modify embedded constants)
     * - Jump visualization (see control flow)
     *
     * @returns {IR_Entry[]} - Array of IR entries for each compiled instruction.
     */
    getIR = () => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.ir_get_count) throw new Error("'ir_get_count' function not found")
        if (!this.wasm_exports.ir_get_pointer) throw new Error("'ir_get_pointer' function not found")
        if (!this.wasm_exports.ir_get_entry_size) throw new Error("'ir_get_entry_size' function not found")

        const count = this.wasm_exports.ir_get_count()
        if (count === 0) return []

        const pointer = this.wasm_exports.ir_get_pointer()
        const struct_size = this.wasm_exports.ir_get_entry_size()

        /** @type {IR_Entry[]} */
        const entries = []

        // Access memory directly
        const memoryBuffer = this.wasm_exports.memory.buffer
        const view = new DataView(memoryBuffer)

        // IR_Entry layout (72 bytes with alignment):
        // u32 bytecode_offset (0-3)
        // u16 source_line (4-5)
        // u16 source_column (6-7)
        // u8  bytecode_size (8)
        // u8  opcode (9)
        // u8  flags (10)
        // u8  operand_count (11)
        // [4 bytes padding for 8-byte alignment of operands] (12-15)
        // Operands[3] at offset 16, each operand is 16 bytes (8-byte aligned):
        //   u8 type (0)
        //   u8 bytecode_pos (1)
        //   u8 _pad[2] (2-3)
        //   [4 bytes padding for 8-byte alignment] (4-7)
        //   u64 value (8-15) - union
        // Reserved[4] + padding at end

        for (let i = 0; i < count; i++) {
            const offset = pointer + i * struct_size

            const bytecode_offset = view.getUint32(offset + 0, true)
            const source_line = view.getUint16(offset + 4, true)
            const source_column = view.getUint16(offset + 6, true)
            const bytecode_size = view.getUint8(offset + 8)
            const opcode = view.getUint8(offset + 9)
            const flags = view.getUint8(offset + 10)
            const operand_count = view.getUint8(offset + 11)

            /** @type {IR_Operand[]} */
            const operands = []

            for (let j = 0; j < operand_count && j < 3; j++) {
                const op_offset = offset + 16 + (j * 16) // Each operand is 16 bytes (8-byte aligned)
                const op_type = view.getUint8(op_offset + 0)
                const op_bytecode_pos = view.getUint8(op_offset + 1)

                // Read value based on type - value starts at offset 8 within operand (8-byte aligned)
                let op_value
                const IR_OP = VovkPLC_class.IR_OP_TYPES
                switch (op_type) {
                    case IR_OP.BOOL:
                    case IR_OP.U8:
                        op_value = view.getUint8(op_offset + 8)
                        break
                    case IR_OP.I8:
                        op_value = view.getInt8(op_offset + 8)
                        break
                    case IR_OP.U16:
                        op_value = view.getUint16(op_offset + 8, true)
                        break
                    case IR_OP.I16:
                        op_value = view.getInt16(op_offset + 8, true)
                        break
                    case IR_OP.U32:
                    case IR_OP.PTR:
                    case IR_OP.LABEL:
                        op_value = view.getUint32(op_offset + 8, true)
                        break
                    case IR_OP.I32:
                        op_value = view.getInt32(op_offset + 4, true)
                        break
                    case IR_OP.F32:
                        op_value = view.getFloat32(op_offset + 8, true)
                        break
                    case IR_OP.F64:
                        op_value = view.getFloat64(op_offset + 8, true)
                        break
                    case IR_OP.U64:
                        op_value = view.getBigUint64(op_offset + 8, true)
                        break
                    case IR_OP.I64:
                        op_value = view.getBigInt64(op_offset + 8, true)
                        break
                    default:
                        op_value = view.getUint32(op_offset + 8, true)
                }

                operands.push({
                    type: op_type,
                    bytecode_pos: op_bytecode_pos,
                    value: op_value
                })
            }

            entries.push({
                bytecode_offset,
                source_line,
                source_column,
                bytecode_size,
                opcode,
                flags,
                operand_count,
                operands
            })
        }

        return entries
    }

    /**
     * Gets the count of labels defined in the last compilation.
     * @returns {number}
     */
    getLabelsCount = () => {
        if (!this.wasm_exports?.ir_get_labels_count) return 0
        return this.wasm_exports.ir_get_labels_count()
    }

    /**
     * Gets the count of named constants defined in the last compilation.
     * @returns {number}
     */
    getConstsCount = () => {
        if (!this.wasm_exports?.ir_get_consts_count) return 0
        return this.wasm_exports.ir_get_consts_count()
    }

    setSilent = (value = true) => {
        this.silent = value
    }

    /**
     * Retrieves runtime information and configuration from the PLC.
     * Parses the output string containing version, architecture, memory sizes, and offsets.
     *
     * @returns {Object|string} - An object containing runtime properties (version, offsets, etc.) or a raw string if parsing fails.
     */
    printInfo = () => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.printInfo) throw new Error("'printInfo' function not found")
        this.wasm_exports.printInfo()
        const raw = this.readStream().trim()
        if (raw.length === 0) return 'No info available'
        if (raw.startsWith('[') && raw.endsWith(']')) {
            // '[VovkPLCRuntime,WASM,0,1,0,324,2025-03-16 19:16:44,1024,104857,104857,0,16,16,16,32,16,48,16,64,16,704,16,9,848,16,5,Simulator]'
            const content = raw.substring(1, raw.length - 1)
            const parts = content.split(',')
            const base = {
                header: parts[0],
                arch: parts[1],
                version: `${parts[2]}.${parts[3]}.${parts[4]} Build ${parts[5]}`,
                date: parts[6],
                stack: +parts[7],
                memory: +parts[8],
                program: +parts[9],
            }
            if (parts.length >= 27) {
                // New format with timer and counter info
                return {
                    ...base,
                    control_offset: +parts[10],
                    control_size: +parts[11],
                    input_offset: +parts[12],
                    input_size: +parts[13],
                    output_offset: +parts[14],
                    output_size: +parts[15],
                    system_offset: +parts[16],
                    system_size: +parts[17],
                    marker_offset: +parts[18],
                    marker_size: +parts[19],
                    timer_offset: +parts[20],
                    timer_count: +parts[21],
                    timer_struct_size: +parts[22],
                    counter_offset: +parts[23],
                    counter_count: +parts[24],
                    counter_struct_size: +parts[25],
                    device: parts[26],
                }
            }
            if (parts.length >= 21) {
                // Legacy format without timer/counter info
                return {
                    ...base,
                    control_offset: +parts[10],
                    control_size: +parts[11],
                    input_offset: +parts[12],
                    input_size: +parts[13],
                    output_offset: +parts[14],
                    output_size: +parts[15],
                    system_offset: +parts[16],
                    system_size: +parts[17],
                    marker_offset: +parts[18],
                    marker_size: +parts[19],
                    device: parts[20],
                }
            }
            return { // Very old legacy format
                ...base,
                input_offset: +parts[10],
                input_size: +parts[11],
                output_offset: +parts[12],
                output_size: +parts[13],
                device: parts[14],
            }
        }
        console.error(`Invalid info response:`, raw)
        return raw
        // return raw
    }

    /**
     * Retrieves current health statistics of the virtual device.
     * Includes cycle times (last, min, max), RAM usage, period, and jitter.
     * Efficiently reads all stats in a single WASM call via structure pointer.
     *
     * @returns {DeviceHealth} - Object containing performance and memory metrics.
     */
    getDeviceHealth = () => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.getDeviceHealthPtr) throw new Error("'getDeviceHealthPtr' function not found")
        
        const ptr = this.wasm_exports.getDeviceHealthPtr()
        const view = new Uint32Array(this.wasm_memory.buffer, ptr, 13)
        
        return {
            last_cycle_time_us: view[0],
            min_cycle_time_us: view[1],
            max_cycle_time_us: view[2],
            ram_free: view[3],
            min_ram_free: view[4],
            max_ram_free: view[5],
            total_ram_size: view[6],
            last_period_us: view[7],
            min_period_us: view[8],
            max_period_us: view[9],
            last_jitter_us: view[10],
            min_jitter_us: view[11],
            max_jitter_us: view[12],
        }
    }

    /**
     * Resets the device health statistics (min/max cycle times, ram tracking).
     */
    resetDeviceHealth = () => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.resetDeviceHealth) throw new Error("'resetDeviceHealth' function not found")
        this.wasm_exports.resetDeviceHealth()
    }

    /**
     * Gets the total RAM (SRAM) size available on the device in bytes.
     * 
     * @returns {number} - Total RAM size in bytes.
     */
    getTotalRam = () => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.getTotalRam) throw new Error("'getTotalRam' function not found")
        return this.wasm_exports.getTotalRam()
    }

    /**
     * Sets the memory offsets for the PLC runtime memory areas.
     * This allows custom memory layout configuration for control, input, output, system, and marker areas.
     *
     * @param {number} controlOffset - Offset for the control area.
     * @param {number} inputOffset - Offset for the input area.
     * @param {number} outputOffset - Offset for the output area.
     * @param {number} systemOffset - Offset for the system area.
     * @param {number} markerOffset - Offset for the marker area.
     */
    setRuntimeOffsets = (controlOffset, inputOffset, outputOffset, systemOffset, markerOffset) => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.setRuntimeOffsets) throw new Error("'setRuntimeOffsets' function not found")
        this.wasm_exports.setRuntimeOffsets(controlOffset, inputOffset, outputOffset, systemOffset, markerOffset)
    }

    /**
     * Downloads assembly code to the PLC runtime line-by-line via the stream interface.
     * Does not compile, just loads the text into the internal buffer.
     *
     * @param {string} assembly - The assembly code string.
     * @returns {boolean} - True if an error occurred during download, false otherwise.
     */
    downloadAssembly = assembly => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.streamIn) throw new Error("'streamIn' function not found")
        if (!this.wasm_exports.loadAssembly) throw new Error("'loadAssembly' function not found")
        
        let ok = true
        for (let i = 0; i < assembly.length && ok; i++) {
            const char = assembly[i]
            const c = char.charCodeAt(0)
            ok = this.wasm_exports.streamIn(c)
        }
        if (!ok) throw new Error('Failed to download assembly')
        this.wasm_exports.loadAssembly()
        const error = !ok
        return error
    }
    /**
     * Compiles assembly code into executable bytecode within the PLC.
     *
     * @param {string} assembly - The assembly source code (PLCASM or STL depending on language parameter).
     * @param {boolean | { run?: boolean, language?: 'plcasm' | 'stl' }} [options=false] - If boolean, whether to run after compile. If object, contains options.
     * @returns {{size: number, output: string, plcasm?: string}} - The compilation result containing bytecode size, hexdump output, and optionally the generated PLCASM (for STL).
     * @throws {Error} If compilation fails.
     */
    compile(assembly, options = false) {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        
        // Handle backward-compatible boolean parameter
        let run = false
        let language = 'plcasm'
        if (typeof options === 'boolean') {
            run = options
        } else if (typeof options === 'object' && options !== null) {
            run = options.run || false
            language = options.language || 'plcasm'
        }
        
        let plcasmCode = assembly
        let generatedPlcasm = undefined
        
        // If STL language, first transpile to PLCASM
        if (language === 'stl') {
            if (!this.wasm_exports.stl_load_from_stream) throw new Error("'stl_load_from_stream' function not found - STL compiler not available")
            if (!this.wasm_exports.stl_compile) throw new Error("'stl_compile' function not found")
            if (!this.wasm_exports.stl_get_output) throw new Error("'stl_get_output' function not found")
            if (!this.wasm_exports.stl_has_error) throw new Error("'stl_has_error' function not found")
            
            // Stream STL code to compiler
            let ok = true
            for (let i = 0; i < assembly.length && ok; i++) {
                ok = this.wasm_exports.streamIn(assembly.charCodeAt(i))
            }
            if (!ok) throw new Error('Failed to stream STL code')
            this.wasm_exports.streamIn(0) // Null terminator
            
            // Load from stream and compile STL to PLCASM
            this.wasm_exports.stl_load_from_stream()
            const stlSuccess = this.wasm_exports.stl_compile()
            
            if (!stlSuccess) {
                const hasError = this.wasm_exports.stl_has_error()
                if (hasError) {
                    const errorLine = this.wasm_exports.stl_get_error_line ? this.wasm_exports.stl_get_error_line() : 0
                    const errorCol = this.wasm_exports.stl_get_error_column ? this.wasm_exports.stl_get_error_column() : 0
                    throw new Error(`STL compilation failed at line ${errorLine}, column ${errorCol}`)
                }
                throw new Error('STL compilation failed')
            }
            
            // Get the generated PLCASM via stream
            if (this.wasm_exports.stl_output_to_stream) {
                this.wasm_exports.stl_output_to_stream()
                plcasmCode = this.readStream()
                generatedPlcasm = plcasmCode
            }
        }
        
        // Compile PLCASM to bytecode
        if (plcasmCode) {
            this.downloadAssembly(plcasmCode)
        }
        if (!this.wasm_exports.compileAssembly) throw new Error("'compileAssembly' function not found")
        if (!this.wasm_exports.loadCompiledProgram) throw new Error("'loadCompiledProgram' function not found")
        if (this.wasm_exports.compileAssembly(false)) throw new Error('Failed to compile assembly')
        if (run) {
            // this.updateTime()
            this.wasm_exports.loadCompiledProgram()
            this.runDebug()
        }
        const result = this.extractProgram()
        if (generatedPlcasm !== undefined) {
            result.plcasm = generatedPlcasm
        }
        return result
    }

    /**
     * Downloads pre-compiled bytecode to the PLC.
     * Verifies size and CRC checksum during upload.
     *
     * @param {string | number[]} program - Bytecode as a hex string or array of bytes.
     * @returns {number} - 0 if success. Positive integer (1 or 2) indicates error code (size or checksum mismatch).
     * @throws {Error} If verification fails.
     */
    downloadBytecode = program => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.streamIn) throw new Error("'streamIn' function not found")
        if (!this.wasm_exports.downloadProgram) throw new Error("'downloadProgram' function not found")
        const code = Array.isArray(program) ? program : this.parseHex(program)
        const size = code.length
        const crc = this.crc8(code)
        for (let i = 0; i < size; i++) {
            const c = code[i]
            this.wasm_exports.streamIn(c)
        }
        const error = this.wasm_exports.downloadProgram(size, crc)
        if (error === 1) throw new Error('Failed to download program -> size mismatch')
        if (error === 2) throw new Error('Failed to download program -> checksum mismatch')
        return error
    }

    /**
     * Executes the loaded program once (Single Scan).
     * This is the fast execution path without debug overhead.
     *
     * @returns {number} - Result code from execution.
     */
    run = () => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.run) throw new Error("'runFullProgram' function not found")
        // this.updateTime() // Update millis and micros
        return this.wasm_exports.run()
    }

    /**
     * Starts the main-thread runtime loop.
     * Executes the PLC run function repeatedly in a loop (burst mode to avoid blocking UI).
     * WARNING: This runs on the Main Thread. For high performance without blocking UI, use VovkPLC.createWorker().
     *
     * @param {number} [interval=10] - Interval in ms between bursts.
     * @returns {void}
     */
    startRuntime = (interval = 10) => {
        if (this.mainLoopActive) return
        this.mainLoopActive = true
        
        const loop = () => {
            if (!this.mainLoopActive) return
            
            // Execute a burst of cycles (optimized)
            const start = performance.now()
            // Try to run for 8ms max to leave breathing room for UI
            while (performance.now() - start < 8) {
                if (this.wasm_exports) this.wasm_exports.run()
                else break
            }
            
            // Schedule next burst
            if (this.mainLoopActive) {
                setTimeout(loop, interval)
            }
        }
        loop()
    }

    /**
     * Stops the main-thread runtime loop.
     */
    stopRuntime = () => {
        this.mainLoopActive = false
    }

    /**
     * Sets the system millisecond counter.
     * Useful for testing timer-based logic with deterministic time values.
     *
     * @param {number} millis - The millisecond value to set.
     */
    setMillis = millis => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.setMillis) throw new Error("'setMillis' function not found")
        this.wasm_exports.setMillis(millis)
    }

    /**
     * Sets the system microsecond counter.
     * Useful for testing timer-based logic with deterministic time values.
     *
     * @param {number} micros - The microsecond value to set.
     */
    setMicros = micros => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.setMicros) throw new Error("'setMicros' function not found")
        this.wasm_exports.setMicros(micros)
    }

    /**
     * Gets the current system millisecond counter value.
     *
     * @returns {number} - The current millisecond counter value.
     */
    getMillis = () => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.getMillis) throw new Error("'getMillis' function not found")
        return this.wasm_exports.getMillis()
    }

    /**
     * Gets the current system microsecond counter value.
     *
     * @returns {number} - The current microsecond counter value.
     */
    getMicros = () => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.getMicros) throw new Error("'getMicros' function not found")
        return this.wasm_exports.getMicros()
    }

    /**
     * Executes the loaded program once in DEBUG mode.
     * Prints execution trace and stack state to stdout.
     * Use this for step-by-step debugging or detailed analysis.
     *
     * @returns {void}
     */
    runDebug = () => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.runFullProgramDebug) throw new Error("'runFullProgramDebug' function not found")
        // this.updateTime() // Update millis and micros
        return this.wasm_exports.runFullProgramDebug()
    }

    /**
     * Extracts the currently loaded bytecode from the PLC memory.
     * Useful for verifying compilation or saving the binary.
     *
     * @returns {{size: number, output: string}} - Object containing program size and the raw byte string (if streamed).
     */
    extractProgram = () => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.uploadProgram) throw new Error("'uploadProgram' function not found")
        this.stream_message = ''
        const size = +this.wasm_exports.uploadProgram()
        const output = this.readStream()
        return {size, output}
    }

    /**
     * Reads a chunk of memory from the PLC's RAM.
     * Starts reading from the global memory offset defined by the runtime.
     *
     * @param {number} address - Relative address within the PLC memory area.
     * @param {number} [size=1] - Number of bytes to read.
     * @returns {Uint8Array} - Buffer containing the read bytes.
     */
    readMemoryArea = (address, size = 1) => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        // const { getMemoryArea } = this.wasm_exports
        // if (!getMemoryArea) throw new Error("'getMemoryArea' function not found")
        // getMemoryArea(address, size)
        // const output = this.readStream()
        // const { memory, getMemoryLocation } = this.wasm_exports
        if (!this.wasm_exports.memory) throw new Error('WebAssembly memory not found')
        if (!this.wasm_exports.getMemoryLocation) throw new Error("'getMemoryLocation' function not found")
        const offset = this.wasm_exports.getMemoryLocation()
        const buffer = new Uint8Array(this.wasm_exports.memory.buffer, offset + address, size)
        return buffer
    }

    /**
     * Writes data to the PLC's RAM.
     *
     * @param {number} address - Relative address to start writing to.
     * @param {number[]} data - Array of bytes to write.
     * @returns {string} - Any output generated by the write operation (usually empty).
     * @throws {Error} If write fails.
     */
    writeMemoryArea = (address, data) => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.writeMemoryByte) throw new Error("'writeMemoryByte' function not found")
        for (let i = 0; i < data.length; i++) {
            const byte = data[i] & 0xff
            const success = this.wasm_exports.writeMemoryByte(address + i, byte)
            if (!success) throw new Error(`Failed to write byte ${byte} at address ${address + i}`)
        }
        const output = this.readStream()
        return output
    }

    /**
     * Writes data to the PLC's RAM with a bitmask.
     * Only bits set in the mask are modified in the target memory.
     *
     * @param {number} address - Relative address.
     * @param {number[]} data - Bytes to write.
     * @param {number[]} mask - Bitmask for each byte (1=write, 0=keep original).
     * @returns {string} - Output logs.
     */
    writeMemoryAreaMasked = (address, data, mask) => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        if (!this.wasm_exports.writeMemoryByteMasked) throw new Error("'writeMemoryByteMasked' function not found")
        if (data.length !== mask.length) throw new Error('Mask length must match data length')
        for (let i = 0; i < data.length; i++) {
            const byte = data[i] & 0xff
            const maskByte = mask[i] & 0xff
            const success = this.wasm_exports.writeMemoryByteMasked(address + i, byte, maskByte)
            if (!success) throw new Error(`Failed to write byte ${byte} at address ${address + i}`)
        }
        const output = this.readStream()
        return output
    }

    /**
     * Returns the raw WebAssembly exports object.
     * Use this to access low-level WASM functions directly.
     *
     * @returns {VovkPLCExportTypes} - The exports object.
     */
    getExports = () => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized')
        return this.wasm_exports
    }

    /**
     * Calls a specific WebAssembly export by name with arguments.
     *
     * @param {string} name - The name of the exported function.
     * @param {...any} args - Arguments to pass to the function.
     * @returns {any} - The result of the function call.
     * @throws {Error} If export is missing or not a function.
     */
    callExport = (name, ...args) => {
        if (!this.wasm_exports) throw new Error('WebAssembly module not initialized') // @ts-ignore
        const fn = this.wasm_exports[name]
        if (typeof fn !== 'function') throw new Error(`'${name}' export not found`)
        return fn(...args)
    }

    /** @type { (charcode: number) => void } */
    console_print = c => {
        const char = String.fromCharCode(c)
        if (char === '\n') {
            const callback = this.stdout_callback || console.log
            if (this.console_message && this.console_message.length > 0 && !this.silent) callback(this.console_message)
            this.console_message = ''
        } else {
            this.console_message += char
        }
    }

    /** @type { (charcode: number | number[] | string) => void } */
    console_error = charcode => {
        if (typeof charcode === 'string') {
            if (charcode.length === 0) return
            if (charcode.length === 1) return this.console_error(charcode.charCodeAt(0))
            return charcode.split('').forEach(this.console_error)
        }
        if (Array.isArray(charcode)) return charcode.forEach(this.console_error)
        const char = String.fromCharCode(charcode)
        if (char === '\0' || char === '\n') {
            // console.error(this.error_message)
            const callback = this.stderr_callback || console.error
            callback(this.error_message)
            this.error_message = ''
        } else this.error_message += char
    }

    /** @param { (message: string) => void } callback */
    onStdout = callback => {
        this.stdout_callback = callback
    }
    /** @param { (message: string) => void } callback */
    onStderr = callback => {
        this.stderr_callback = callback
    }

    /** @type { (charcode: number | number[] | string) => void } */
    console_stream = charcode => {
        if (typeof charcode === 'string') {
            if (charcode.length === 0) return
            if (charcode.length === 1) return this.console_stream(charcode.charCodeAt(0))
            return charcode.split('').forEach(this.console_stream)
        }
        if (Array.isArray(charcode)) return charcode.forEach(this.console_stream)
        const char = String.fromCharCode(charcode)
        this.stream_message += char
        if (this.stream_message.length > 100000) this.stream_message = this.stream_message.substring(this.stream_message.length - 100000 + 1)
    }

    readStream = () => {
        const output = this.stream_message
        this.stream_message = ''
        return output
    }

    /** @param { number | number[] } data * @param { number } [crc] */
    crc8 = (data, crc = 0) => {
        if (!this.crc8_table_loaded) {
            this.crc8_table_loaded = true
            for (let i = 0; i < 256; i++) {
                let crc8 = i
                for (let j = 0; j < 8; j++) crc8 = crc8 & 0x80 ? (crc8 << 1) ^ 0x31 : crc8 << 1
                this.crc8_table[i] = crc8 & 0xff
            }
        }
        data = Array.isArray(data) ? data : [data]
        const size = data.length
        for (let i = 0; i < size; i++) if (!(data[i] >= 0 && data[i] <= 255)) throw new Error(`Invalid data byte at index ${i}: ${data[i]}`)
        for (let i = 0; i < size; i++) {
            /** @type { number } */
            let index = (crc ^ data[i]) & 0xff
            crc = this.crc8_table[index] & 0xff
        }
        return crc
    }

    /** @param { string } hex_string * @returns { number[] } */
    parseHex = hex_string => {
        // Parse 02x formatted HEX string
        if (typeof hex_string !== 'string') throw new Error(`Invalid HEX string: ${hex_string}`)
        hex_string = hex_string.replace(/[^0-9a-fA-F]/g, '')
        if (hex_string.length % 2 !== 0) throw new Error(`Invalid HEX string length: ${hex_string.length}`)
        const hex_array = hex_string.match(/.{1,2}/g)
        if (!hex_array) throw new Error(`Invalid HEX string: ${hex_string}`)
        const num_array = []
        for (let i = 0; i < hex_array.length; i++) {
            const num = parseInt(hex_array[i], 16)
            if (num < 0 || num > 255) throw new Error(`Invalid HEX string byte at index ${i}: ${hex_array[i]}`)
            num_array.push(num)
        }
        return num_array
    }
    /** @param { string } str * @returns { string } */
    stringToHex = str =>
        str
            .split('')
            .map(c => c.charCodeAt(0).toString(16).padStart(2, '0'))
            .join('')

    //  - PLC reset:        'RS<u8>' (checksum)
    //  - Program download: 'PD<u32><u8[]><u8>' (size, data, checksum)
    //  - Program upload:   'PU<u8>' (checksum)
    //  - Program run:      'PR<u8>' (checksum)
    //  - Program stop:     'PS<u8>' (checksum)
    //  - Memory read:      'MR<u32><u32><u8>' (address, size, checksum)
    //  - Memory write:     'MW<u32><u32><u8[]><u8>' (address, size, data, checksum)
    //  - Memory write mask:'MM<u32><u32><u8[]><u8[]><u8>' (address, size, data, mask, checksum)
    //  - Memory format:    'MF<u32><u32><u8><u8>' (address, size, value, checksum)
    //  - Source download:  'SD<u32><u8[]><u8>' (size, data, checksum) // Only available if PLCRUNTIME_SOURCE_ENABLED is defined
    //  - Source upload:    'SU<u32><u8>' (size, checksum) // Only available if PLCRUNTIME_SOURCE_ENABLED is defined
    buildCommand = {
        /** @returns { string } */
        plcReset: () => {
            const cmd = 'RS'
            const cmd_hex = this.stringToHex(cmd)
            const checksum = this.crc8(this.parseHex(cmd_hex))
            const checksum_hex = checksum.toString(16).padStart(2, '0')
            const command = cmd + checksum_hex
            return command
        },

        /** @param { number[] | [number[]] | [string] } input * @returns { string } */
        programDownload: (...input) => {
            const cmd = 'PD'
            const cmd_hex = this.stringToHex(cmd)
            let checksum = this.crc8(this.parseHex(cmd_hex))
            input = Array.isArray(input[0]) ? input[0] : input
            const allowedChars = '0123456789abcdefABCDEF'
            if (typeof input[0] === 'string')
                input = this.parseHex(
                    input[0]
                        .split('')
                        .filter(c => allowedChars.includes(c))
                        .join('') || ''
                )
            /** @type { number[] } */ // @ts-ignore
            const data = input
            const data_hex = data.map(d => d.toString(16).padStart(2, '0'))
            const size = data.length
            const size_hex_u32 = size.toString(16).padStart(8, '0')
            checksum = this.crc8(this.parseHex(size_hex_u32), checksum)
            checksum = this.crc8(data, checksum)
            const checksum_hex = checksum.toString(16).padStart(2, '0')
            const command = cmd + size_hex_u32 + data_hex.join('') + checksum_hex
            return command.toUpperCase()
        },

        /** @returns { string } */
        programUpload: () => {
            const cmd = 'PU'
            const cmd_hex = this.stringToHex(cmd)
            const checksum = this.crc8(this.parseHex(cmd_hex))
            const checksum_hex = checksum.toString(16).padStart(2, '0')
            const command = cmd + checksum_hex
            return command
        },

        /** @returns { string } */
        programRun: () => {
            const cmd = 'PR'
            const cmd_hex = this.stringToHex(cmd)
            const checksum = this.crc8(this.parseHex(cmd_hex))
            const checksum_hex = checksum.toString(16).padStart(2, '0')
            const command = cmd + checksum_hex
            return command
        },

        /** @returns { string } */
        programStop: () => {
            const cmd = 'PS'
            const cmd_hex = this.stringToHex(cmd)
            const checksum = this.crc8(this.parseHex(cmd_hex))
            const checksum_hex = checksum.toString(16).padStart(2, '0')
            const command = cmd + checksum_hex
            return command
        },

        /** @param { number } address * @param { number } size * @returns { string } */
        memoryRead: (address, size = 1) => {
            const cmd = 'MR'
            const cmd_hex = this.stringToHex(cmd)
            const address_hex_u32 = address.toString(16).padStart(8, '0')
            const size_hex_u32 = size.toString(16).padStart(8, '0')
            let checksum = this.crc8(this.parseHex(cmd_hex))
            checksum = this.crc8(this.parseHex(address_hex_u32), checksum)
            checksum = this.crc8(this.parseHex(size_hex_u32), checksum)
            const checksum_hex = checksum.toString(16).padStart(2, '0')
            const command = cmd + address_hex_u32 + size_hex_u32 + checksum_hex
            return command
        },

        /** @param { number } address * @param { number[] | [number[]] | [string] } input * @returns { string } */
        memoryWrite: (address, input) => {
            const cmd = 'MW'
            const cmd_hex = this.stringToHex(cmd)
            let checksum = this.crc8(this.parseHex(cmd_hex))
            const address_hex_u32 = address.toString(16).padStart(8, '0')
            checksum = this.crc8(this.parseHex(address_hex_u32), checksum)
            input = Array.isArray(input[0]) ? input[0] : input
            const allowedChars = '0123456789abcdefABCDEF'
            if (typeof input[0] === 'string')
                input = this.parseHex(
                    input[0]
                        .split('')
                        .filter(c => allowedChars.includes(c))
                        .join('') || ''
                )
            /** @type { number[] } */ // @ts-ignore
            const data = input
            const data_hex = data.map(d => d.toString(16).padStart(2, '0')).join('')
            const size = data.length
            const size_hex_u32 = size.toString(16).padStart(8, '0')
            checksum = this.crc8(this.parseHex(size_hex_u32), checksum)
            checksum = this.crc8(data, checksum)
            const checksum_hex = checksum.toString(16).padStart(2, '0')
            const command = cmd + address_hex_u32 + size_hex_u32 + data_hex + checksum_hex
            return command
        },

        /** @type { (address: number, data: number[] | [number[]] | [string], mask: number[] | [number[]] | [string]) => string } */
        memoryWriteMask: (address, data, mask) => {
            const cmd = 'MM'
            const cmd_hex = this.stringToHex(cmd)
            let checksum = this.crc8(this.parseHex(cmd_hex))
            const address_hex_u32 = address.toString(16).padStart(8, '0')
            checksum = this.crc8(this.parseHex(address_hex_u32), checksum)
            data = Array.isArray(data[0]) ? data[0] : data
            mask = Array.isArray(mask[0]) ? mask[0] : mask
            const allowedChars = '0123456789abcdefABCDEF'
            if (typeof data[0] === 'string')
                data = this.parseHex(
                    data[0]
                        .split('')
                        .filter(c => allowedChars.includes(c))
                        .join('') || ''
                )
            if (typeof mask[0] === 'string')
                mask = this.parseHex(
                    mask[0]
                        .split('')
                        .filter(c => allowedChars.includes(c))
                        .join('') || ''
                )
            /** @type { number[] } */ // @ts-ignore
            const data_bytes = data
            /** @type { number[] } */ // @ts-ignore
            const mask_bytes = mask
            if (data_bytes.length !== mask_bytes.length) throw new Error('Mask length must match data length')
            const size = data_bytes.length
            const size_hex_u32 = size.toString(16).padStart(8, '0')
            checksum = this.crc8(this.parseHex(size_hex_u32), checksum)
            checksum = this.crc8(data_bytes, checksum)
            checksum = this.crc8(mask_bytes, checksum)
            const data_hex = data_bytes.map(d => d.toString(16).padStart(2, '0')).join('')
            const mask_hex = mask_bytes.map(d => d.toString(16).padStart(2, '0')).join('')
            const checksum_hex = checksum.toString(16).padStart(2, '0')
            const command = cmd + address_hex_u32 + size_hex_u32 + data_hex + mask_hex + checksum_hex
            return command
        },

        /** @param { number } address * @param { number } size * @param { number } value * @returns { string } */
        memoryFormat: (address, size, value) => {
            const cmd = 'MF'
            const cmd_hex = this.stringToHex(cmd)
            const address_hex_u32 = address.toString(16).padStart(8, '0')
            const size_hex_u32 = size.toString(16).padStart(8, '0')
            const value_hex = value.toString(16).padStart(2, '0')
            let checksum = this.crc8(this.parseHex(cmd_hex))
            checksum = this.crc8(this.parseHex(address_hex_u32), checksum)
            checksum = this.crc8(this.parseHex(size_hex_u32), checksum)
            checksum = this.crc8(this.parseHex(value_hex), checksum)
            const checksum_hex = checksum.toString(16).padStart(2, '0')
            const command = cmd + address_hex_u32 + size_hex_u32 + value_hex + checksum_hex
            return command
        },
    }
}

const SHARED_BUFFER_SIZE = 64 * 1024 * 1024 // 64MB
const RING_SIZE = 1024 * 1024 // 1MB for each ring
const OFFSETS = {
    M2S_WRITE: 0, // Master Write Index
    M2S_READ: 4,  // Slave Read Index
    S2M_WRITE: 8, // Slave Write Index
    S2M_READ: 12, // Master Read Index
    LOCK: 16,
    IO_OFFSET: 20,
    IO_IN_SIZE: 24,
    IO_OUT_SIZE: 28,
    M2S_START: 1024,
    S2M_START: 1024 + RING_SIZE,
    DATA_START: 1024 + RING_SIZE * 2
}

/**
 * @typedef {{
 *   postMessage: (message: any, transfer?: Transferable[]) => void,
 *   terminate?: () => any,
 *   addEventListener?: (type: string, listener: (event: any) => void) => void,
 *   removeEventListener?: (type: string, listener: (event: any) => void) => void,
 *   on?: (type: string, listener: (event: any) => void) => void,
 *   off?: (type: string, listener: (event: any) => void) => void,
 *   removeListener?: (type: string, listener: (event: any) => void) => void,
 *   onmessage?: ((event: any) => void) | null,
 *   onerror?: ((error: any) => void) | null,
 * }} VovkPLCWorkerLike
 */

/**
 * @typedef {(url: URL | string) => VovkPLCWorkerLike | Promise<VovkPLCWorkerLike>} VovkPLCWorkerFactory
 */

/**
 * @typedef {{
 *   workerUrl?: URL | string,
 *   workerFactory?: VovkPLCWorkerFactory,
 *   debug?: boolean,
 *   silent?: boolean,
 *   batchFlushDelay?: number,
 *   forcePostMessage?: boolean
 * }} VovkPLCWorkerOptions
 */

/**
 * @typedef {{ resolve: (value: any) => void, reject: (reason?: any) => void }} VovkPLCPendingRequest
 */

class VovkPLCWorkerInstance {
    /** @type { VovkPLCWorkerClient } */
    client
    /** @type { number } */
    id
    /** @param { VovkPLCWorkerClient } client * @param { number } id */
    constructor(client, id) {
        this.client = client
        this.id = id
    }
    /** @type { (method: string, ...args: any[]) => Promise<any> } */
    call = (method, ...args) => this.client.callInstance(this.id, method, ...args)
    /** @type { (name: string, ...args: any[]) => Promise<any> } */
    callExport = (name, ...args) => this.client.callInstance(this.id, 'callExport', name, ...args)
    /** @type { () => Promise<string[]> } */
    getExports = () => this.client.callInstance(this.id, 'getExports')
    /** @type { (callback: (message: string, instanceId?: number) => void) => Promise<any> } */
    onStdout = callback => this.client.onStdout(callback, this.id)
    /** @type { (callback: (message: string, instanceId?: number) => void) => Promise<any> } */
    onStderr = callback => this.client.onStderr(callback, this.id)
    /** @type { () => Promise<any> } */
    dispose = () => this.client.disposeInstance(this.id)
}

class VovkPLCWorkerClient {
    /** @type { VovkPLCWorkerLike } */
    worker
    /** @type { number } */
    nextId = 1
    /** @type { Map<number, VovkPLCPendingRequest> } */
    pending = new Map()
    /** @type { Map<string | number, (message: string, instanceId?: number) => void> } */
    stdoutHandlers = new Map()
    /** @type { Map<string | number, (message: string, instanceId?: number) => void> } */
    stderrHandlers = new Map()
    /** @type { (message: any) => void } */
    _onMessage
    /** @type { (error: any) => void } */
    _onError
    
    /** @type { SharedArrayBuffer | null } */
    sab = null
    /** @type { Int32Array | null } */
    sabI32 = null
    /** @type { Uint8Array | null } */
    sabU8 = null
    
    encoder = new TextEncoder()
    decoder = new TextDecoder()
    
    isPolling = false
    
    // Batched postMessage fallback for high-throughput when SAB unavailable
    /** @type { Array<{id: number, type: string, payload: Record<string, any>}> } */
    batchQueue = []
    /** @type { boolean } */
    batchScheduled = false
    /** @type { number } */
    batchFlushDelay = 20 // ms - batching window for collecting requests (tune for latency vs throughput)
    /** @type { boolean } */
    useBatchedFallback = false
    /** @type { boolean } When true, disables SAB and forces batched postMessage mode */
    forcePostMessage = false

    /** @param { VovkPLCWorkerLike } worker */
    constructor(worker) {
        this.worker = worker
        this._onMessage = this._handleMessage
        this._onError = this._handleError
        
        // Performance optimization: Prefer direct property assignment for Browser Workers
        // This bypasses the EventTarget dispatch chain overhead significantly in high-frequency scenarios
        if ('onmessage' in worker) {
            worker.onmessage = this._onMessage
            worker.onerror = this._onError
        } else if (typeof worker.addEventListener === 'function') {
            worker.addEventListener('message', this._onMessage)
            worker.addEventListener('error', this._onError)
        } else if (typeof worker.on === 'function') {
            worker.on('message', this._onMessage)
            worker.on('error', this._onError)
        }
    }


    /** @type { () => void } */
    startPolling = () => {
        if (this.isPolling) return
        this.isPolling = true
        
        const poll = () => {
            if (!this.sabI32 || !this.sabU8 || !this.isPolling) return
            
            // Allow checking for multiple messages in one poll tick
            while (true) {
                // Check if Data in S2M Ring
                const readIdx = Atomics.load(this.sabI32, OFFSETS.S2M_READ / 4)
                const writeIdx = Atomics.load(this.sabI32, OFFSETS.S2M_WRITE / 4)
                
                if (readIdx === writeIdx) break // Buffer Empty
                
                const start = OFFSETS.S2M_START
                let current = readIdx
                
                // Helper to read wrapping buffer
                const readByte = (/** @type {number} */ idx) => this.sabU8 ? this.sabU8[start + (idx % RING_SIZE)] : 0
                const readU32 = (/** @type {number} */ idx) => {
                    let val = 0
                    val |= readByte(idx)
                    val |= readByte(idx + 1) << 8
                    val |= readByte(idx + 2) << 16
                    val |= readByte(idx + 3) << 24
                    return val
                }
                
                const frameSize = readU32(current)
                const msgId = readU32(current + 4)
                const ok = readByte(current + 8)
                
                // Payload
                const payloadLen = frameSize - 9
                let payload = null
                
                if (payloadLen > 0) {
                    // Extract payload. Since it might wrap, we might need two copies
                    const payloadStart = (current + 9) % RING_SIZE
                    const payloadEnd = (current + 9 + payloadLen) % RING_SIZE
                    
                    if (this.sab && this.sabU8) {
                        if (payloadEnd > payloadStart) {
                            const view = new Uint8Array(this.sab, start + payloadStart, payloadLen)
                            // Use copy-less decode if supported, otherwise fallback to copy
                            const str = this.decoder.decode(SUPPORT.decodeShared ? view : new Uint8Array(view))
                            if (str) payload = JSON.parse(str)
                        } else {
                            // Wrapping
                            const part1Len = RING_SIZE - payloadStart
                            const buf = new Uint8Array(payloadLen)
                            buf.set(new Uint8Array(this.sab, start + payloadStart, part1Len))
                            buf.set(new Uint8Array(this.sab, start, payloadLen - part1Len), part1Len)
                            const str = this.decoder.decode(buf)
                            if (str) payload = JSON.parse(str)
                        }
                    }
                }

                // Handling Message
                const pending = this.pending.get(msgId)
                if (pending) {
                    this.pending.delete(msgId)
                    if (ok) pending.resolve(payload && typeof payload.result !== 'undefined' ? payload.result : payload)
                    else pending.reject(new Error(payload && payload.error ? payload.error : 'Worker call failed'))
                } else if (msgId === 0) { // EVENTS have ID 0
                   // Structure for events: { type: 'event', event: ..., ... }
                   // payload is the message object
                   if (payload && payload.type === 'event') {
                       this._handleEvent(payload)
                   }
                }

                // Advance Read Pointer
                const nextRead = (readIdx + frameSize)
                Atomics.store(this.sabI32, OFFSETS.S2M_READ / 4, nextRead)
            }
            
            if (this.isPolling) {
                 if (isNodeRuntime) setImmediate(poll)
                 else requestAnimationFrame(poll)
            }
        }
        poll()
    }

    /** @type { (message: any) => void } */
    _handleMessage = message => {
        const data = message.data || message
        
        // Check for batched ArrayBuffer response
        if (data instanceof ArrayBuffer) {
            this._parseBatchResponse(data)
            return
        }
        
        // Handle Init Response special case if needed, or fallback for non-shared setup
        if (data.id) {
            const pending = this.pending.get(data.id)
            if (pending) {
                this.pending.delete(data.id)
                if (data.ok) {
                    if (data.type === 'init_ack') {
                       // Received Ack for Init with Shared Memory
                       this.startPolling()
                    }
                    pending.resolve(data.result)
                }
                else pending.reject(new Error(data.error || 'Worker call failed'))
                return
            }
        }
        if (data.type === 'event') {
            this._handleEvent(data)
        }
    }

    /** @type { (data: any) => void } */
    _handleEvent = data => {
        if (!data || typeof data.event !== 'string') return
        const key = data.instanceId == null ? 'default' : data.instanceId
        if (data.event === 'stdout') {
            const handler = this.stdoutHandlers.get(key) || this.stdoutHandlers.get('default')
            if (handler) handler(data.message, data.instanceId)
            return
        }
        if (data.event === 'stderr') {
            const handler = this.stderrHandlers.get(key) || this.stderrHandlers.get('default')
            if (handler) handler(data.message, data.instanceId)
        }
    }

    /** @type { (error: any) => void } */
    _handleError = error => {
        const message = error && error.message ? error.message : String(error)
        const err = error instanceof Error ? error : new Error(message)
        for (const pending of this.pending.values()) pending.reject(err)
        this.pending.clear()
    }

    /** @type { (type: string, payload?: Record<string, any>) => Promise<any> } */
    _send = (type, payload = {}) => {
        const id = this.nextId++
        return new Promise((resolve, reject) => {
            this.pending.set(id, {resolve, reject})
            
            // If Shared Memory is active and not forced to use postMessage, use Ring Buffer
            if (!this.forcePostMessage && this.sab && this.sabI32 && this.sabU8) {
                try {
                    this._writeToRing({id, type, ...payload})
                } catch (e) {
                    reject(e)
                }
            } else if (this.useBatchedFallback) {
                // High-throughput batched fallback
                this._enqueueBatch(id, type, payload)
            } else {
                // Simple postMessage (Init only, before batching is enabled)
                this.worker.postMessage({id, type, ...payload})
            }
        })
    }
    
    /** @type { (id: number, type: string, payload: Record<string, any>) => void } */
    _enqueueBatch = (id, type, payload) => {
        this.batchQueue.push({id, type, payload})
        if (!this.batchScheduled) {
            this.batchScheduled = true
            // Use queueMicrotask for minimal latency, or setTimeout for batching window
            if (this.batchFlushDelay <= 0) {
                queueMicrotask(() => this._flushBatch())
            } else {
                setTimeout(() => this._flushBatch(), this.batchFlushDelay)
            }
        }
    }
    
    /** @type { () => void } */
    _flushBatch = () => {
        this.batchScheduled = false
        if (this.batchQueue.length === 0) return
        
        const ops = this.batchQueue.splice(0, this.batchQueue.length)
        
        // Calculate total size needed
        // Format: [u32 count][...ops]
        // Each op: [u32 id][u8 typeLen][type bytes][u32 payloadLen][payload bytes]
        let totalSize = 4 // count
        const encodedOps = ops.map(op => {
            const typeBytes = this.encoder.encode(op.type)
            const payloadBytes = this.encoder.encode(JSON.stringify(op.payload))
            totalSize += 4 + 1 + typeBytes.length + 4 + payloadBytes.length
            return { id: op.id, typeBytes, payloadBytes }
        })
        
        // Build the buffer
        const buf = new ArrayBuffer(totalSize)
        const dv = new DataView(buf)
        const u8 = new Uint8Array(buf)
        let off = 0
        
        dv.setUint32(off, encodedOps.length, true); off += 4
        
        for (const op of encodedOps) {
            dv.setUint32(off, op.id, true); off += 4
            dv.setUint8(off, op.typeBytes.length); off += 1
            u8.set(op.typeBytes, off); off += op.typeBytes.length
            dv.setUint32(off, op.payloadBytes.length, true); off += 4
            u8.set(op.payloadBytes, off); off += op.payloadBytes.length
        }
        
        // Transfer the buffer (zero-copy)
        this.worker.postMessage(buf, [buf])
    }
    
    /** @type { (buffer: ArrayBuffer) => void } */
    _parseBatchResponse = (buffer) => {
        // Format: [u32 count][...responses]
        // Each response: [u32 id][u8 ok][u32 payloadLen][payload bytes]
        const dv = new DataView(buffer)
        const u8 = new Uint8Array(buffer)
        let off = 0
        
        const count = dv.getUint32(off, true); off += 4
        
        for (let i = 0; i < count; i++) {
            const id = dv.getUint32(off, true); off += 4
            const ok = dv.getUint8(off) === 1; off += 1
            const payloadLen = dv.getUint32(off, true); off += 4
            
            let result = undefined
            let error = undefined
            if (payloadLen > 0) {
                const payloadBytes = u8.subarray(off, off + payloadLen)
                const payloadStr = this.decoder.decode(payloadBytes)
                try {
                    const parsed = JSON.parse(payloadStr)
                    if (ok) result = parsed.result
                    else error = parsed.error
                } catch (e) {
                    error = payloadStr
                }
            }
            off += payloadLen
            
            const pending = this.pending.get(id)
            if (pending) {
                this.pending.delete(id)
                if (ok) pending.resolve(result)
                else pending.reject(new Error(error || 'Worker call failed'))
            }
        }
    }

    /** @param { Record<string, any> } msg */
    _writeToRing = (msg) => {
        if (!this.sabI32 || !this.sabU8) throw new Error('Shared Buffer not initialized')
        // Frame: [TotalSize(4)][ID(4)][TypeLen(1)][Type(utf8)][Payload(json_utf8)]
        const { id, type, ...rest } = msg
        const typeBytes = this.encoder.encode(type)
        const payloadStr = JSON.stringify(rest)
        const payloadBytes = this.encoder.encode(payloadStr)
        
        const totalSize = 4 + 4 + 1 + typeBytes.length + payloadBytes.length
        
        // Wait for space?
        // Simple spin-wait with timeout to avoid freezing main thread indefinitely if worker dead
        const startWait = Date.now()
        let writeIdx, readIdx
        while (true) {
            writeIdx = Atomics.load(this.sabI32, OFFSETS.M2S_WRITE / 4)
            readIdx = Atomics.load(this.sabI32, OFFSETS.M2S_READ / 4)
            if (writeIdx - readIdx + totalSize <= RING_SIZE) break
            if (Date.now() - startWait > 1000) throw new Error('Command Queue Full (Timeout)')
            // Yield? No yield in JS sync function...
        }
        
        const start = OFFSETS.M2S_START
        const current = writeIdx
        
        // Write Helper
        const writeByte = (/** @type {number} */ idx, /** @type {number} */ val) => { if (this.sabU8) this.sabU8[start + (idx % RING_SIZE)] = val }
        const writeU32 = (/** @type {number} */ idx, /** @type {number} */ val) => {
            writeByte(idx, val & 0xff)
            writeByte(idx + 1, (val >> 8) & 0xff)
            writeByte(idx + 2, (val >> 16) & 0xff)
            writeByte(idx + 3, (val >> 24) & 0xff)
        }
        
        writeU32(current, totalSize)
        writeU32(current + 4, id)
        writeByte(current + 8, typeBytes.length)
        
        // Write Type
        let i = 0
        for (; i < typeBytes.length; i++) writeByte(current + 9 + i, typeBytes[i])
        
        // Write Payload
        const payloadStart = 9 + typeBytes.length
        for (let j = 0; j < payloadBytes.length; j++) writeByte(current + payloadStart + j, payloadBytes[j])
        
        // Commit
        const nextWrite = writeIdx + totalSize
        Atomics.store(this.sabI32, OFFSETS.M2S_WRITE / 4, nextWrite)
        Atomics.notify(this.sabI32, OFFSETS.M2S_WRITE / 4) // Wake worker
    }

    /** @type { (stream: 'stdout' | 'stderr', callback: (message: string, instanceId?: number) => void, instanceId?: number | null) => Promise<any> } */
    _setStreamHandler = (stream, callback, instanceId) => {
        if (typeof callback !== 'function') throw new Error('Stream callback must be a function')
        const key = instanceId == null ? 'default' : instanceId
        if (stream === 'stdout') this.stdoutHandlers.set(key, callback)
        else if (stream === 'stderr') this.stderrHandlers.set(key, callback)
        else throw new Error(`Unknown stream type: ${stream}`)
        return this._send('subscribe', {stream, instanceId})
    }

    /** @type { (wasmPath?: string, debug?: boolean, silent?: boolean) => Promise<any> } */
    initialize = (wasmPath = '', debug = false, silent = false) => {
        // Initialize Shared Buffer if supported and not forced to use postMessage
        if (!this.forcePostMessage && SUPPORT.sab && SUPPORT.atomics) {
            try {
                this.sab = new SharedArrayBuffer(SHARED_BUFFER_SIZE)
                this.sabI32 = new Int32Array(this.sab)
                this.sabU8 = new Uint8Array(this.sab)
                
                // Init Queues
                this.sabI32[OFFSETS.M2S_WRITE / 4] = 0
                this.sabI32[OFFSETS.M2S_READ / 4] = 0
                this.sabI32[OFFSETS.S2M_WRITE / 4] = 0
                this.sabI32[OFFSETS.S2M_READ / 4] = 0
                
                // Send init with SAB via postMessage
                // We fake '_send' logic here because we need to attach the SAB
                const id = this.nextId++
                return new Promise((resolve, reject) => {
                    this.pending.set(id, {resolve, reject})
                    // @ts-ignore
                    this.worker.postMessage({id, type: 'init', wasmPath, debug, silent, sharedBuffer: this.sab})
                }).then(res => {
                    // Start Polling once initialized
                    this.startPolling()
                    return res
                })
            } catch(e) {
                console.warn('Failed to create SharedArrayBuffer, falling back to batched postMessage', e)
            }
        }
        // Use batched fallback for high-throughput after init completes
        return this._send('init', {wasmPath, debug, silent}).then(res => {
            // Enable batched mode after successful init (when SAB not available or forcePostMessage is set)
            if (!this.sab || this.forcePostMessage) {
                this.useBatchedFallback = true
            }
            return res
        })
    }
    /** @type { (method: string, ...args: any[]) => Promise<any> } */
    call = (method, ...args) => this._send('call', {method, args})
    /** @type { (instanceId: number | null | undefined, method: string, ...args: any[]) => Promise<any> } */
    callInstance = (instanceId, method, ...args) => this._send('call', {instanceId, method, args})
    /** @type { (wasmPath?: string, debug?: boolean) => Promise<VovkPLCWorkerInstance> } */
    createInstance = (wasmPath = '', debug = false) => this._send('create', {wasmPath, debug}).then(id => new VovkPLCWorkerInstance(this, id))
    /** @type { (instanceId: number | null | undefined) => Promise<any> } */
    disposeInstance = instanceId => this._send('dispose', {instanceId})
    /** @type { (callback: (message: string, instanceId?: number) => void, instanceId?: number | null) => Promise<any> } */
    onStdout = (callback, instanceId = null) => this._setStreamHandler('stdout', callback, instanceId)
    /** @type { (callback: (message: string, instanceId?: number) => void, instanceId?: number | null) => Promise<any> } */
    onStderr = (callback, instanceId = null) => this._setStreamHandler('stderr', callback, instanceId)
    /** @type { (sharedBuffer: SharedArrayBuffer, instanceId?: number | null) => Promise<any> } */
    setupSharedMemory = (sharedBuffer, instanceId = null) => this._send('setup_shared_memory', {sharedBuffer, instanceId})

    /** @type { () => Promise<any> } */
    terminate = async () => {
        for (const pending of this.pending.values()) pending.reject(new Error('Worker terminated'))
        this.pending.clear()
        this.stdoutHandlers.clear()
        this.stderrHandlers.clear()
        if (typeof this.worker.removeEventListener === 'function') {
            this.worker.removeEventListener('message', this._onMessage)
            this.worker.removeEventListener('error', this._onError)
        } else if (typeof this.worker.off === 'function') {
            this.worker.off('message', this._onMessage)
            this.worker.off('error', this._onError)
        } else if (typeof this.worker.removeListener === 'function') {
            this.worker.removeListener('message', this._onMessage)
            this.worker.removeListener('error', this._onError)
        }
        if (typeof this.worker.terminate === 'function') return this.worker.terminate()
    }
}

class VovkPLCWorker extends VovkPLCWorkerClient {
    /** @type { VovkPLC_class } */
    helper
    /** @type { VovkPLC_class['buildCommand'] } */
    buildCommand
    /** @param { VovkPLCWorkerLike } worker */
    constructor(worker) {
        super(worker)
        this.helper = new VovkPLC_class()
        this.buildCommand = this.helper.buildCommand
    }

    /** @type { (wasmPath?: string, options?: VovkPLCWorkerOptions) => Promise<VovkPLCWorker> } */
    static create = async (wasmPath = '', {workerUrl, workerFactory, debug = false, silent = false, batchFlushDelay = 20, forcePostMessage = false} = {}) => {
        const resolvedUrl = workerUrl || new URL('./VovkPLC.worker.js', import.meta.url)
        const factory = workerFactory || (await getDefaultWorkerFactory())
        const worker = await createWorker(factory, resolvedUrl)
        const client = new VovkPLCWorker(worker)
        // Allow tuning batch flush delay (0 = immediate via microtask, >0 = collect requests for N ms)
        client.batchFlushDelay = batchFlushDelay
        // Force postMessage mode (disable SAB even if available)
        client.forcePostMessage = forcePostMessage
        await client.initialize(wasmPath, debug, silent)
        return client
    }

    /** @type { (assembly: string, debug?: boolean) => Promise<any> } */
    lint = (assembly, debug = false) => this.call('lint', assembly, debug)
    /** @type { (value?: boolean) => Promise<any> } */
    setSilent = value => this.call('setSilent', value)
    /** @type { () => Promise<any> } */
    printInfo = () => this.call('printInfo')
    /** @type { () => Promise<DeviceHealth> } */
    getDeviceHealth = () => this.call('getDeviceHealth')
    /** @type { () => Promise<void> } */
    resetDeviceHealth = () => this.call('resetDeviceHealth')
    /** @type { (controlOffset: number, inputOffset: number, outputOffset: number, systemOffset: number, markerOffset: number) => Promise<void> } */
    setRuntimeOffsets = (controlOffset, inputOffset, outputOffset, systemOffset, markerOffset) => this.call('setRuntimeOffsets', controlOffset, inputOffset, outputOffset, systemOffset, markerOffset)
    /** @type { (assembly: string) => Promise<any> } */
    downloadAssembly = assembly => this.call('downloadAssembly', assembly)
    /** @type { (assembly: string, options?: boolean | { run?: boolean, language?: 'plcasm' | 'stl' }) => Promise<any> } */
    compile = (assembly, options = false) => this.call('compile', assembly, options)
    /** @type { (program: string | number[]) => Promise<any> } */
    downloadBytecode = program => this.call('downloadBytecode', program)
    /** @type { () => Promise<any> } */
    run = () => this.call('run')
    /** @type { () => Promise<any> } */
    runDebug = () => this.call('runDebug')
    /** @type { () => Promise<{ size: number, output: string }> } */
    extractProgram = () => this.call('extractProgram')
    /** @type { (address: number, size?: number) => Promise<Uint8Array> } */
    readMemoryArea = (address, size = 1) => this.call('readMemoryArea', address, size)
    /** @type { (address: number, data: number[]) => Promise<string> } */
    writeMemoryArea = (address, data) => this.call('writeMemoryArea', address, data)
    /** @type { (address: number, data: number[], mask: number[]) => Promise<string> } */
    writeMemoryAreaMasked = (address, data, mask) => this.call('writeMemoryAreaMasked', address, data, mask)
    /** @type { () => Promise<string> } */
    readStream = () => this.call('readStream')
    /** @type { () => Promise<string[]> } */
    getExports = () => this.call('getExports')
    /** @type { (name: string, ...args: any[]) => Promise<any> } */
    callExport = (name, ...args) => this.call('callExport', name, ...args)
    /** @type { (millis: number) => Promise<void> } */
    setMillis = millis => this.call('setMillis', millis)
    /** @type { (micros: number) => Promise<void> } */
    setMicros = micros => this.call('setMicros', micros)
    /** @type { () => Promise<number> } */
    getMillis = () => this.call('getMillis')
    /** @type { () => Promise<number> } */
    getMicros = () => this.call('getMicros')
    
    // IR (Intermediate Representation) accessors
    /** @type { () => Promise<import('./VovkPLC.js').IR_Entry[]> } */
    getIR = () => this.call('getIR')
    /** @type { () => Promise<number> } */
    getLabelsCount = () => this.call('getLabelsCount')
    /** @type { () => Promise<number> } */
    getConstsCount = () => this.call('getConstsCount')

    /** @type { SharedArrayBuffer | null } */
    _sharedBuffer = null
    /** @type { Int32Array | null } */
    _sharedControl = null
    /** @type { Uint8Array | null } */
    _sharedInputs = null
    /** @type { Uint8Array | null } */
    _sharedOutputs = null

    get sharedInputs() { 
        if (this.sabU8 && this.sabI32) {
            const offset = this.sabI32[OFFSETS.IO_OFFSET / 4]
            const size = this.sabI32[OFFSETS.IO_IN_SIZE / 4]
            if (offset && size) return new Uint8Array(this.sab, offset, size)
        }
        return this._sharedInputs 
    }
    get sharedOutputs() { 
        if (this.sabU8 && this.sabI32) {
             const offset = this.sabI32[OFFSETS.IO_OFFSET / 4]
             const inSize = this.sabI32[OFFSETS.IO_IN_SIZE / 4]
             const outSize = this.sabI32[OFFSETS.IO_OUT_SIZE / 4]
             if (offset && inSize && outSize) return new Uint8Array(this.sab, offset + inSize, outSize)
        }
        return this._sharedOutputs 
    }
    get sharedControl() { return this._sharedControl }

    /** @type { () => Promise<boolean> } */
    enableSharedMemory = async () => {
        // If we are initialized with SAB, we just need to verify the PLC is ready and pointers are set
        // In VovkPLCWorker (this class), 'this.worker' is the VovkPLCWorkerLike/Client if it's wrapping?
        // Wait, VovkPLCWorker extends VovkPLCWorkerClient.
        // So 'this' IS the client.
        if (!this.sab) return false
        
        // Use the new IO area in the 64MB buffer
        await this.printInfo() // Refresh info internally via stream/console hack? No, we used call before.
        
        // Wait, printInfo writes to stdout. We need to catch it?
        // Actually, we can just call the worker to "map" the IO area now that it has the info.
        
        // We don't need 'enableSharedMemory' logic for buffer creation anymore, 
        // but we might need to tell the worker to populate the IO offsets in the header.
        await this._send('setup_shared_io') 
        return true
    }

    /** @type { (mode?: 'run' | 'pause' | 'step' | 'stop') => void } */
    setSharedMode = (mode = 'run') => {
        // Command is at IO_OFFSET (Control Struct)
        if (!this.sabI32) return
        const offset = this.sabI32[OFFSETS.IO_OFFSET / 4]
        if (!offset) return
        
        const i32 = new Int32Array(this.sab, offset)
        const map = { 'stop': 0, 'run': 1, 'pause': 2, 'step': 3 }
        Atomics.store(i32, 0, map[mode])
        Atomics.notify(i32, 0)
    }

    /**
     * Retrieves the shared status from the worker thread (if using SharedArrayBuffer).
     * This provides atomic access to runtime statistics without overhead.
     *
     * @returns {{ status: number, cycles: number, last_time: number, min_time: number, max_time: number } | null} - Stats object.
     */
    getSharedStatus = () => {
        if (!this.sabI32) return null
        const offset = this.sabI32[OFFSETS.IO_OFFSET / 4]
        if (!offset) return null
        const i32 = new Int32Array(this.sab, offset)
        
        return {
            status: Atomics.load(i32, 1),
            cycles: Atomics.load(i32, 6),
            last_time: Atomics.load(i32, 7),
            min_time: Atomics.load(i32, 8),
            max_time: Atomics.load(i32, 9),
        }
    }
    
    /**
     * Resets execution statistics (cycles, min/max times) via the worker.
     *
     * @returns {Promise<boolean>}
     */
    resetStats = () => this._send('resetStats')

    /**
     * Starts the PLC execution loop in strict mode.
     */
    startRuntime = () => this.setSharedMode('run')

    /**
     * Stops the PLC execution.
     */
    stopRuntime = () => this.setSharedMode('stop')

    /** @type { (data: number | number[], crc?: number) => number } */
    crc8 = (data, crc = 0) => this.helper.crc8(data, crc)
    /** @type { (hex: string) => number[] } */
    parseHex = hex => this.helper.parseHex(hex)
    /** @type { (str: string) => string } */
    stringToHex = str => this.helper.stringToHex(str)
}

/** @type { () => Promise<VovkPLCWorkerFactory> } */
const getDefaultWorkerFactory = async () => {
    if (isNodeRuntime) {
        const {Worker} = await import('worker_threads') // @ts-ignore
        return url => new Worker(url, {type: 'module'})
    }
    if (typeof Worker !== 'undefined') return url => new Worker(url, {type: 'module'})
    throw new Error('Workers are not supported in this environment')
}

/** @type { (factory: VovkPLCWorkerFactory, url: URL | string) => Promise<VovkPLCWorkerLike> } */
const createWorker = async (factory, url) => {
    const worker = factory(url) // @ts-ignore
    return worker && typeof worker.then === 'function' ? await worker : worker
}

/** @type { (wasmPath?: string, options?: VovkPLCWorkerOptions) => Promise<VovkPLCWorker> } */ // @ts-ignore
VovkPLC_class.createWorker = (wasmPath = '', options = {}) => VovkPLCWorker.create(wasmPath, options)

// Export the module if we are in a browser
if (typeof window !== 'undefined') {
    // console.log(`WASM exported as window object`)
    Object.assign(window, {VovkPLC: VovkPLC_class})
}

// Export for CommonJS modules
if (typeof module !== 'undefined') {
    // console.log(`WASM exported as module`)
    module.exports = VovkPLC_class
}
// Export for ES modules
export default VovkPLC_class
export {VovkPLCWorker, VovkPLCWorkerClient, VovkPLCWorkerInstance}
